{
  "dslNameList": [
    "HierarchyDSL",
    "ThinkingDSL",
    "TextLabelsDSL",
    "CodeFlowDSL",
    "PicturesDSL"
  ],
  "view": {
    "scale": 0.905557019777226,
    "position": [
      -2274.5023921235143,
      -343.4246267228914
    ],
    "isGridOn": true
  },
  "model": "{ \"class\": \"GraphLinksModel\",\n  \"copiesArrays\": true,\n  \"copiesArrayObjects\": true,\n  \"copiesKey\": false,\n  \"linkKeyProperty\": \"key\",\n  \"linkFromPortIdProperty\": \"fromPort\",\n  \"linkToPortIdProperty\": \"toPort\",\n  \"nodeDataArray\": [ \n{\"label\":\"Graph Info\", \"category\":\"Property_GraphInfo\", \"size\":\"277 40\", \"rows\":[ {\"name\":\"Name\", \"value\":\"@57.label\"},{\"name\":\"Version\", \"value\":\"1.0\"},{\"name\":\"Date\", \"value\":\"@Common.getDate()\"},{\"name\":\"Path\", \"value\":\"./\"},{\"name\":\"Authors\", \"value\":\"Frankonello\"} ], \"key\":0, \"location\":\"-390 -390\", \"color\":\"SkyBlue\"},\n{\"label\":\"Selection\", \"size\":\"180 60\", \"category\":\"Hierarchy_Selection\", \"isFile\":true, \"fileType\":\"text/json\", \"isSystem\":\"$GraphSelection$\", \"key\":5, \"location\":\"-620 -330\"},\n{\"label\":\"Main web page\", \"category\":\"CodeFlow_Code\", \"size\":\"210 100\", \"in\":[ {\"portId\":\"header@Header.out\"},{\"portId\":\"style\"},{\"portId\":\"scriptBeforeBody\"},{\"portId\":\"body\"},{\"portId\":\"scriptAfterBody\"} ], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":6, \"location\":\"60 379.79999999999995\", \"color\":\"lightsalmon\", \"fileContent\":\"<!--[# Begin out #]-->\\r\\n<!--\\r\\n<!--[# Insert header #]\\r\\n-->\\r\\n\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n  <head>\\r\\n    <title>\\r\\n      <!--[# Define Property #][Replace]-->\\r\\n      <!--:Example page -()-> m.title-->\\r\\n      Example page\\r\\n    </title>\\r\\n    <!--[# Define Property #][Replace]-->\\r\\n    <!--:utf-8 -()-> m.charset-->\\r\\n    <meta charset=utf-8 />\\r\\n    <!--[# Insert style #]-->\\r\\n  </head>\\r\\n  <body>\\r\\n    <!--[# Insert scriptBeforeBody #]-->\\r\\n    <!--[# Define body #]-->\\r\\n    <!--:%b-->\\r\\n    Put page content here\\r\\n    <script>\\r\\n      <!--[# Insert scriptAfterBody #]-->\\r\\n    </script>\\r\\n  </body>\\r\\n</html>\\r\\n<!--[# End out #]-->\", \"editorPosition\":[ 15,741,583,542 ], \"rows\":[ {\"name\":\"title\", \"value\":\"@TitleUpperCase.out\"},{\"name\":\"charset\", \"value\":\"utf-8\"} ], \"group\":40},\n{\"label\":\"Global\", \"category\":\"CodeFlow_Param\", \"size\":\"250 40\", \"rows\":[ {\"name\":\"title\", \"value\":\"SmartBlock Demo\"},{\"name\":\"appTag\", \"value\":\"SBEditor\"} ], \"key\":8, \"location\":\"-1965 -15\", \"group\":53, \"color\":\"sandybrown\"},\n{\"label\":\"smartBlock body\", \"category\":\"CodeFlow_Code\", \"size\":\"290 57\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":12, \"location\":\"-1032.0000000000005 488.69999999999993\", \"color\":\"lightsalmon\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <body>\\n    <!--[# Begin out #]-->\\n    <!--[# Define Property #][Replace]-->\\n    <!--:app -()-> m.appTag-->\\n    <div id=\\\"app\\\"></div>\\n    <!--[# End out #]-->\\n  </body>\\n</html>\", \"rows\":[ {\"name\":\"appTag\", \"value\":\"@Global.appTag\"} ], \"group\":96},\n{\"label\":\"Header\", \"category\":\"CodeFlow_Code\", \"size\":\"220 40\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"Text\", \"fileType\":\"text/text\", \"key\":18, \"location\":\"-1605 14.799999999999997\", \"color\":\"yellow\", \"fileContent\":\"$$[# Begin out #]\\n$$[# Begin Property #][Replace]\\n$$:Christophe LORIN -()-> m.company\\n$$:2021 -()-> m.year\\n$$:MDDTools Main Web Frontend -()-> m.name\\n$$:10.07.2020 -()-> m.date\\n=============================================================================\\nLicensed Materials - Property of Frank Joublin and Antonio Ceravola.\\n(C) Copyright Frank Joublin and Antonio Ceravola. 2021, All Rights Reserved.\\nFrance Government Users Restricted Rights - Use, duplication or disclosure\\nrestricted by GSA ADP Schedule Contract with Frank Joublin and Antonio Ceravola.\\n=============================================================================\\nModule: MDDTools Main Web Frontend\\nDate: 10.07.2020\\n=============================================================================\\n$$[# End Property #]\\n$$[# End out #]\", \"rows\":[ {\"name\":\"date\", \"value\":\"@Graph Info.Date\"},{\"name\":\"name\", \"value\":\"@Global.title\"},{\"name\":\"year\", \"value\":\"@Common.getYear()\"},{\"name\":\"company\", \"value\":\"Lorinware Prod\"} ], \"group\":53},\n{\"label\":\"smartBlock style\", \"category\":\"CodeFlow_Code\", \"size\":\"292 62\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":17, \"location\":\"-1032 259\", \"color\":\"lightsalmon\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <!--[# Begin out #]-->\\n    <link rel=\\\"stylesheet\\\" href=\\\"https://unpkg.com/smartblock@1.3.2/css/smartblock.css\\\" />\\n    <!--[# End out #]-->\\n  </head>\\n</html>\", \"rows\":[], \"group\":96, \"editorPosition\":[ 671,742,400,350 ]},\n{\"label\":\"smartBlock editor script\", \"category\":\"CodeFlow_Code\", \"size\":\"292 58\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":25, \"location\":\"-1032 339\", \"color\":\"lightsalmon\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <!--[# Begin out #]-->\\n    <script src=\\\"https://unpkg.com/smartblock@1.3.2/dist/editor.js\\\"></script>\\n    <!--[# End out #]-->\\n  </head>\\n</html>\", \"rows\":[], \"group\":96},\n{\"label\":\"smartBlock extensions script\", \"category\":\"CodeFlow_Code\", \"size\":\"292 58\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":27, \"location\":\"-2020 319\", \"color\":\"lightsalmon\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <!--[# Begin out #]-->\\n    <script src=\\\"https://unpkg.com/smartblock@1.3.2/dist/extensions.js\\\"></script>\\n    <!--[# End out #]-->\\n  </head>\\n</html>\", \"rows\":[], \"group\":43},\n{\"label\":\"smartBlock customBlock script\", \"category\":\"CodeFlow_Code\", \"size\":\"292 58\", \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":29, \"location\":\"-2020 399\", \"color\":\"lightsalmon\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <head>\\n    <!--[# Begin out #]-->\\n    <script src=\\\"https://unpkg.com/smartblock@1.3.2/dist/customblock.js\\\"></script>\\n    <!--[# End out #]-->\\n  </head>\\n</html>\", \"rows\":[], \"group\":43},\n{\"label\":\"alertBlock definition \", \"category\":\"CodeFlow_Code\", \"size\":\"290 60\", \"rows\":[], \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":33, \"location\":\"-2490 539.8\", \"fileContent\":\"//[# Begin out #]\\r\\nSmartBlock.Extensions.push(\\r\\n\\tnew SmartBlock.CustomBlock(\\r\\n\\t\\t{\\r\\n\\t\\t  tagName: 'div',\\r\\n\\t\\t  className: 'acms-alert',\\r\\n\\t\\t  customName: 'alert',\\r\\n\\t\\t  icon: '!'\\r\\n\\t\\t}\\r\\n\\t)\\r\\n);\\r\\n//[# End out #]\", \"group\":44, \"color\":\"orange\"},\n{\"label\":\"smartBlock Editor declaration\", \"category\":\"CodeFlow_Code\", \"size\":\"290 60\", \"rows\":[ {\"name\":\"appTag\", \"value\":\"@Global.appTag\"} ], \"in\":[ {\"portId\":\"extensions\"},{\"portId\":\"initHTML\"} ], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":35, \"location\":\"-1410 660\", \"fileContent\":\"//[# Begin out #]\\r\\nSmartBlock.Editor(\\r\\n  //[# Define Property #][Replace]\\r\\n  //:app -()-> m.appTag\\r\\n\\t'#app', \\r\\n\\t{\\r\\n    //[# Define initHTML #][ArrayPattern]\\r\\n    //:html: '%i'+\\r\\n    //:      '%i',\\r\\n    html: '<p>Default text if no initial text is specified</p>',\\r\\n    //[# Insert extensions #]\\r\\n\\r\\n\\t\\tonChange: function(result) {\\r\\n\\t\\t\\tconsole.log(result.json, result.html);\\r\\n\\t\\t}\\r\\n\\t}\\r\\n);\\r\\n//[# End out #]\", \"group\":96, \"color\":\"orange\", \"editorPosition\":[ 1205,1232,400,350 ]},\n{\"label\":\"initial HTML\", \"category\":\"CodeFlow_Code\", \"size\":\"290 60\", \"rows\":[], \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":37, \"location\":\"-1995 704.5999999999999\", \"fileContent\":\"<!DOCTYPE html>\\n<html>\\n  <body>\\n    <!--[# Begin out #]-->\\n    <h2>Hello World</h2>\\n    <p>This is an example text</p>\\n    <!--[# End out #]-->\\n  </body>\\n</html>\", \"color\":\"lightsalmon\", \"group\":46},\n{\"label\":\"Main web page\", \"isGroup\":true, \"color\":\"green\", \"key\":40, \"colorSwap\":\"gray\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"alertBlock extensions\", \"category\":\"CodeFlow_Code\", \"size\":\"290 60\", \"rows\":[], \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":42, \"location\":\"-2020 478.0999999999998\", \"fileContent\":\"const a = {\\n  //[# Begin out #]\\n  extensions: SmartBlock.Extensions,\\n  //[# End out #]\\n};\", \"group\":43, \"color\":\"orange\"},\n{\"label\":\"Smart Editor extensions\", \"isGroup\":true, \"color\":\"gray\", \"key\":43, \"colorSwap\":\"green\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"Alert block extension\", \"isGroup\":true, \"color\":\"gray\", \"key\":44, \"colorSwap\":\"green\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"Initial Text\", \"isGroup\":true, \"color\":\"gray\", \"key\":46, \"colorSwap\":\"green\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"index2\", \"size\":\"180 1\", \"category\":\"CodeFlow_File\", \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"fileURL\":\"/fileServer/00/54.html\", \"key\":38, \"location\":\"340 250\", \"color\":\"lightsalmon\", \"group\":40},\n{\"label\":\"Constants\", \"isGroup\":true, \"color\":\"green\", \"key\":53, \"colorSwap\":\"gray\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"Integrator test 1\", \"category\":\"TextLabels_Size5\", \"size\":\"940 30\", \"key\":57, \"location\":\"-550 -570\"},\n{\"label\":\"TitleUpperCase\", \"category\":\"CodeFlow_Operator\", \"size\":\"180 60\", \"in\":[ {\"portId\":\"in@Global.title\"} ], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileContent\":\"const title = getPort('in');\\nsetPort( 'out', title.toUpperCase() );\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":54, \"location\":\"-1565 -55.19999999999999\", \"group\":53, \"color\":\"orange\"},\n{\"label\":\"release 1\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"green\", \"buttons\":[ {\"name\":\"\", \"checked\":true, \"color\":\"RebeccaPurple\"} ], \"key\":51, \"location\":\"-470 1319.8000000000002\", \"group\":85},\n{\"label\":\"release 2\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":56, \"location\":\"-470 1530\", \"group\":85},\n{\"label\":\"1.00\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"green\", \"buttons\":[ {\"name\":\"\", \"checked\":true, \"color\":\"RebeccaPurple\"} ], \"key\":61, \"location\":\"-100 1319.8\", \"group\":85},\n{\"label\":\"1.01\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":64, \"location\":\"-100 1440\", \"group\":85},\n{\"label\":\"1.02\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":69, \"location\":\"-100 1530\", \"group\":85},\n{\"label\":\"Main web page\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"green\", \"buttons\":[ {\"name\":\"\", \"checked\":true, \"color\":\"RebeccaPurple\"} ], \"key\":75, \"location\":\"150 1320\", \"group\":85},\n{\"label\":\"Smart Editor\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"green\", \"buttons\":[ {\"name\":\"\", \"checked\":true, \"color\":\"RebeccaPurple\"} ], \"key\":78, \"location\":\"150 1420\", \"group\":85},\n{\"label\":\"Initial Text\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":80, \"location\":\"150 1470\", \"group\":85},\n{\"label\":\"Alert block extension\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":82, \"location\":\"150 1530\", \"group\":85},\n{\"label\":\"Smart Editor extensions\", \"category\":\"CodeFlow_Feature\", \"size\":\"230 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":84, \"location\":\"380 1530\", \"group\":85},\n{\"label\":\"Code Generation\", \"isGroup\":true, \"color\":\"black\", \"key\":85, \"category\":\"Group_BasicGroup\"},\n{\"label\":\"Pressing this button will deploy the generated file at the target path defined in the parameter\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Deploy\", \"checked\":true} ], \"rows\":[ {\"name\":\"path\", \"value\":\"value1\"} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\nconsole.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\nconsole.log( 'Button Label: '+obj.data.name );\\nconsole.log( 'Button Status: '+obj.data.checked );\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":59, \"location\":\"-140 720\", \"group\":85, \"color\":\"YellowGreen\"},\n{\"label\":\"Pressing this button will generate the application based on the selected features\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Generate 1.4\", \"checked\":false} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Get main graph editor\\nconst g = m.e.getEditor( config.htmlDiv.graphDiv );\\n// Get current graph model\\nconst model = g.getJSONModel();\\nconst modelId = 'main';\\n\\n// Instantiate Model Explorer\\nconst me = new ModelExplorer();\\nme.setJSONModel( modelId, model );\\n\\n// Cache of all data generated or stored in the model\\nconst dataCache = {\\n  //'Header.body': ['Line1', 'Line2', ...],\\n  //'Style.url': ['http://styleServer.come/style.css'],\\n  // Missing entry => generate and add to cache\\n  // Then return the entry content\\n};\\n\\n/************************\\n * Utility functions\\n ************************/\\n// Filter nodes in disabled features as condition for \\\"me\\\" functions\\nfunction filterOutDisabledNodes (d) {\\n  return( !d.isGroup && ( !d.group || activeFeature.has( d.group ) ) ); \\n}\\nfunction isNumber( v ) {\\n  return( parseInt(v).toString() === v.toString() );\\n}\\nfunction getArrayOf( v ) {\\n   if( v instanceof String ) {\\n    return( v.split( '\\\\n' ) );\\n  } else if( Array.isArray( v ) ) {\\n    return( v );\\n  } else {\\n    return( [v] );\\n  }\\n}\\nfunction getId( nodeData, property ) {\\n  return( ( nodeData.label? nodeData.label: nodeData.key ) + ( property? '.'+ property: '' ) );\\n}\\nfunction parseInputPortName( portName ) {\\n  let value = '';\\n  let [name, reference] = portName.split( '@' );\\n  if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    value = getArrayOf( name+'@'+reference );\\n    reference = '';\\n    name = '';\\n  }\\n  if( reference == undefined ) {\\n    reference = '';\\n  }\\n  return({ name, reference, value });\\n}\\n/************************\\n * DataCache functions\\n ************************/\\nfunction getCacheValue( id ) {\\n  let value = [''];\\n  const dValue = dataCache[id];\\n  if( dValue ) {\\n    // Case of ref being defined in the dataCache\\n    value = dValue;\\n  } else {\\n    // Case of ref being not defined in the dataCache\\n    // Split the reference into Name.property\\n    const [name, property] = id.split( '.' );\\n    if( name && property ) {\\n      if( libraryNameList.has( name ) ) {\\n        // Case of a javascript function \\n        eval( `value = getArrayOf( ${property} )` );\\n      } else {\\n        // Case of recursion\\n        value = getValueOfNode( name, property );\\n        setCacheValue( id, value );\\n      }\\n    } else if( name ) {\\n      value = getValueOfNode( name );\\n    } else {\\n      value = [`Error: could not resolve \\\"${id}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction setCacheValue( id, value ) {\\n  if( !dataCache.hasOwnProperty( id ) ) {\\n    dataCache[id] = value;\\n  }\\n}\\n/************************\\n * Generation functions\\n ************************/\\nfunction getFanInNodeValueList( nodeData, portName ) {\\n  let valueList = [];\\n  // Get node from fan in\\n  const linkList = me.getLinkListFanInByNodeKey( 'main', nodeData.key, portName );\\n  if( !linkList || linkList.length == 0 ) {\\n    const value = getValueOfRef( portName, {} ); // Provide {} as empty link\\n    // this is necessary to get an empty value in case the input is not connected\\n    // or connected to a disable node\\n    valueList.push( value );\\n  } else {\\n    for( const linkData of linkList ) {\\n      const refValue = linkData.toPort;\\n      //const fromPort = linkData.fromPort;\\n      const value = getValueOfRef( refValue, linkData );\\n      if( value && value.length > 0 ) {\\n        valueList.push( value );\\n      }\\n    }\\n  }\\n  return( valueList );\\n}\\nfunction getGenerationValueFrom( nodeData, portName ) {\\n  let value = [];\\n  \\n  const valueList = getFanInNodeValueList( nodeData, portName );\\n  if( valueList && valueList.length == 1 ) {\\n    value = valueList[0];\\n  } else {\\n    if( !valueList || valueList.length == 0 ) {\\n      // Reference name is not found in the graph\\n      value = [];\\n    } else {\\n      // Reference name is used multiple time in the graph\\n      value = [`Error: Multiple source enalbled for \\\"${nodeData.label}.${portName}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateNode( nodeData, property ) {\\n  let value = [''];\\n  let id = '';\\n  \\n  switch( nodeData.category ) {\\n    case 'Hierarchy_CodeInGraph':\\n    case 'Hierarchy_CodeInFile':\\n      value = getGenerationValueFrom( nodeData, '' );\\n      nodeData.fileContent = value.join( '\\\\n' );\\n      // NOTE: then next function is async, but we don't handle \\n      // the callback for now\\n      saveNodeContent( nodeData );\\n      id = getId( nodeData );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Code':\\n      // Data model for node code generation\\n      let m = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          let funcName = 'Begin_'+refInfo.name.replaceAll( ' ', '_' );\\n          //m[funcName] = ()=> [inValue];\\n          // We put undefined in case the input is not connected\\n          m[funcName] = ()=> ( inValue.length == 0? undefined: inValue );\\n          funcName = 'Define_'+refInfo.name.replaceAll( ' ', '_' );\\n          //m[funcName] = ()=> [inValue];\\n          m[funcName] = ()=> ( inValue.length == 0? undefined: inValue );\\n          funcName = 'Insert_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> ( inValue.length == 0? undefined: inValue );\\n        }\\n      }\\n      if( nodeData.rows && ( nodeData.rows.length > 0 ) ) {\\n        let objData = {};\\n        for( const row of nodeData.rows ) {\\n          let pValue = getValueOfRef( row.value );\\n          if( Array.isArray( pValue ) && ( pValue.length > 0 ) ) {\\n            pValue = pValue[0];\\n          } else {\\n            pValue = '';\\n          }\\n          objData[row.name] = pValue;\\n        }\\n        funcName = 'Begin_Property';\\n        m[funcName] = ()=> objData;\\n        funcName = 'Define_Property';\\n        m[funcName] = ()=> objData;\\n      }\\n      // Get node template\\n      const templateSource = nodeData.fileContent;\\n      const templateLen = templateSource.length;\\n      // Get the output to be generated\\n      const outputName = property;\\n      // Create the template generator\\n      const tg = new TemplateGenerator( templateSource );\\n      const beginTag = `[# Begin ${outputName} #]`;\\n      const endTag = `[# End ${outputName} #]`;\\n      // Get output template and trim to first line indentation (true)\\n      const block = tg.extractNextLineBlock( true, beginTag, endTag );\\n      //const blockSrc = block.getTemplate();\\n      // Set template language\\n      const [format, language] = nodeData.fileType.split( '/' );\\n      block.setLanguage( language );\\n      block.setProperty( 'isKeepBlockOnNoData', true );\\n      // Execute code generation\\n      block.process( m );\\n      // Get output\\n      value = block.getOutput();\\n      //debug();\\n      break;\\n    case 'CodeFlow_Operator':\\n      let inOutValue = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          inOutValue[refInfo.name] = inValue.join( '\\\\n' );\\n        }\\n      }\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          inOutValue[row.name] = pValue;\\n        }\\n      }\\n      if( nodeData.fileContent ) {\\n        const getPort = (name)=>{ return( inOutValue[name] ); };\\n        const setPort = (name, value)=>{ inOutValue[name] = value; };\\n        eval( nodeData.fileContent );\\n        if( nodeData.out ) {\\n          for( const output of nodeData.out ) {\\n            let oValue = inOutValue[output.portId];\\n            if( oValue ) {\\n              oValue = oValue.split( '\\\\n' );\\n            }\\n            if( property == output.portId ) {\\n              value = oValue;\\n            }\\n          }\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Merge':\\n      value = [];\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          value = value.concat( inValue );\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Param':\\n    case 'Property_GraphInfo':\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          if( row.name == property ) {\\n            value = pValue;\\n          }\\n        }\\n      }\\n      break;\\n  }\\n  return( value );\\n}\\nfunction getValueOfNode( name, property ) {\\n  let value = [''];\\n  let nodeData = null;\\n  \\n  if( isNumber( name ) ) {\\n    // If name is a node key ==> get the node by key\\n    nodeData = me.getNodeByFieldName( 'main', 'key', [name], filterOutDisabledNodes );\\n  } else {\\n    // Find component with label = name\\n    const nodeDataList = me.getNodeListByFieldNameList( 'main', 'label', [name], filterOutDisabledNodes );\\n    if( nodeDataList && nodeDataList.length == 1 ) {\\n      // A unique node is found with this name\\n      nodeData = nodeDataList[0];\\n    } else {\\n      if( !nodeDataList || nodeDataList.length == 0 ) {\\n        // Reference name is not found in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is not a node in the graph`];\\n      } else {\\n        // Reference name is used multiple time in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is a label for multiple nodes in the graph`];\\n      }\\n    }\\n  }\\n  // If we found a node\\n  if( nodeData ) {\\n    value = generateNode( nodeData, property );\\n  }\\n  return( value );\\n}\\nfunction getValueOfRef( refValue, linkData ) {\\n  let value = [];\\n  \\n  const refInfo = parseInputPortName( refValue );\\n  if( ( refInfo.reference == '' ) && \\n      ( refInfo.name == '' ) && \\n      ( refInfo.value ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    value = refInfo.value;\\n  } else if( refInfo.reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = refInfo.reference;\\n    value = getCacheValue( id );\\n  } else {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, filterOutDisabledNodes );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateStartNode( nodeData ) {\\n  generateNode( nodeData );\\n}\\n\\n/************************\\n * Setup functions\\n ************************/\\n// Detect all active features\\nvar activeFeature = new Set();\\nconst featureList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Feature'] );\\nfor( const feature of featureList ) {\\n  if( feature.buttons[0].checked ) {\\n    // We get here all enabled groups (green titla backgound)\\n    const groupData = me.getNodeByFieldName( 'main', 'label', feature.label, (d)=> d.isGroup == true );\\n    if( groupData ) {\\n      activeFeature.add( groupData.key );\\n    }\\n  }\\n}\\n// Load all libraries for code generation\\nconst libraryNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Library'], filterOutDisabledNodes );\\nlet libraryNameList = new Set( ['javascript' ] );\\nfor( const libraryNode of libraryNodeList ) {\\n  // Add the library to the available libraries\\n  libraryNameList.add( libraryNode.label );\\n  // If library has JavaScript code, we load it\\n  if( libraryNode.fileContent ) {\\n    eval( libraryNode.fileContent );\\n  }\\n}\\n/************************\\n * Property caching functions\\n ************************/\\n// Cache all name/value pairs from CodeFlow_Param nodes\\nconst paramNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Param', 'Property_GraphInfo'], filterOutDisabledNodes );\\nfor( const paramNode of paramNodeList ) {\\n  if( nodeData.rows ) {\\n    for( const row of paramNode.rows ) {\\n      const value = getValueOfRef( row.value );\\n    }\\n  }\\n}\\ndebug();\\n/************************\\n * Start generation\\n ************************/\\n// Detect starting nodes for code generation\\nconst categoryList = ['Hierarchy_CodeInGraph','Hierarchy_CodeInFile'];\\nconst startNodeList = me.getNodeListByFieldNameList( 'main', 'category', categoryList, filterOutDisabledNodes );\\nfor( const startNode of startNodeList ) {\\n  generateStartNode( startNode );\\n}\\nconsole.log( dataCache );\\n\\n\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":60, \"location\":\"-140 830\", \"group\":85, \"color\":\"YellowGreen\", \"editorPosition\":[ 3506,1030,768,1295 ]},\n{\"label\":\"Constants\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"green\", \"buttons\":[ {\"name\":\"\", \"checked\":true, \"color\":\"RebeccaPurple\"} ], \"key\":47, \"location\":\"150 1270\", \"group\":85},\n{\"label\":\"\", \"category\":\"CodeFlow_Merge\", \"color\":\"white\", \"rows\":[], \"in\":[ {\"portId\":\"editorExtensions\"},{\"portId\":\"editorDeclaration\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":63, \"location\":\"-862 599\", \"group\":96},\n{\"label\":\"Common\", \"category\":\"CodeFlow_Library\", \"size\":\"180 100\", \"color\":\"orange\", \"isFile\":true, \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":48, \"location\":\"-1925 -135\", \"fileContent\":\"function getDate() {\\n  return( new Date().toString() );\\n}\\nfunction getYear() {\\n  return( new Date().getFullYear() );\\n}\", \"group\":53},\n{\"label\":\"\", \"category\":\"CodeFlow_Merge\", \"color\":\"white\", \"rows\":[], \"in\":[ {\"portId\":\"data@Global.title\"},{\"portId\":\"titleUpperCase\"},{\"portId\":\"com@Global.appTag\"},{\"portId\":\"in@Graph Info.Date\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":70, \"location\":\"-40 -10.100000000000001\", \"group\":71},\n{\"label\":\"test1\", \"isGroup\":true, \"color\":\"gray\", \"key\":71, \"colorSwap\":\"green\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"0.00\", \"category\":\"CodeFlow_FeatureOnOff\", \"size\":\"180 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":79, \"location\":\"-90 1109.6999999999998\", \"group\":85},\n{\"label\":\"Constants\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":91, \"location\":\"150 1110\", \"group\":85},\n{\"label\":\"test1\", \"category\":\"CodeFlow_Feature\", \"size\":\"200 40\", \"color\":\"RebeccaPurple\", \"buttons\":[ {\"name\":\"\", \"checked\":false, \"color\":\"green\"} ], \"key\":92, \"location\":\"150 1160\", \"group\":85},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleCenter\", \"size\":\"150 40\", \"key\":94, \"location\":\"550 -180\", \"label\":\"startNode\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RectangleCenter\", \"size\":\"150 40\", \"key\":97, \"location\":\"770 -180\", \"label\":\"generateNode\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RectangleCenter\", \"size\":\"260 40\", \"key\":50, \"location\":\"1410 -180\", \"label\":\"getGenerationValueFrom\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleLeft\", \"size\":\"150 40\", \"key\":58, \"location\":\"1190 -210\", \"label\":\"NodeLabel\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleLeft\", \"size\":\"150 40\", \"key\":65, \"location\":\"1190 -150\", \"label\":\"NodePort\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RectangleCenter\", \"size\":\"260 40\", \"key\":66, \"location\":\"1880 -320\", \"label\":\"getCacheValue\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleLeft\", \"size\":\"150 40\", \"key\":67, \"location\":\"1940 -250\", \"label\":\"id\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RectangleCenter\", \"size\":\"260 40\", \"key\":68, \"location\":\"1970 -50\", \"label\":\"getFanInNodeInfoList\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleLeft\", \"size\":\"150 40\", \"key\":74, \"location\":\"1760 -70\", \"label\":\"NodeLabel\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_RoundedRectangleLeft\", \"size\":\"150 40\", \"key\":76, \"location\":\"1740 -10\", \"label\":\"NodePort\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_HexagoneCenter\", \"size\":\"150 40\", \"key\":81, \"location\":\"970 -180\", \"label\":\"Loop on input \\nand properties\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_HexagoneCenter\", \"size\":\"150 40\", \"key\":86, \"location\":\"1940 -180\", \"label\":\"Sequence\"},\n{\"tag\":\"tag\", \"type\":\"type\", \"category\":\"Thinking_HexagoneCenter\", \"size\":\"150 40\", \"key\":88, \"location\":\"1730 -180.1\", \"label\":\"Sequence\"},\n{\"label\":\"index\", \"color\":\"lightsalmon\", \"size\":\"180 35\", \"category\":\"Hierarchy_CodeInGraph\", \"isFile\":true, \"fileContent\":\"<!--\\r\\n=============================================================================\\r\\nLicensed Materials - Property of Frank Joublin and Antonio Ceravola.\\r\\n(C) Copyright Lorinware Prod 2022, All Rights Reserved.\\r\\nFrance Government Users Restricted Rights - Use, duplication or disclosure\\r\\nrestricted by GSA ADP Schedule Contract with Lorinware Prod.\\r\\n=============================================================================\\r\\nModule: SmartBlock Demo\\r\\nDate: Mon Sep 05 2022 14:20:45 GMT+0200 (Central European Summer Time)\\r\\n=============================================================================\\r\\n-->\\r\\n\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n  <head>\\r\\n    <title>\\r\\n      SMARTBLOCK DEMO\\r\\n    </title>\\r\\n    <meta charset=utf-8 />\\r\\n    <link rel=\\\"stylesheet\\\" href=\\\"https://unpkg.com/smartblock@1.3.2/css/smartblock.css\\\" />\\r\\n  </head>\\r\\n  <body>\\r\\n    <script src=\\\"https://unpkg.com/smartblock@1.3.2/dist/editor.js\\\"></script>\\r\\n    <div id=\\\"SBEditor\\\"></div>\\r\\n    <script>\\r\\n      SmartBlock.Editor(\\r\\n      \\t'#SBEditor', \\r\\n      \\t{\\r\\n          html: '<p>Default text if no initial text is specified</p>',\\r\\n      \\r\\n      \\t\\tonChange: function(result) {\\r\\n      \\t\\t\\tconsole.log(result.json, result.html);\\r\\n      \\t\\t}\\r\\n      \\t}\\r\\n      );\\r\\n    </script>\\r\\n  </body>\\r\\n</html>\\r\\n\", \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":77, \"location\":\"580 390\"},\n{\"label\":\"Pressing this button will generate the application based on the selected features\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Generate v1.0\", \"checked\":false} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Get main graph editor\\nconst g = m.e.getEditor( config.htmlDiv.graphDiv );\\n// Get current graph model\\nconst model = g.getJSONModel();\\nconst modelId = 'main';\\n\\n// Instantiate Model Explorer\\nconst me = new ModelExplorer();\\nme.setJSONModel( modelId, model );\\n\\n\\n// Detect all active features\\nvar activeFeature = new Set();\\nconst featureList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Feature'] );\\nfor( const feature of featureList ) {\\n  if( feature.buttons[0].checked ) {\\n    //activeFeature.add( feature.label );\\n    const groupData = me.getNodeByFieldName( 'main', 'text', feature.label );\\n    if( groupData ) {\\n      activeFeature.add( groupData.key );\\n    }\\n    //console.log( feature.label );\\n  }\\n}\\n\\n// Extract all constant key/value pairs from CodeFlow_Param nodes\\nconst libraryNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Library'] );\\nlet libraryNameList = new Set( ['javascript' ] );\\nfor( const libraryNode of libraryNodeList ) {\\n  if( libraryNode.group ) {\\n    // Skip node if not active\\n    if( !activeFeature.has( libraryNode.group ) ) {\\n      continue;\\n    }\\n  }\\n  // Add the library to the available libraries\\n  libraryNameList.add( libraryNode.label );\\n  // If library has JavaScript code, we load it\\n  if( libraryNode.fileContent ) {\\n    eval( libraryNode.fileContent );\\n  }\\n}\\n\\n// Cache of all data generated or stored in the model\\nconst dataCache = {\\n  //'Header.body': ['Line1', 'Line2', ...],\\n  //'Style.url': ['url'],\\n  // Missing entry => generate and add to cache\\n  // Then return the entry content\\n};\\n\\nfunction isNumber( v ) {\\n  return( parseInt(v).toString() === v.toString() );\\n}\\nfunction getArrayOf( v ) {\\n   if( v instanceof String ) {\\n    return( v.split( '\\\\n' ) );\\n  } else if( Array.isArray( v ) ) {\\n    return( v );\\n  } else {\\n    return( [v] );\\n  }\\n}\\nfunction getId( nodeData, property ) {\\n  return( (nodeData.label? nodeData.label: nodeData.key) + (property? '.'+ property: ''));\\n}\\nfunction parseInputPortName( portName ) {\\n  let value = '';\\n  let [name, reference] = portName.split( '@' );\\n  if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    value = getArrayOf( name+'@'+reference );\\n    reference = '';\\n    name = '';\\n  }\\n  return({ name, reference, value });\\n}\\nfunction getCacheValue( id ) {\\n  let value = [''];\\n  const dValue = dataCache[id];\\n  if( dValue ) {\\n    // Case of ref being defined in the dataCache\\n    value = dValue;\\n  } else {\\n    // Case of ref being not defined in the dataCache\\n    // Split the reference into Name.property\\n    const [name, property] = id.split( '.' );\\n    if( name && property ) {\\n      if( libraryNameList.has( name ) ) {\\n        // Case of a javascript function \\n        eval( `value = getArrayOf( ${property} )` );\\n      } else {\\n        // Case of recursion\\n        value = getValueOfNode( name, property );\\n        setCacheValue( id, value );\\n      }\\n    } else if( name ) {\\n      value = getValueOfNode( name );\\n    } else {\\n      value = [`Error: could not resolve \\\"${id}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction setCacheValue( id, value ) {\\n  if( !dataCache.hasOwnProperty( id ) ) {\\n    dataCache[id] = value;\\n  }\\n}\\nfunction getFanInNodeValueList( nodeData, portName ) {\\n  let valueList = [];\\n  // Get node from fan in\\n  const linkList = me.getLinkListFanInByNodeKey( 'main', nodeData.key, portName );\\n  if( !linkList || linkList.length == 0 ) {\\n    const value = getValueOfRef( portName, {} ); // Provide {} as empty link\\n    // this is necessary to get an empty value in case the input is not connected\\n    // or connected to a disable node\\n    valueList.push( value );\\n  } else {\\n    for( const linkData of linkList ) {\\n      const refValue = linkData.toPort;\\n      //const fromPort = linkData.fromPort;\\n      const value = getValueOfRef( refValue, linkData );\\n      if( value && value.length > 0 ) {\\n        valueList.push( value );\\n      }\\n    }\\n  }\\n  return( valueList );\\n}\\nfunction getGenerationValueFrom( nodeData, portName ) {\\n  let value = [];\\n  \\n  const valueList = getFanInNodeValueList( nodeData, portName );\\n  if( valueList && valueList.length == 1 ) {\\n    value = valueList[0];\\n  } else {\\n    if( !valueList || valueList.length == 0 ) {\\n      // Reference name is not found in the graph\\n      value = [];\\n    } else {\\n      // Reference name is used multiple time in the graph\\n      value = [`Error: Multiple source enalbled for \\\"${nodeData.label}.${portName}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateNode( nodeData, property ) {\\n  let value = [''];\\n  let id = '';\\n  switch( nodeData.category ) {\\n    case 'Hierarchy_CodeInGraph':\\n      // TODO: Do we need to have files in the midle of a chain\\n      value = getGenerationValueFrom( nodeData, '' );\\n      g.setNodeDataField( nodeData.key, 'fileContent', value.join( '\\\\n' ) );\\n      id = getId( nodeData );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Code':\\n      break;\\n    case 'CodeFlow_Operator':\\n      let inOutValue = {};\\n      for( const input of nodeData.in ) {\\n        const inValue = getGenerationValueFrom( nodeData, input.portId );\\n        const refInfo = parseInputPortName( input.portId );\\n        inOutValue[refInfo.name] = inValue.join( '\\\\n' );\\n      }\\n      if( nodeData.fileContent ) {\\n        const getPort = (name)=>{ return( inOutValue[name] ); };\\n        const setPort = (name, value)=>{ inOutValue[name] = value; };\\n        eval( nodeData.fileContent );\\n        for( const output of nodeData.out ) {\\n          let oValue = inOutValue[output.portId];\\n          if( oValue ) {\\n            oValue = oValue.split( '\\\\n' );\\n          }\\n          if( property == output.portId ) {\\n            value = oValue;\\n          }\\n          id = getId( nodeData, output.portId );\\n          setCacheValue( id, oValue );\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Merge':\\n      value = [];\\n      for( const input of nodeData.in ) {\\n        const inValue = getGenerationValueFrom( nodeData, input.portId );\\n        value = value.concat( inValue );\\n      }\\n      id = getId( nodeData, nodeData.out[0].portId );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Param':\\n    case 'Property_GraphInfo':\\n      for( const row of nodeData.rows ) {\\n        const pValue = getValueOfRef( row.value );\\n        if( row.name == property ) {\\n          value = pValue;\\n        }\\n        id = getId( nodeData, row.name );\\n        setCacheValue( id, pValue );\\n      }\\n      break;\\n  }\\n  return( value );\\n}\\nfunction getValueOfNode( name, property ) {\\n  let value = [''];\\n  let nodeData = null;\\n  \\n  if( isNumber( name ) ) {\\n    // If name is a node key ==> get the node by key\\n    nodeData = me.getNodeByFieldName( 'main', 'key', [name] );\\n  } else {\\n    // Find component with label = name\\n    const nodeDataList = me.getNodeListByFieldNameList( 'main', 'label', [name] );\\n    if( nodeDataList && nodeDataList.length == 1 ) {\\n      // A unique node is found with this name\\n      nodeData = nodeDataList[0];\\n    } else {\\n      if( !nodeDataList || nodeDataList.length == 0 ) {\\n        // Reference name is not found in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is not a node in the graph`];\\n      } else {\\n        // Reference name is used multiple time in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is a label for multiple nodes in the graph`];\\n      }\\n    }\\n  }\\n  // If we found a node\\n  if( nodeData ) {\\n    value = generateNode( nodeData, property );\\n  }\\n  return( value );\\n}\\nfunction getValueOfRef( refValue, linkData ) {\\n  let value = [];\\n  \\n  const refInfo = parseInputPortName( refValue );\\n  if( refInfo.reference == '' && refInfo.name == '' ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    value = refInfo.value;\\n  } else if( refInfo.reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = refInfo.reference;\\n    value = getCacheValue( id );\\n  } else {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      \\n      // Filter nodes in disabled features\\n      const getEnabledNode = (d)=> d.group && activeFeature.has( d.group );\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, getEnabledNode );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }\\n  //const [name, reference] = refValue.split( '@' );\\n  /*if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    reference = reference;\\n    value = getArrayOf( name+'@'+reference );\\n  } else if( reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = reference;\\n    value = getCacheValue( id );\\n  } else  {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      \\n      // Filter nodes in disabled features\\n      const getEnabledNode = (d)=> d.group && activeFeature.has( d.group );\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, getEnabledNode );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }*/\\n  return( value );\\n}\\nfunction generateStartNode( nodeData ) {\\n  const id = getId( nodeData );\\n  const value = getCacheValue( id );\\n  g.setNodeDataField( nodeData.key, 'fileContent', value.join( '\\\\n' ) );\\n}\\n\\n/*\\n// Extract all constant key/value pairs from CodeFlow_Param nodes\\nconst paramNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Param'] );\\nfor( const paramNode of paramNodeList ) {\\n  if( paramNode.group ) {\\n    // Skip node if not active\\n    if( !activeFeature.has( paramNode.group ) ) {\\n      continue;\\n    }\\n  }\\n  for( const row of paramNode.rows ) {\\n    const value = getValueOfRef( row.value );\\n    dataCache[paramNode.label+'.'+row.name] = value;\\n  }\\n}\\nconsole.log( parameters );\\n*/\\n\\ndebug();\\n// Detect starting nodes for code generation\\nconst startNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['Hierarchy_CodeInGraph'] );\\nfor( const startNode of startNodeList ) {\\n  if( startNode.group ) {\\n    // Skip node if not active\\n    if( !activeFeature.has( startNode.group ) ) {\\n      continue;\\n    }\\n  }\\n  generateStartNode( startNode );\\n}\\n\\n\\n\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":72, \"location\":\"720 650\", \"color\":\"YellowGreen\", \"editorPosition\":[ 1775,13,820,1957 ]},\n{\"label\":\"Pressing this button will generate the application based on the selected features\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Generate 1.1\", \"checked\":false} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Get main graph editor\\nconst g = m.e.getEditor( config.htmlDiv.graphDiv );\\n// Get current graph model\\nconst model = g.getJSONModel();\\nconst modelId = 'main';\\n\\n// Instantiate Model Explorer\\nconst me = new ModelExplorer();\\nme.setJSONModel( modelId, model );\\n\\n// Cache of all data generated or stored in the model\\nconst dataCache = {\\n  //'Header.body': ['Line1', 'Line2', ...],\\n  //'Style.url': ['http://styleServer.come/style.css'],\\n  // Missing entry => generate and add to cache\\n  // Then return the entry content\\n};\\n\\n/************************\\n * Utility functions\\n ************************/\\n// Filter nodes in disabled features as condition for \\\"me\\\" functions\\nfunction filterOutDisabledNodes (d) {\\n  return( !d.group || activeFeature.has( d.group ) ); \\n}\\nfunction isNumber( v ) {\\n  return( parseInt(v).toString() === v.toString() );\\n}\\nfunction getArrayOf( v ) {\\n   if( v instanceof String ) {\\n    return( v.split( '\\\\n' ) );\\n  } else if( Array.isArray( v ) ) {\\n    return( v );\\n  } else {\\n    return( [v] );\\n  }\\n}\\nfunction getId( nodeData, property ) {\\n  return( (nodeData.label? nodeData.label: nodeData.key) + (property? '.'+ property: ''));\\n}\\nfunction parseInputPortName( portName ) {\\n  let value = '';\\n  let [name, reference] = portName.split( '@' );\\n  if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    value = getArrayOf( name+'@'+reference );\\n    reference = '';\\n    name = '';\\n  }\\n  return({ name, reference, value });\\n}\\n\\n/************************\\n * Setup functions\\n ************************/\\n// Detect all active features\\nvar activeFeature = new Set();\\nconst featureList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Feature'] );\\nfor( const feature of featureList ) {\\n  if( feature.buttons[0].checked ) {\\n    const groupData = me.getNodeByFieldName( 'main', 'text', feature.label );\\n    if( groupData ) {\\n      activeFeature.add( groupData.key );\\n    }\\n  }\\n}\\n// Extract all constant key/value pairs from CodeFlow_Param nodes\\nconst libraryNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Library'], filterOutDisabledNodes );\\nlet libraryNameList = new Set( ['javascript' ] );\\nfor( const libraryNode of libraryNodeList ) {\\n  // Add the library to the available libraries\\n  libraryNameList.add( libraryNode.label );\\n  // If library has JavaScript code, we load it\\n  if( libraryNode.fileContent ) {\\n    eval( libraryNode.fileContent );\\n  }\\n}\\n/************************\\n * DataCache functions\\n ************************/\\nfunction getCacheValue( id ) {\\n  let value = [''];\\n  const dValue = dataCache[id];\\n  if( dValue ) {\\n    // Case of ref being defined in the dataCache\\n    value = dValue;\\n  } else {\\n    // Case of ref being not defined in the dataCache\\n    // Split the reference into Name.property\\n    const [name, property] = id.split( '.' );\\n    if( name && property ) {\\n      if( libraryNameList.has( name ) ) {\\n        // Case of a javascript function \\n        eval( `value = getArrayOf( ${property} )` );\\n      } else {\\n        // Case of recursion\\n        value = getValueOfNode( name, property );\\n        setCacheValue( id, value );\\n      }\\n    } else if( name ) {\\n      value = getValueOfNode( name );\\n    } else {\\n      value = [`Error: could not resolve \\\"${id}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction setCacheValue( id, value ) {\\n  if( !dataCache.hasOwnProperty( id ) ) {\\n    dataCache[id] = value;\\n  }\\n}\\n/************************\\n * Generation functions\\n ************************/\\nfunction getFanInNodeValueList( nodeData, portName ) {\\n  let valueList = [];\\n  // Get node from fan in\\n  const linkList = me.getLinkListFanInByNodeKey( 'main', nodeData.key, portName );\\n  if( !linkList || linkList.length == 0 ) {\\n    const value = getValueOfRef( portName, {} ); // Provide {} as empty link\\n    // this is necessary to get an empty value in case the input is not connected\\n    // or connected to a disable node\\n    valueList.push( value );\\n  } else {\\n    for( const linkData of linkList ) {\\n      const refValue = linkData.toPort;\\n      //const fromPort = linkData.fromPort;\\n      const value = getValueOfRef( refValue, linkData );\\n      if( value && value.length > 0 ) {\\n        valueList.push( value );\\n      }\\n    }\\n  }\\n  return( valueList );\\n}\\nfunction getGenerationValueFrom( nodeData, portName ) {\\n  let value = [];\\n  \\n  const valueList = getFanInNodeValueList( nodeData, portName );\\n  if( valueList && valueList.length == 1 ) {\\n    value = valueList[0];\\n  } else {\\n    if( !valueList || valueList.length == 0 ) {\\n      // Reference name is not found in the graph\\n      value = [];\\n    } else {\\n      // Reference name is used multiple time in the graph\\n      value = [`Error: Multiple source enalbled for \\\"${nodeData.label}.${portName}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateNode( nodeData, property ) {\\n  let value = [''];\\n  let id = '';\\n  \\n  switch( nodeData.category ) {\\n    case 'Hierarchy_CodeInGraph':\\n      // TODO: Do we need to have files in the midle of a chain\\n      value = getGenerationValueFrom( nodeData, '' );\\n      g.setNodeDataField( nodeData.key, 'fileContent', value.join( '\\\\n' ) );\\n      id = getId( nodeData );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Code':\\n      break;\\n    case 'CodeFlow_Operator':\\n      let inOutValue = {};\\n      for( const input of nodeData.in ) {\\n        const inValue = getGenerationValueFrom( nodeData, input.portId );\\n        const refInfo = parseInputPortName( input.portId );\\n        inOutValue[refInfo.name] = inValue.join( '\\\\n' );\\n      }\\n      if( nodeData.fileContent ) {\\n        const getPort = (name)=>{ return( inOutValue[name] ); };\\n        const setPort = (name, value)=>{ inOutValue[name] = value; };\\n        eval( nodeData.fileContent );\\n        for( const output of nodeData.out ) {\\n          let oValue = inOutValue[output.portId];\\n          if( oValue ) {\\n            oValue = oValue.split( '\\\\n' );\\n          }\\n          if( property == output.portId ) {\\n            value = oValue;\\n          }\\n          id = getId( nodeData, output.portId );\\n          setCacheValue( id, oValue );\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Merge':\\n      value = [];\\n      for( const input of nodeData.in ) {\\n        const inValue = getGenerationValueFrom( nodeData, input.portId );\\n        value = value.concat( inValue );\\n      }\\n      id = getId( nodeData, nodeData.out[0].portId );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Param':\\n    case 'Property_GraphInfo':\\n      for( const row of nodeData.rows ) {\\n        const pValue = getValueOfRef( row.value );\\n        if( row.name == property ) {\\n          value = pValue;\\n        }\\n        id = getId( nodeData, row.name );\\n        setCacheValue( id, pValue );\\n      }\\n      break;\\n  }\\n  return( value );\\n}\\nfunction getValueOfNode( name, property ) {\\n  let value = [''];\\n  let nodeData = null;\\n  \\n  if( isNumber( name ) ) {\\n    // If name is a node key ==> get the node by key\\n    nodeData = me.getNodeByFieldName( 'main', 'key', [name] );\\n  } else {\\n    // Find component with label = name\\n    const nodeDataList = me.getNodeListByFieldNameList( 'main', 'label', [name], filterOutDisabledNodes );\\n    if( nodeDataList && nodeDataList.length == 1 ) {\\n      // A unique node is found with this name\\n      nodeData = nodeDataList[0];\\n    } else {\\n      if( !nodeDataList || nodeDataList.length == 0 ) {\\n        // Reference name is not found in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is not a node in the graph`];\\n      } else {\\n        // Reference name is used multiple time in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is a label for multiple nodes in the graph`];\\n      }\\n    }\\n  }\\n  // If we found a node\\n  if( nodeData ) {\\n    value = generateNode( nodeData, property );\\n  }\\n  return( value );\\n}\\nfunction getValueOfRef( refValue, linkData ) {\\n  let value = [];\\n  \\n  const refInfo = parseInputPortName( refValue );\\n  if( refInfo.reference == '' && refInfo.name == '' ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    value = refInfo.value;\\n  } else if( refInfo.reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = refInfo.reference;\\n    value = getCacheValue( id );\\n  } else {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, filterOutDisabledNodes );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateStartNode( nodeData ) {\\n  generateNode( nodeData );\\n}\\n\\n/************************\\n * Property caching functions\\n ************************/\\n// Extract all constant key/value pairs from CodeFlow_Param nodes\\nconst paramNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Param'], filterOutDisabledNodes );\\nfor( const paramNode of paramNodeList ) {\\n  for( const row of paramNode.rows ) {\\n    const value = getValueOfRef( row.value );\\n    const id = getId( paramNode, row.name );\\n    setCacheValue( id, value );\\n  }\\n}\\n//debug();\\n/************************\\n * Start generation\\n ************************/\\n// Detect starting nodes for code generation\\nconst startNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['Hierarchy_CodeInGraph'], filterOutDisabledNodes );\\nfor( const startNode of startNodeList ) {\\n  generateStartNode( startNode );\\n}\\n\\n\\n\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":73, \"location\":\"720 740\", \"color\":\"YellowGreen\", \"editorPosition\":[ 1775,13,820,1957 ]},\n{\"label\":\"TitleLowerCase\", \"category\":\"CodeFlow_Operator\", \"size\":\"180 60\", \"in\":[ {\"portId\":\"input\"} ], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileContent\":\"const title = getPort('input');\\nsetPort( 'out', title.toLowerCase() );\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":83, \"location\":\"-1125 15\", \"group\":53, \"color\":\"orange\"},\n{\"label\":\"\", \"category\":\"CodeFlow_Merge\", \"color\":\"white\", \"rows\":[], \"in\":[ {\"portId\":\"smartBlock\"},{\"portId\":\"smartBlockStyle\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":89, \"location\":\"-270 250\", \"group\":40},\n{\"label\":\"\", \"category\":\"CodeFlow_Merge\", \"color\":\"white\", \"rows\":[], \"in\":[ {\"portId\":\"smartBlockEditor \"},{\"portId\":\"smartBlockExtensions\"},{\"portId\":\"smartBlockCustomBlock\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":93, \"location\":\"-260 334.277152501692\", \"group\":40},\n{\"label\":\"Code in Graph\", \"color\":\"yellow\", \"size\":\"180 35\", \"category\":\"Hierarchy_CodeInGraph\", \"isFile\":true, \"fileContent\":\"=============================================================================\\nLicensed Materials - Property of Frank Joublin and Antonio Ceravola.\\n(C) Copyright Lorinware Prod 2022, All Rights Reserved.\\nFrance Government Users Restricted Rights - Use, duplication or disclosure\\nrestricted by GSA ADP Schedule Contract with Lorinware Prod.\\n=============================================================================\\nModule: SmartBlock Demo\\nDate: Mon Sep 05 2022 14:20:45 GMT+0200 (Central European Summer Time)\\n=============================================================================\", \"fileTypeName\":\"Text\", \"fileType\":\"text/text\", \"key\":90, \"location\":\"-810 -90\", \"editorPosition\":[ 1012,1123,642,428 ]},\n{\"label\":\"\", \"category\":\"CodeFlow_Merge\", \"color\":\"white\", \"rows\":[], \"in\":[ {\"portId\":\"body\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":95, \"location\":\"-260 400\", \"group\":40},\n{\"label\":\"Model\", \"size\":\"180 60\", \"category\":\"Hierarchy_Model\", \"isFile\":true, \"fileType\":\"text/json\", \"isSystem\":\"$GraphModel$\", \"key\":99, \"location\":\"-620 -390\"},\n{\"label\":\"Pressing this button will generate the application based on the selected features\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Generate 1.2\", \"checked\":true} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Get main graph editor\\nconst g = m.e.getEditor( config.htmlDiv.graphDiv );\\n// Get current graph model\\nconst model = g.getJSONModel();\\nconst modelId = 'main';\\n\\n// Instantiate Model Explorer\\nconst me = new ModelExplorer();\\nme.setJSONModel( modelId, model );\\n\\n// Cache of all data generated or stored in the model\\nconst dataCache = {\\n  //'Header.body': ['Line1', 'Line2', ...],\\n  //'Style.url': ['http://styleServer.come/style.css'],\\n  // Missing entry => generate and add to cache\\n  // Then return the entry content\\n};\\n\\n/************************\\n * Utility functions\\n ************************/\\n// Filter nodes in disabled features as condition for \\\"me\\\" functions\\nfunction filterOutDisabledNodes (d) {\\n  return( !d.group || activeFeature.has( d.group ) ); \\n}\\nfunction isNumber( v ) {\\n  return( parseInt(v).toString() === v.toString() );\\n}\\nfunction getArrayOf( v ) {\\n   if( v instanceof String ) {\\n    return( v.split( '\\\\n' ) );\\n  } else if( Array.isArray( v ) ) {\\n    return( v );\\n  } else {\\n    return( [v] );\\n  }\\n}\\nfunction getId( nodeData, property ) {\\n  return( ( nodeData.label? nodeData.label: nodeData.key ) + ( property? '.'+ property: '' ) );\\n}\\nfunction parseInputPortName( portName ) {\\n  let value = '';\\n  let [name, reference] = portName.split( '@' );\\n  if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    value = getArrayOf( name+'@'+reference );\\n    reference = '';\\n    name = '';\\n  }\\n  return({ name, reference, value });\\n}\\n/************************\\n * DataCache functions\\n ************************/\\nfunction getCacheValue( id ) {\\n  let value = [''];\\n  const dValue = dataCache[id];\\n  if( dValue ) {\\n    // Case of ref being defined in the dataCache\\n    value = dValue;\\n  } else {\\n    // Case of ref being not defined in the dataCache\\n    // Split the reference into Name.property\\n    const [name, property] = id.split( '.' );\\n    if( name && property ) {\\n      if( libraryNameList.has( name ) ) {\\n        // Case of a javascript function \\n        eval( `value = getArrayOf( ${property} )` );\\n      } else {\\n        // Case of recursion\\n        value = getValueOfNode( name, property );\\n        setCacheValue( id, value );\\n      }\\n    } else if( name ) {\\n      value = getValueOfNode( name );\\n    } else {\\n      value = [`Error: could not resolve \\\"${id}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction setCacheValue( id, value ) {\\n  if( !dataCache.hasOwnProperty( id ) ) {\\n    dataCache[id] = value;\\n  }\\n}\\n/************************\\n * Generation functions\\n ************************/\\nfunction getFanInNodeValueList( nodeData, portName ) {\\n  let valueList = [];\\n  // Get node from fan in\\n  const linkList = me.getLinkListFanInByNodeKey( 'main', nodeData.key, portName );\\n  if( !linkList || linkList.length == 0 ) {\\n    const value = getValueOfRef( portName, {} ); // Provide {} as empty link\\n    // this is necessary to get an empty value in case the input is not connected\\n    // or connected to a disable node\\n    valueList.push( value );\\n  } else {\\n    for( const linkData of linkList ) {\\n      const refValue = linkData.toPort;\\n      //const fromPort = linkData.fromPort;\\n      const value = getValueOfRef( refValue, linkData );\\n      if( value && value.length > 0 ) {\\n        valueList.push( value );\\n      }\\n    }\\n  }\\n  return( valueList );\\n}\\nfunction getGenerationValueFrom( nodeData, portName ) {\\n  let value = [];\\n  \\n  const valueList = getFanInNodeValueList( nodeData, portName );\\n  if( valueList && valueList.length == 1 ) {\\n    value = valueList[0];\\n  } else {\\n    if( !valueList || valueList.length == 0 ) {\\n      // Reference name is not found in the graph\\n      value = [];\\n    } else {\\n      // Reference name is used multiple time in the graph\\n      value = [`Error: Multiple source enalbled for \\\"${nodeData.label}.${portName}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateNode( nodeData, property ) {\\n  let value = [''];\\n  let id = '';\\n  \\n  switch( nodeData.category ) {\\n    case 'Hierarchy_CodeInGraph':\\n      value = getGenerationValueFrom( nodeData, '' );\\n      g.setNodeDataField( nodeData.key, 'fileContent', value.join( '\\\\n' ) );\\n      id = getId( nodeData );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Code':\\n      // Data model for node code generation\\n      let m = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          let funcName = 'Begin_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n          funcName = 'Define_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n          funcName = 'Insert_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n        }\\n      }\\n      if( nodeData.rows ) {\\n        let objData = {};\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          objData[row.name] = pValue;\\n        }\\n        funcName = 'Begin_Property';\\n        m[funcName] = ()=> objData;\\n        funcName = 'Define_Property';\\n        m[funcName] = ()=> objData;\\n      }\\n      // Get node template\\n      const templateSource = nodeData.fileContent;\\n      const templateLen = templateSource.length;\\n      // Get the output to be generated\\n      const outputName = property;\\n      // Create the template generator\\n      const tg = new TemplateGenerator( templateSource );\\n      const beginTag = `[# Begin ${outputName} #]`;\\n      const endTag = `[# End ${outputName} #]`;\\n      // Get output template\\n      const block = tg.extractNextLineBlock( beginTag, endTag );\\n      //const blockSrc = block.getTemplate();\\n      // Set template language\\n      const [format, language] = nodeData.fileType.split( '/' );\\n      block.setLanguage( language );\\n      // Execute code generation\\n      block.process( m );\\n      // Get output\\n      value = block.getOutput();\\n      //debug();\\n      break;\\n    case 'CodeFlow_Operator':\\n      let inOutValue = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          inOutValue[refInfo.name] = inValue.join( '\\\\n' );\\n        }\\n      }\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          inOutValue[row.name] = pValue;\\n        }\\n      }\\n      if( nodeData.fileContent ) {\\n        const getPort = (name)=>{ return( inOutValue[name] ); };\\n        const setPort = (name, value)=>{ inOutValue[name] = value; };\\n        eval( nodeData.fileContent );\\n        if( nodeData.out ) {\\n          for( const output of nodeData.out ) {\\n            let oValue = inOutValue[output.portId];\\n            if( oValue ) {\\n              oValue = oValue.split( '\\\\n' );\\n            }\\n            if( property == output.portId ) {\\n              value = oValue;\\n            }\\n          }\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Merge':\\n      value = [];\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          value = value.concat( inValue );\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Param':\\n    case 'Property_GraphInfo':\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          if( row.name == property ) {\\n            value = pValue;\\n          }\\n        }\\n      }\\n      break;\\n  }\\n  return( value );\\n}\\nfunction getValueOfNode( name, property ) {\\n  let value = [''];\\n  let nodeData = null;\\n  \\n  if( isNumber( name ) ) {\\n    // If name is a node key ==> get the node by key\\n    nodeData = me.getNodeByFieldName( 'main', 'key', [name] );\\n  } else {\\n    // Find component with label = name\\n    const nodeDataList = me.getNodeListByFieldNameList( 'main', 'label', [name], filterOutDisabledNodes );\\n    if( nodeDataList && nodeDataList.length == 1 ) {\\n      // A unique node is found with this name\\n      nodeData = nodeDataList[0];\\n    } else {\\n      if( !nodeDataList || nodeDataList.length == 0 ) {\\n        // Reference name is not found in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is not a node in the graph`];\\n      } else {\\n        // Reference name is used multiple time in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is a label for multiple nodes in the graph`];\\n      }\\n    }\\n  }\\n  // If we found a node\\n  if( nodeData ) {\\n    value = generateNode( nodeData, property );\\n  }\\n  return( value );\\n}\\nfunction getValueOfRef( refValue, linkData ) {\\n  let value = [];\\n  \\n  const refInfo = parseInputPortName( refValue );\\n  if( refInfo.reference == '' && refInfo.name == '' ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    value = refInfo.value;\\n  } else if( refInfo.reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = refInfo.reference;\\n    value = getCacheValue( id );\\n  } else {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, filterOutDisabledNodes );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateStartNode( nodeData ) {\\n  generateNode( nodeData );\\n}\\n\\n/************************\\n * Setup functions\\n ************************/\\n// Detect all active features\\nvar activeFeature = new Set();\\nconst featureList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Feature'] );\\nfor( const feature of featureList ) {\\n  if( feature.buttons[0].checked ) {\\n    const groupData = me.getNodeByFieldName( 'main', 'text', feature.label );\\n    if( groupData ) {\\n      activeFeature.add( groupData.key );\\n    }\\n  }\\n}\\n// Load all libraries for code generation\\nconst libraryNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Library'], filterOutDisabledNodes );\\nlet libraryNameList = new Set( ['javascript' ] );\\nfor( const libraryNode of libraryNodeList ) {\\n  // Add the library to the available libraries\\n  libraryNameList.add( libraryNode.label );\\n  // If library has JavaScript code, we load it\\n  if( libraryNode.fileContent ) {\\n    eval( libraryNode.fileContent );\\n  }\\n}\\n/************************\\n * Property caching functions\\n ************************/\\n// Cache all name/value pairs from CodeFlow_Param nodes\\nconst paramNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Param', 'Property_GraphInfo'], filterOutDisabledNodes );\\nfor( const paramNode of paramNodeList ) {\\n  if( nodeData.rows ) {\\n    for( const row of paramNode.rows ) {\\n      const value = getValueOfRef( row.value );\\n    }\\n  }\\n}\\ndebug();\\n/************************\\n * Start generation\\n ************************/\\n// Detect starting nodes for code generation\\nconst startNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['Hierarchy_CodeInGraph'], filterOutDisabledNodes );\\nfor( const startNode of startNodeList ) {\\n  generateStartNode( startNode );\\n}\\nconsole.log( dataCache );\\n\\n\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":87, \"location\":\"720 830\", \"color\":\"YellowGreen\", \"editorPosition\":[ 1765,24,826,1985 ]},\n{\"label\":\"Smart Editor\", \"isGroup\":true, \"color\":\"green\", \"key\":96, \"colorSwap\":\"gray\", \"category\":\"Group_BasicGroup\"},\n{\"label\":\"Pressing this button will generate the application based on the selected features\", \"category\":\"CodeFlow_Button\", \"size\":\"440 80\", \"buttons\":[ {\"name\":\"Generate 1.3\", \"checked\":true} ], \"isFile\":true, \"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Get main graph editor\\nconst g = m.e.getEditor( config.htmlDiv.graphDiv );\\n// Get current graph model\\nconst model = g.getJSONModel();\\nconst modelId = 'main';\\n\\n// Instantiate Model Explorer\\nconst me = new ModelExplorer();\\nme.setJSONModel( modelId, model );\\n\\n// Cache of all data generated or stored in the model\\nconst dataCache = {\\n  //'Header.body': ['Line1', 'Line2', ...],\\n  //'Style.url': ['http://styleServer.come/style.css'],\\n  // Missing entry => generate and add to cache\\n  // Then return the entry content\\n};\\n\\n/************************\\n * Utility functions\\n ************************/\\n// Filter nodes in disabled features as condition for \\\"me\\\" functions\\nfunction filterOutDisabledNodes (d) {\\n  return( !d.group || activeFeature.has( d.group ) ); \\n}\\nfunction isNumber( v ) {\\n  return( parseInt(v).toString() === v.toString() );\\n}\\nfunction getArrayOf( v ) {\\n   if( v instanceof String ) {\\n    return( v.split( '\\\\n' ) );\\n  } else if( Array.isArray( v ) ) {\\n    return( v );\\n  } else {\\n    return( [v] );\\n  }\\n}\\nfunction getId( nodeData, property ) {\\n  return( ( nodeData.label? nodeData.label: nodeData.key ) + ( property? '.'+ property: '' ) );\\n}\\nfunction parseInputPortName( portName ) {\\n  let value = '';\\n  let [name, reference] = portName.split( '@' );\\n  if( name.endsWith( '\\\\\\\\' ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    name = name.substing( name.length-1 );\\n    value = getArrayOf( name+'@'+reference );\\n    reference = '';\\n    name = '';\\n  }\\n  if( reference == undefined ) {\\n    reference = '';\\n  }\\n  return({ name, reference, value });\\n}\\n/************************\\n * DataCache functions\\n ************************/\\nfunction getCacheValue( id ) {\\n  let value = [''];\\n  const dValue = dataCache[id];\\n  if( dValue ) {\\n    // Case of ref being defined in the dataCache\\n    value = dValue;\\n  } else {\\n    // Case of ref being not defined in the dataCache\\n    // Split the reference into Name.property\\n    const [name, property] = id.split( '.' );\\n    if( name && property ) {\\n      if( libraryNameList.has( name ) ) {\\n        // Case of a javascript function \\n        eval( `value = getArrayOf( ${property} )` );\\n      } else {\\n        // Case of recursion\\n        value = getValueOfNode( name, property );\\n        setCacheValue( id, value );\\n      }\\n    } else if( name ) {\\n      value = getValueOfNode( name );\\n    } else {\\n      value = [`Error: could not resolve \\\"${id}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction setCacheValue( id, value ) {\\n  if( !dataCache.hasOwnProperty( id ) ) {\\n    dataCache[id] = value;\\n  }\\n}\\n/************************\\n * Generation functions\\n ************************/\\nfunction getFanInNodeValueList( nodeData, portName ) {\\n  let valueList = [];\\n  // Get node from fan in\\n  const linkList = me.getLinkListFanInByNodeKey( 'main', nodeData.key, portName );\\n  if( !linkList || linkList.length == 0 ) {\\n    const value = getValueOfRef( portName, {} ); // Provide {} as empty link\\n    // this is necessary to get an empty value in case the input is not connected\\n    // or connected to a disable node\\n    valueList.push( value );\\n  } else {\\n    for( const linkData of linkList ) {\\n      const refValue = linkData.toPort;\\n      //const fromPort = linkData.fromPort;\\n      const value = getValueOfRef( refValue, linkData );\\n      if( value && value.length > 0 ) {\\n        valueList.push( value );\\n      }\\n    }\\n  }\\n  return( valueList );\\n}\\nfunction getGenerationValueFrom( nodeData, portName ) {\\n  let value = [];\\n  \\n  const valueList = getFanInNodeValueList( nodeData, portName );\\n  if( valueList && valueList.length == 1 ) {\\n    value = valueList[0];\\n  } else {\\n    if( !valueList || valueList.length == 0 ) {\\n      // Reference name is not found in the graph\\n      value = [];\\n    } else {\\n      // Reference name is used multiple time in the graph\\n      value = [`Error: Multiple source enalbled for \\\"${nodeData.label}.${portName}\\\"`];\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateNode( nodeData, property ) {\\n  let value = [''];\\n  let id = '';\\n  \\n  switch( nodeData.category ) {\\n    case 'Hierarchy_CodeInGraph':\\n      value = getGenerationValueFrom( nodeData, '' );\\n      g.setNodeDataField( nodeData.key, 'fileContent', value.join( '\\\\n' ) );\\n      id = getId( nodeData );\\n      setCacheValue( id, value );\\n      break;\\n    case 'CodeFlow_Code':\\n      // Data model for node code generation\\n      let m = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          let funcName = 'Begin_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n          funcName = 'Define_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n          funcName = 'Insert_'+refInfo.name.replaceAll( ' ', '_' );\\n          m[funcName] = ()=> inValue;\\n        }\\n      }\\n      if( nodeData.rows ) {\\n        let objData = {};\\n        for( const row of nodeData.rows ) {\\n          let pValue = getValueOfRef( row.value );\\n          if( Array.isArray( pValue ) && ( pValue.length > 0 ) ) {\\n            pValue = pValue[0];\\n          } else {\\n            pValue = '';\\n          }\\n          objData[row.name] = pValue;\\n        }\\n        funcName = 'Begin_Property';\\n        m[funcName] = ()=> objData;\\n        funcName = 'Define_Property';\\n        m[funcName] = ()=> objData;\\n      }\\n      // Get node template\\n      const templateSource = nodeData.fileContent;\\n      const templateLen = templateSource.length;\\n      // Get the output to be generated\\n      const outputName = property;\\n      // Create the template generator\\n      const tg = new TemplateGenerator( templateSource );\\n      const beginTag = `[# Begin ${outputName} #]`;\\n      const endTag = `[# End ${outputName} #]`;\\n      // Get output template\\n      const block = tg.extractNextLineBlock( beginTag, endTag );\\n      //const blockSrc = block.getTemplate();\\n      // Set template language\\n      const [format, language] = nodeData.fileType.split( '/' );\\n      block.setLanguage( language );\\n      // Execute code generation\\n      block.process( m );\\n      // Get output\\n      value = block.getOutput();\\n      //debug();\\n      break;\\n    case 'CodeFlow_Operator':\\n      let inOutValue = {};\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          const refInfo = parseInputPortName( input.portId );\\n          inOutValue[refInfo.name] = inValue.join( '\\\\n' );\\n        }\\n      }\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          inOutValue[row.name] = pValue;\\n        }\\n      }\\n      if( nodeData.fileContent ) {\\n        const getPort = (name)=>{ return( inOutValue[name] ); };\\n        const setPort = (name, value)=>{ inOutValue[name] = value; };\\n        eval( nodeData.fileContent );\\n        if( nodeData.out ) {\\n          for( const output of nodeData.out ) {\\n            let oValue = inOutValue[output.portId];\\n            if( oValue ) {\\n              oValue = oValue.split( '\\\\n' );\\n            }\\n            if( property == output.portId ) {\\n              value = oValue;\\n            }\\n          }\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Merge':\\n      value = [];\\n      if( nodeData.in ) {\\n        for( const input of nodeData.in ) {\\n          const inValue = getGenerationValueFrom( nodeData, input.portId );\\n          value = value.concat( inValue );\\n        }\\n      }\\n      break;\\n    case 'CodeFlow_Param':\\n    case 'Property_GraphInfo':\\n      if( nodeData.rows ) {\\n        for( const row of nodeData.rows ) {\\n          const pValue = getValueOfRef( row.value );\\n          if( row.name == property ) {\\n            value = pValue;\\n          }\\n        }\\n      }\\n      break;\\n  }\\n  return( value );\\n}\\nfunction getValueOfNode( name, property ) {\\n  let value = [''];\\n  let nodeData = null;\\n  \\n  if( isNumber( name ) ) {\\n    // If name is a node key ==> get the node by key\\n    nodeData = me.getNodeByFieldName( 'main', 'key', [name], filterOutDisabledNodes );\\n  } else {\\n    // Find component with label = name\\n    const nodeDataList = me.getNodeListByFieldNameList( 'main', 'label', [name], filterOutDisabledNodes );\\n    if( nodeDataList && nodeDataList.length == 1 ) {\\n      // A unique node is found with this name\\n      nodeData = nodeDataList[0];\\n    } else {\\n      if( !nodeDataList || nodeDataList.length == 0 ) {\\n        // Reference name is not found in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is not a node in the graph`];\\n      } else {\\n        // Reference name is used multiple time in the graph\\n        value = [`Error: Reference name \\\"${name}\\\" is a label for multiple nodes in the graph`];\\n      }\\n    }\\n  }\\n  // If we found a node\\n  if( nodeData ) {\\n    value = generateNode( nodeData, property );\\n  }\\n  return( value );\\n}\\nfunction getValueOfRef( refValue, linkData ) {\\n  let value = [];\\n  \\n  const refInfo = parseInputPortName( refValue );\\n  if( ( refInfo.reference == '' ) && \\n      ( refInfo.name == '' ) && \\n      ( refInfo.value ) ) {\\n    // Case of refValue containing a \\\\@ to avoid interpretation as reference\\n    // Example: emailServer: \\\\@gmail.com\\n    // Example: email: antonello\\\\@gmail.com\\n    // Remove the '\\\\'\\n    value = refInfo.value;\\n  } else if( refInfo.reference ) {\\n    // Case of refValue being a reference\\n    // Remove the '@'\\n    const id = refInfo.reference;\\n    value = getCacheValue( id );\\n  } else {\\n    // Case of refValue being a value like string, array or number\\n    if( linkData ) {\\n      // Get all nodes connected to the nodeData\\n      const fromKey = linkData.from;\\n      const fromPort = linkData.fromPort;\\n      const nodeData = me.getNodeByFieldName( 'main', 'key', fromKey, filterOutDisabledNodes );\\n      if( nodeData ) {\\n        const id = getId( nodeData, fromPort );\\n        value = getCacheValue( id );\\n        //value = getGenerationValueFrom( nodeData, fromPort );\\n      } else {\\n        // We do nothing, because the node is not in an enabled feature\\n      }\\n    } else {\\n      value = getArrayOf( refValue );\\n    }\\n  }\\n  return( value );\\n}\\nfunction generateStartNode( nodeData ) {\\n  generateNode( nodeData );\\n}\\n\\n/************************\\n * Setup functions\\n ************************/\\n// Detect all active features\\nvar activeFeature = new Set();\\nconst featureList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Feature'] );\\nfor( const feature of featureList ) {\\n  if( feature.buttons[0].checked ) {\\n    const groupData = me.getNodeByFieldName( 'main', 'text', feature.label );\\n    if( groupData ) {\\n      activeFeature.add( groupData.key );\\n    }\\n  }\\n}\\n// Load all libraries for code generation\\nconst libraryNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Library'], filterOutDisabledNodes );\\nlet libraryNameList = new Set( ['javascript' ] );\\nfor( const libraryNode of libraryNodeList ) {\\n  // Add the library to the available libraries\\n  libraryNameList.add( libraryNode.label );\\n  // If library has JavaScript code, we load it\\n  if( libraryNode.fileContent ) {\\n    eval( libraryNode.fileContent );\\n  }\\n}\\n/************************\\n * Property caching functions\\n ************************/\\n// Cache all name/value pairs from CodeFlow_Param nodes\\nconst paramNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['CodeFlow_Param', 'Property_GraphInfo'], filterOutDisabledNodes );\\nfor( const paramNode of paramNodeList ) {\\n  if( nodeData.rows ) {\\n    for( const row of paramNode.rows ) {\\n      const value = getValueOfRef( row.value );\\n    }\\n  }\\n}\\ndebug();\\n/************************\\n * Start generation\\n ************************/\\n// Detect starting nodes for code generation\\nconst startNodeList = me.getNodeListByFieldNameList( 'main', 'category', ['Hierarchy_CodeInGraph'], filterOutDisabledNodes );\\nfor( const startNode of startNodeList ) {\\n  generateStartNode( startNode );\\n}\\nconsole.log( dataCache );\\n\\n\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":100, \"location\":\"720 920\", \"color\":\"YellowGreen\", \"editorPosition\":[ 1767,-1,903,1583 ]},\n{\"label\":\"debug\", \"color\":\"orange\", \"size\":\"180 35\", \"category\":\"Hierarchy_CodeInGraph\", \"isFile\":true, \"fileContent\":\"<div id=\\\"SBEditor\\\"></div>\", \"fileTypeName\":\"Javascript\", \"fileType\":\"text/javascript\", \"key\":101, \"location\":\"-150 250\", \"group\":40},\n{\"label\":\"alertBlock style\", \"category\":\"CodeFlow_Code\", \"size\":\"290 60\", \"rows\":[], \"in\":[], \"out\":[ {\"portId\":\"out\"} ], \"isFile\":true, \"fileTypeName\":\"HTML\", \"fileType\":\"text/html\", \"key\":98, \"location\":\"-2490 619.9\", \"fileContent\":\"<!DOCTYPE html>\\r\\n<html>\\r\\n  <body>\\r\\n    <!--[# Begin out #]-->\\r\\n    <style>\\r\\n      .acms-alert{\\r\\n        margin-bottom:20px;\\r\\n        padding:20px;\\r\\n        color:#404040;\\r\\n        font-weight:700;\\r\\n        background:#fff;\\r\\n        border:1px solid #9898a2;\\r\\n        border-radius:0;box-shadow:0 2px 5px 2px rgba(0,0,0,.1);\\r\\n      }\\r\\n    </style>\\r\\n    <!--[# End out #]-->\\r\\n  </body>\\r\\n</html>\\r\\n\", \"group\":44, \"color\":\"lightsalmon\"},\n{\"label\":\"Code in Graph\", \"color\":\"lightsalmon\", \"size\":\"180 35\", \"category\":\"Hierarchy_CodeInGraph\", \"isFile\":true, \"fileContent\":\"<!--\\r\\n=============================================================================\\nLicensed Materials - Property of Frank Joublin and Antonio Ceravola.\\n(C) Copyright Lorinware Prod 2022, All Rights Reserved.\\nFrance Government Users Restricted Rights - Use, duplication or disclosure\\nrestricted by GSA ADP Schedule Contract with Lorinware Prod.\\n=============================================================================\\nModule: SmartBlock Demo\\nDate: Mon Sep 05 2022 14:20:45 GMT+0200 (Central European Summer Time)\\n=============================================================================\\n-->\\r\\n\\r\\n<!DOCTYPE html>\\r\\n<html>\\r\\n  <head>\\r\\n    <title>\\r\\n      SMARTBLOCK DEMO\\r\\n    </title>\\r\\n    <meta charset=utf-8 />\\r\\n    <link rel=\\\"stylesheet\\\" href=\\\"https://unpkg.com/smartblock@1.3.2/css/smartblock.css\\\" />\\n  </head>\\r\\n  <body>\\r\\n    <script src=\\\"https://unpkg.com/smartblock@1.3.2/dist/editor.js\\\"></script>\\n    <div id=\\\"SBEditor\\\"></div>\\n    <script>\\r\\n      SmartBlock.Editor(\\r\\n      \\t'#SBEditor', \\r\\n      \\t{\\r\\n          html: '<p>Default text if no initial text is specified</p>',\\r\\n      \\r\\n      \\t\\tonChange: function(result) {\\r\\n      \\t\\t\\tconsole.log(result.json, result.html);\\r\\n      \\t\\t}\\r\\n      \\t}\\r\\n      );\\r\\n    </script>\\r\\n  </body>\\r\\n</html>\\r\", \"fileTypeName\":\"WebPage\", \"fileType\":\"application/html\", \"key\":105, \"location\":\"580 319.9\"},\n{\"label\":\"Multiplexer\", \"category\":\"TextLabels_Size2\", \"size\":\"150 30\", \"key\":104, \"location\":\"1160 330\"},\n{\"label\":\"Demultiplexer\", \"category\":\"TextLabels_Size2\", \"size\":\"150 30\", \"key\":108, \"location\":\"1500 330\"},\n{\"label\":\"Bus\", \"size\":\"40 40\", \"category\":\"CodeFlow_Bus\", \"color\":\"lightseagreen\", \"isFile\":true, \"fileTypeName\":\"Text\", \"fileType\":\"text/text\", \"fileURL\":\"/fileServer/00/79.txt\", \"key\":107, \"location\":\"1370 400\"},\n{\"label\":\"\", \"category\":\"CodeFlow_Multiplexer\", \"color\":\"lightseagreen\", \"rows\":[], \"in\":[ {\"portId\":\"in0\"},{\"portId\":\"in1\"},{\"portId\":\"in\"},{\"portId\":\"in\"} ], \"out\":[ {\"portId\":\"out\"} ], \"key\":103, \"location\":\"1230 400\"},\n{\"label\":\"\", \"category\":\"CodeFlow_Demultiplexer\", \"color\":\"lightseagreen\", \"rows\":[], \"in\":[ {\"portId\":\"in\"} ], \"out\":[ {\"portId\":\"out1\"},{\"portId\":\"out2\"},{\"portId\":\"out\"},{\"portId\":\"out\"} ], \"key\":109, \"location\":\"1530 400\"}\n ],\n  \"linkDataArray\": [ \n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"smartBlock\", \"from\":17, \"to\":89, \"points\":[-699.5380859375,259,-689.5380859375,259,-401.3583984375,240,-391.3583984375,240], \"key\":-8, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"smartBlockCustomBlock\", \"from\":29, \"to\":93, \"points\":[-1687.5380859375,399,-1677.5380859375,399,-442.703125,354.277152501692,-432.703125,354.277152501692], \"key\":-10, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"smartBlockExtensions\", \"from\":27, \"to\":93, \"points\":[-1687.5380859375,319,-1677.5380859375,319,-442.703125,334.277152501692,-432.703125,334.277152501692], \"key\":-11, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"smartBlockEditor \", \"from\":25, \"to\":93, \"points\":[-699.5380859375,339,-689.5380859375,339,-442.703125,314.277152501692,-432.703125,314.277152501692], \"key\":-12, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"extensions\", \"from\":42, \"to\":35, \"points\":[-1689.5380859375,478.0999999999998,-1679.5380859375,478.0999999999998,-1507.9306640625,650,-1497.9306640625,650], \"key\":-27, \"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"initHTML\", \"from\":37, \"to\":35, \"points\":[-1664.5380859375,704.5999999999999,-1654.5380859375,704.5999999999999,-1507.9306640625,670,-1497.9306640625,670], \"key\":-26, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"editorExtensions\", \"from\":33, \"to\":63, \"points\":[-2159.5380859375,539.8,-2149.5380859375,539.8,-998.833984375,589,-988.833984375,589], \"key\":-29, \"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"scriptAfterBody\", \"from\":63, \"to\":6, \"points\":[-811.5380859375,599,-801.5380859375,599,-97.30078125,419.79999999999995,-87.30078125,419.79999999999995], \"key\":-30, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":51, \"to\":61, \"points\":[-290,1319.8000000000002,-100,1319.8], \"key\":-40, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":64, \"to\":61, \"points\":[-10,1420,-10,1339.8], \"key\":-42, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":69, \"to\":64, \"points\":[-10,1510,-10,1460], \"key\":-43, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":61, \"to\":75, \"points\":[80,1319.92,140,1320,150,1320], \"key\":-45, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":64, \"to\":78, \"points\":[80,1428,140,1420,150,1420], \"key\":-46, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":64, \"to\":80, \"points\":[80,1458,140,1470,150,1470], \"key\":-47, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":69, \"to\":82, \"points\":[80,1530,140,1530,150,1530], \"key\":-48, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":82, \"to\":84, \"points\":[350,1530,360,1530,370,1530,380,1530], \"key\":-49, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":56, \"to\":69, \"points\":[-290,1530,-100,1530], \"key\":-50, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":61, \"to\":47, \"points\":[50.24096385542174,1299.8,140,1270,150,1270], \"key\":-25, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"titleUpperCase\", \"from\":83, \"to\":70, \"points\":[-904.5380859375,15,-894.5380859375,15,-201.94921875,-20.1,-191.94921875,-20.1], \"key\":-34, \"color\":\"orange\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":79, \"to\":91, \"points\":[90,1109.892857142857,140,1110,150,1110], \"key\":-37, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":79, \"to\":92, \"points\":[55.666003976142946,1129.6999999999998,140,1160,150,1160], \"key\":-38, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":94, \"to\":97, \"points\":[701,-180,770,-180], \"key\":-39},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":81, \"to\":58, \"points\":[1116.2081810414688,-189.64202468747305,1190.0045849159778,-199.70517067036062], \"key\":-44},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":81, \"to\":65, \"points\":[1116.2081810414688,-170.35797531252695,1190.0045849159778,-160.29482932963938], \"key\":-51},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":65, \"to\":50, \"points\":[1340.997051088304,-158.23604193690588,1410,-165.76363636363635], \"key\":-52},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":58, \"to\":50, \"points\":[1340.997051088304,-201.7639580630941,1410,-194.23636363636365], \"key\":-53},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":86, \"to\":67, \"points\":[2015.5,-200.5,2015.5,-229.5], \"key\":-54},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":67, \"to\":66, \"points\":[2014.0358050464347,-270.4987293499154,2011.9642857142858,-299.5], \"key\":-55},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":88, \"to\":74, \"points\":[1801.0810387552667,-159.6175877681713,1819.9189612447333,-90.48241223182869], \"key\":-56},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":88, \"to\":76, \"points\":[1796.7051227629715,-159.6008618018534,1804.2948772370285,-30.49913819814659], \"key\":-57},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":74, \"to\":68, \"points\":[1910.9985820602433,-64.30199380677409,1970,-59.84905660377358], \"key\":-58},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":76, \"to\":68, \"points\":[1890.995146988576,-20.59581010365978,1970,-31.684210526315788], \"key\":-59},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":97, \"to\":81, \"points\":[921,-180,970,-180], \"key\":-60},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":50, \"to\":88, \"points\":[1671,-180.04924528301888,1730.0141483095103,-180.07151477294698], \"key\":-61},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"\", \"toPort\":\"\", \"from\":88, \"to\":86, \"points\":[1880.9821470511422,-180.06405612045182,1940.0178529488578,-180.03594387954817], \"key\":-62},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"\", \"from\":70, \"to\":77, \"points\":[10.4619140625,-10.100000000000001,20.4619140625,-10.100000000000001,637.5804123770644,369.7379149116458], \"key\":-63, \"color\":\"white\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"\", \"from\":6, \"to\":77, \"points\":[310.4619140625,379.79999999999995,320.4619140625,379.79999999999995,580.0002121452354,387.362864576161], \"key\":-64, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"input\", \"from\":54, \"to\":83, \"points\":[-1344.5380859375,-55.19999999999999,-1334.5380859375,-55.19999999999999,-1186.3583984375,15,-1176.3583984375,15], \"key\":-65, \"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"\", \"from\":18, \"to\":90, \"points\":[-1344.5380859375,14.799999999999997,-1334.5380859375,14.799999999999997,-809.9928956410536,-74.5803769229567], \"key\":-66, \"color\":\"yellow\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"style\", \"from\":89, \"to\":6, \"points\":[-219.5380859375,250,-209.5380859375,250,-97.30078125,359.79999999999995,-87.30078125,359.79999999999995], \"key\":-67, \"color\":\"white\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"scriptBeforeBody\", \"from\":93, \"to\":6, \"points\":[-209.5380859375,334.277152501692,-199.5380859375,334.277152501692,-97.3076171875,379.79999999999995,-87.3076171875,379.79999999999995], \"key\":-68, \"color\":\"white\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"body\", \"from\":95, \"to\":6, \"points\":[-209.5380859375,400,-199.5380859375,400,-97.30078125,399.79999999999995,-87.30078125,399.79999999999995], \"key\":-69, \"color\":\"white\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"\", \"from\":95, \"to\":101, \"points\":[-209.5380859375,400,-199.5380859375,400,-78.51295350883545,270.36548134196977], \"key\":-71, \"color\":\"white\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"smartBlockStyle\", \"from\":98, \"to\":89, \"points\":[-2159.5380859375,619.9,-2149.5380859375,619.9,-401.3583984375,260,-391.3583984375,260], \"key\":-73, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Feature\", \"fromPort\":\"Feature\", \"toPort\":\"Feature\", \"from\":51, \"to\":78, \"points\":[-290,1337.142307692308,140,1420,150,1420], \"key\":-74, \"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"body\", \"from\":12, \"to\":95, \"points\":[-701.5380859375005,488.69999999999993,-691.5380859375005,488.69999999999993,-321.3583984375,400,-311.3583984375,400], \"key\":-70, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"editorDeclaration\", \"from\":35, \"to\":63, \"points\":[-1079.5380859375,660,-1069.5380859375,660,-998.833984375,609,-988.833984375,609], \"key\":-75, \"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"\", \"from\":6, \"to\":105, \"points\":[310.4619140625,379.79999999999995,320.4619140625,379.79999999999995,580.0071639160373,335.3855174313723], \"key\":-76, \"color\":\"lightsalmon\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"out\", \"toPort\":\"Bus\", \"from\":103, \"to\":107, \"points\":[1290.4619140625,400,1300.4619140625,400,1370,400], \"key\":-72, \"color\":\"lightseagreen\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"Bus\", \"toPort\":\"in\", \"from\":107, \"to\":109, \"points\":[1411,400,1488.103515625,400,1498.103515625,400], \"key\":-77, \"color\":\"lightseagreen\"},\n{\"category\":\"CodeFlow_Code\", \"fromPort\":\"\", \"toPort\":\"in0\", \"from\":105, \"to\":103, \"points\":[760.9976030746708,328.79324308447224,1180.3173828125,370,1190.3173828125,370], \"key\":-78}\n ]}"
}