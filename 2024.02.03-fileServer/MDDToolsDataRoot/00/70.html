<!DOCTYPE html>
<html>
  <script type="text/javascript" src="lib/gojs/2.1/go.js"></script>
  <style type="text/css">
    /* CSS for the traditional context menu */
    .menu {
      display: none;
      position: absolute;
      opacity: 0;
      margin: 0;
      padding: 8px 0;
      z-index: 999;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);
      list-style: none;
      background-color: #ffffff;
      border-radius: 4px;
    }

    .menu-item {
      display: block;
      position: relative;
      min-width: 60px;
      margin: 0;
      padding: 6px 16px;
      font: bold 12px sans-serif;
      color: rgba(0, 0, 0, .87);
      cursor: pointer;
    }

    .menu-item::before {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
      content: "";
      width: 100%;
      height: 100%;
      background-color: #000000;
    }

    .menu-item:hover::before {
      opacity: .04;
    }

    .menu .menu {
      top: -8px;
      left: 100%;
    }

    .show-menu, .menu-item:hover > .menu {
      display: block;
      opacity: 1;
    }
  </style>
  <script>
    var $ = go.GraphObject.make;  // for conciseness in defining templates
    let myDiagram = null;
  
    console.log('00000000000000000000000000000000000000000000000000000000000000000000000');
    //window.parent.debug();
    
    class ContextMenu {
      constructor( diagram ) {
        this.menuList = {};
        this.diagram = diagram;
        
        this.hideCX = ()=> {
          if ( this.diagram.currentTool instanceof go.ContextMenuTool) {
            this.diagram.currentTool.doCancel();
          }
        }
      }
      add( name, data, parentId ) {
        // Start creation from root
        const parent = document.getElementById( parentId );
        // Collect menu info
        const menuData = {
          parent,
          name,
          data,
          contextMenu: null,
        };
        
        // Create context menu
        const menuElement = this._createDOMMenu( menuData );
        menuData.menuElement = menuElement;
        
        // Store the new menu
        this.menuList[name] = menuData;
        
        // We don't want the div acting as a context menu to have a (browser) context menu!
        menuElement.addEventListener( "contextmenu", function(e) {
          e.preventDefault();
          return false;
        }, false);
      }
      get( name ) {
        return( this.menuList[name] );
      }
      getShowCallback( name ) {
        const menuData = this.get( name );
        // This is the actual HTML context menu:
        const cxElement = menuData.menuElement;
        
        const showCM = ( obj, diagram, tool )=> {
          const hasMenuItem = this._show( name, obj );
          
          // Now show the whole context menu element
          if( hasMenuItem ) {
            cxElement.classList.add( "show-menu" );
            // we don't bother overriding positionContextMenu, we just do it here:
            const mousePt = diagram.lastInput.viewPoint;
            cxElement.style.left = mousePt.x + 5 + "px";
            cxElement.style.top = mousePt.y + "px";
          }
    
          // Optional: Use a `window` click listener with event capture to
          //           remove the context menu if the user clicks elsewhere on the page
          window.addEventListener( "click", this.hideCX, true );
        };
        return( showCM );
      }
      getHideCallback( name ) {
        const menuData = this.get( name );
        // This is the actual HTML context menu:
        const cxElement = menuData.menuElement;
        
        const hideCM = ()=> {
          cxElement.classList.remove( "show-menu" );
          // Optional: Use a `window` click listener with event capture to
          //           remove the context menu if the user clicks elsewhere on the page
          window.removeEventListener( "click", this.hideCX, true );
        };
        return( hideCM );
      }
      _show( name, obj ) {
        const menuData = this.get( name );
        let hasMenuItem = false;
        
        const d = {
          diagram: this.diagram,
          tool: this.diagram.currentTool,
          cmd: this.diagram.commandHandler,
          cmt: this.diagram.toolManager.contextMenuTool,
        }
        
        const showMenu = ( menuData )=> {
          for( const item of menuData.data ) {
            const o = {
              item,
              obj,
              d,
            };
            if( item.if( o ) ) {
              item.element.style.display = "block";
              hasMenuItem = true;
              if( item.sub ) {
                const subMenuData = {
                  data: item.sub,
                };
                showMenu( subMenuData );
              }
            } else {
              item.element.style.display = "none";
            }
          }
        }
        showMenu( menuData );
        return( hasMenuItem );
      }
      _createDOMMenu( menuData ) {
        const d = {
          diagram: this.diagram,
          tool: this.diagram.currentTool,
          cmd: this.diagram.commandHandler,
          cmt: this.diagram.toolManager.contextMenuTool,
        }
        const createMenu = ( menuData )=> {
          // Create ul element 
          const ul = document.createElement( 'ul' );
          ul.id = menuData.name;
          ul.className = 'menu';
          menuData.parent.appendChild( ul );
          
          // Create li elements
          for( const item of menuData.data ) {
            // We create the element first
            const li = document.createElement( 'li' );
            li.id = item.label;
            li.className = 'menu-item';
            li.innerHTML = item.label;
            item.element = li;
            
            let clickParam = {
              item,
              d,
            };
            li.onclick = ( event )=> { clickParam.event = event; if( item.do ) item.do( clickParam ) };
            ul.appendChild( li );
            
            if( item.sub ) {
              const subMenuData = {
                parent: li,
                name: '',
                data: item.sub,
                d,
              };
              createMenu( subMenuData );
            }
          }
          return( ul );
        }
        
        const ul = createMenu( menuData );
        return( ul );
      }
    }
  
    // if: ( o )=> {} where o has properties
    //  o.item    = selected menu data item
    //  o.obj     = selected node in graph
    //  o.d.diagram = diagram
    //  o.d.tool    = diagram.currentTool,
    //  o.d.cmd     = diagram.commandHandler;
    //  o.d.cmt     = diagram.toolManager.contextMenuTool
    // do: ( o )=> {} where e has properties
    //  o.item    = selected menu data item
    //  o.event   = DOM event
    //  o.d.diagram = diagram
    //  o.d.tool    = diagram.currentTool,
    //  o.d.cmd     = diagram.commandHandler;
    //  o.d.cmt     = diagram.toolManager.contextMenuTool
    const diagramMenu = [
      { label: 'cut',         if: ( o )=> o.d.cmd.canCutSelection(),
                              do: ( o )=> o.d.cmd.cutSelection() },
      { label: 'copy',        if: ( o )=> o.d.cmd.canCopySelection(),
                              do: ( o )=> o.d.cmd.copySelection() },
      { label: 'paste',       if: ( o )=> o.d.cmd.canPasteSelection( o.d.cmt.mouseDownPoint ),
                              do: ( o )=> o.d.cmd.pasteSelection( o.d.cmt.mouseDownPoint ) },
      { label: 'delete',      if: ( o )=> o.d.cmd.canDeleteSelection(),
                              do: ( o )=> o.d.cmd.deleteSelection() },
      { label: 'color',       if: ( o )=> o.obj !== null, 
                              sub:[
          { label: 'red',     if: ( o )=> { o.item.element.style['backgroundColor'] = '#f38181';
                                            return( true ); },
                              do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                            changeColor( o.d.diagram, color ); } },
          { label: 'green',   if: ( o )=> { o.item.element.style['backgroundColor'] = '#eaffd0';
                                            return( true ); },
                              do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                            changeColor( o.d.diagram, color ); } },
          { label: 'blue',    if: ( o )=> { o.item.element.style['backgroundColor'] = '#95e1d3';
                                            return( true ); },
                              do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                            changeColor( o.d.diagram, color ); } },
          { label: 'yellow',  if: ( o )=> { o.item.element.style['backgroundColor'] = '#fce38a';
                                            return( true ); },
                              do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                            changeColor( o.d.diagram, color ); } },
        ]},
    ];
     
    function init() {
      myDiagram =
      $(go.Diagram, "myDiagramDiv",  // create a Diagram for the DIV HTML element
        {
          "undoManager.isEnabled": true
        });
      
      // Create context menu
      const cm = new ContextMenu( myDiagram );
      cm.add( 'diagramMenu', diagramMenu, 'contextMenuContainer' );
      
      // an HTMLInfo object is needed to invoke the code to set up the HTML cxElement
      const contextMenu = $(go.HTMLInfo, {
        show: cm.getShowCallback( 'diagramMenu' ),
        hide: cm.getHideCallback( 'diagramMenu' ),
      });
      myDiagram.contextMenu = contextMenu;
        
      // define a simple Node template (but use the default Link template)
      myDiagram.nodeTemplate =
        $(go.Node, "Auto",
          { contextMenu: contextMenu },
          $(go.Shape, "RoundedRectangle",
            // Shape.fill is bound to Node.data.color
            new go.Binding("fill", "color")),
          $(go.TextBlock,
            { margin: 3 },  // some room around the text
            // TextBlock.text is bound to Node.data.key
            new go.Binding("text", "key"))
        );
  
      // create the model data that will be represented by Nodes and Links
      myDiagram.model = new go.GraphLinksModel(
        [
          { key: "Alpha", color: "#f38181" },
          { key: "Beta", color: "#eaffd0" },
          { key: "Gamma", color: "#95e1d3" },
          { key: "Delta", color: "#fce38a" }
        ],
        [
          { from: "Alpha", to: "Beta" },
          { from: "Alpha", to: "Gamma" },
          { from: "Beta", to: "Beta" },
          { from: "Gamma", to: "Delta" },
          { from: "Delta", to: "Alpha" }
        ]
      );
    }
    
    // A custom command, for changing the color of the selected node(s).
    function changeColor(diagram, color) {
      // Always make changes in a transaction, except when initializing the diagram.
      diagram.startTransaction("change color");
      diagram.selection.each(function(node) {
        if (node instanceof go.Node) {  // ignore any selected Links and simple Parts
          // Examine and modify the data, not the Node directly.
          var data = node.data;
          // Call setDataProperty to support undo/redo as well as
          // automatically evaluating any relevant bindings.
          diagram.model.setDataProperty(data, "color", color);
        }
      });
      diagram.commitTransaction("change color");
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
  <body style="background-color: lightgray;">
    <div id="contextMenuContainer" style="position: relative; zIndex: 10000;"></div>
    <div id="myDiagramDiv" style="border: solid 1px black; width:400px; height:400px"></div>
  </body>
</html>

