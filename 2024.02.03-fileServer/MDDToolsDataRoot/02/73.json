{
  "dslNameList": [
    "HierarchyDSL",
    "TextLabelsDSL",
    "CodeFlowDSL",
    "PicturesDSL"
  ],
  "view": {
    "scale": 0.7820482380187401,
    "position": [
      -308.6992930841652,
      -25380.841336963975
    ],
    "isGridOn": false
  },
  "graphFileServer": [],
  "model": "{ \"class\": \"GraphLinksModel\",\n  \"copiesArrays\": true,\n  \"copiesArrayObjects\": true,\n  \"copiesKey\": false,\n  \"linkKeyProperty\": \"key\",\n  \"linkFromPortIdProperty\": \"fromPort\",\n  \"linkToPortIdProperty\": \"toPort\",\n  \"nodeDataArray\": [\n{\"label\":\"Selection\",\"size\":\"180 60\",\"category\":\"Hierarchy_Selection\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphSelection$\",\"key\":0,\"location\":\"1093.9498887169657 -24567.22417018102\"},\n{\"label\":\"Model\",\"size\":\"180 60\",\"category\":\"Hierarchy_Model\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphModel$\",\"key\":1,\"location\":\"1093.9498887169657 -24657.22417018102\"},\n{\"label\":\"Graph Info\",\"category\":\"Hierarchy_GraphInfo\",\"size\":\"180 80\",\"props_\":[{\"name\":\"Name\",\"value\":\"label@2\",\"valueChanged\":\"true\"},{\"name\":\"Type\",\"value\":\"TemplateWorkSpace\",\"valueChanged\":true},{\"name\":\"Version\",\"value\":\"1.0\"},{\"name\":\"Date\",\"value\":\"date@system\"},{\"name\":\"Path\",\"value\":\"graphPath@system\"},{\"name\":\"Authors\",\"value\":\"userName@system\"}],\"key\":2,\"location\":\"1323.9498887169657 -24667.22417018102\"},\n{\"label\":\"This file is a Python code\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"256 58\",\"key\":3,\"location\":\"2933.9498887169657 -22757.22417018102\",\"group\":17},\n{\"label\":\"This file is a Python code\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"255 58\",\"key\":4,\"location\":\"2590 -22750\",\"group\":17},\n{\"label\":\"This file is a JavaScript code\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"293 58\",\"key\":5,\"location\":\"2610 -23090\",\"group\":17},\n{\"label\":\"File1.js\",\"color\":\"orange\",\"size\":\"401 124\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/*\\n * This file is code generated by GenDFE 1.0\\n *\\n * Generated on Sun, 21 Jan 2024 10:50:20 GMT\\n */\\n\\n/********************\\n * Node Functions\\n ********************/\\n// System function for reading properties\\nfunction nodeData_getProperty( name, defaultValue ) {\\n  // NOTE: this function access both nodeData fields and properties\\n  if( this.nd_[name] != undefined ) {\\n    return( this.nd_[name] );\\n  } else if( this.nd_.props_[name] != undefined ) {\\n    return( this.nd_.props_[name] );\\n  } else {\\n    return( defaultValue );\\n  }\\n}\\n// System function for reading input\\nfunction nodeData_getInput( name, defaultValue ) {\\n  if( this.in_[name] == undefined ) {\\n    this.in_[name] = defaultValue;\\n  }\\n  return( this.in_[name] );\\n}\\n// System function for storing access\\nfunction nodeData_setInput( name, value ) {\\n  this.in_[name] = value;\\n}\\n// System function for instance data access\\nfunction nodeData_get( name, defaultValue ) {\\n  if( this.st_[name] == undefined ) {\\n    this.st_[name] = defaultValue;\\n  }\\n  return( this.st_[name] );\\n}\\n// System function for firing inputs\\nfunction nodeData_fireInput( name, value ) {\\n  this.setInput( name, value );\\n  this.doCompute( name, value );\\n}\\n\\n/********************\\n * Model Functions\\n ********************/\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\nconst nodeData_7 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=z',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_9 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Parser',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_19.setInput( 'in', value );\\n      nodeData_19.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Tokenizer\\nconst nodeData_15 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Tokenizer',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_18.setInput( 'in', value );\\n      nodeData_18.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_15,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_19 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compute',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rValue', value );\\n      nodeData_58.doCompute( 'rValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rStatus', value );\\n      nodeData_58.doCompute( 'rStatus', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Split\\nconst nodeData_18 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Split',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'lEq' ) {\\n      // Store new input\\n      nodeData_26.setInput( 'in', value );\\n      nodeData_26.doCompute( 'in', value );\\n    } else if( name == 'rEq' ) {\\n      // Store new input\\n      nodeData_9.setInput( 'in', value );\\n      nodeData_9.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_18,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_26 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Parser',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'in', value );\\n      nodeData_27.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_27 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compute',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lValue', value );\\n      nodeData_58.doCompute( 'lValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lStatus', value );\\n      nodeData_58.doCompute( 'lStatus', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Compare\\nconst nodeData_25 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compare',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_34.setInput( 'in', value );\\n      nodeData_34.doCompute( 'in', value );\\n      // Store new input\\n      nodeData_45.setInput( 'in', value );\\n      nodeData_45.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_25,\\n};\\n// Node Info: [DataFlow_Message] y = 25\\nconst nodeData_34 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'y = 25',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\\nconst nodeData_38 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=10-4',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\\nconst nodeData_42 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=10-1',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] y=3*5+10\\nconst nodeData_46 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'y=3*5+10',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nconst nodeData_50 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Log Result\\nconst nodeData_45 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Log Result',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_45,\\n};\\n// Node Info: [DataFlow_Component] Barrier\\nconst nodeData_58 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Barrier',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_25.setInput( 'in', value );\\n      nodeData_25.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: MakeObject,\\n};\\n\\n/********************\\n * Compute Functions\\n ********************/\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\nfunction DataFlow_Message( name, value ) {\\n  \\n  if( value == undefined ) {\\n    value = this.getProperty( 'label', '' );\\n    try {\\n      value = JSON.parse( value ); \\n    } catch( e ) {}\\n  }\\n  this.fireOutput( 'out', value );\\n}\\n// Node Compute: [DataFlow_Component] Equation Parser\\nfunction EquationParser( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Build the AST tree (recursive function)\\n    const outValue = buildAST( value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n  function buildAST( tokenList ) {\\n    if( tokenList.length == 0 ) {\\n      return( null );\\n    } else if( tokenList.length == 1 ) {\\n      return( tokenList[0] );\\n    }\\n  \\n    // Find the index of the lowest precedence operator\\n    let index = -1;\\n    let minPrecedence = Infinity;\\n    let parenthesis = 0;\\n    // Loop over all tokenList\\n    for( let i = 0; i < tokenList.length; ++i ) {\\n      if( tokenList[i] == '(' ) {\\n        parenthesis++;\\n      } else if( tokenList[i] == ')' ) {\\n        parenthesis--;\\n      } else if( parenthesis === 0 ) {\\n        // Compute precedences\\n        const operator = tokenList[i];\\n        let precedence = 0;\\n        if( ( operator == '+' ) || ( operator == '-' ) ) {\\n          precedence = 1;\\n        } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n          precedence = 2;\\n        } else {\\n          precedence = Infinity;\\n        }\\n        \\n        if( precedence <= minPrecedence ) {\\n          minPrecedence = precedence;\\n          index = i;\\n        }\\n      }\\n    }\\n  \\n    // Handle subexpressions inside parentheses\\n    if( index === -1 ) {\\n      return( buildAST( tokenList.slice( 1, -1 ) ) );\\n    }\\n  \\n    const result = [\\n      tokenList[index],\\n      buildAST( tokenList.slice( 0, index ) ),\\n      buildAST( tokenList.slice( index+1 ))\\n    ];\\n    return( result );\\n  }\\n  \\n}\\n// Node Compute: [DataFlow_Component] Equation Tokenizer\\nfunction compute_15( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Tokenize the input equation\\n    const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|[=a-zA-Z]/g;\\n    const tokenList = value.match( regex ).map( token => {\\n      return( isNaN( token ) ? token : parseFloat( token ) );\\n    });\\n    \\n    this.fireOutput( 'out', tokenList );\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Compute\\nfunction EquationCompute( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = NaN;\\n    let outStatus = 'Done';\\n    try {\\n      if( value == null ) {\\n        outValue = '';\\n      } else {\\n        outValue = evaluateAST( value );\\n      }\\n    } catch( e ) {\\n      outStatus = `Syntax error in expression: ${e}`;\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n    this.fireOutput( 'status', outStatus );\\n  }\\n  \\n  function evaluateAST( ast ) {\\n    if( RegExp( /^[a-z]/i ).test( ast ) ) {\\n      return( ast );\\n    } else if( typeof( ast ) === 'number' ) {\\n      // Base case: if the node is a number, return it.\\n      return( ast );\\n    }\\n  \\n    // Recursive case: evaluate the left and right operands.\\n    const left = evaluateAST( ast[1] );\\n    const right = evaluateAST( ast[2] );\\n  \\n    // Compute the result based on the operator.\\n    switch( ast[0] ) {\\n      case '+':\\n        return( left + right );\\n      case '-':\\n        return( left - right );\\n      case '*':\\n        return( left * right );\\n      case '/':\\n        return( left / right );\\n      default:\\n        throw new Error( 'Unknown operator: ' + ast[0] );\\n    }\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Split\\nfunction compute_18( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let i = value.indexOf( '=' );\\n    if( i == -1 ) {\\n      i = value.length;\\n    }\\n    \\n    const lEq = value.slice( 0, i );\\n    const rEq = value.slice( i+1 );\\n    \\n    this.fireOutput( 'lEq', lEq );\\n    this.fireOutput( 'rEq', rEq );\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Parser\\n// Node Compute: [DataFlow_Component] Equation Compute\\n// Node Compute: [DataFlow_Component] Equation Compare\\nfunction compute_25( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = '';\\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n        outValue = value.lValue || value.rValue;\\n      } else if( isVariable( value.lValue  ) ) {\\n        outValue = `${value.lValue} = ${value.rValue}`;\\n      } else if( isVariable( value.rValue ) ) {\\n        outValue = `${value.rValue} = ${value.lValue}`;\\n      } else {\\n        outValue = String( value.lValue == value.rValue );\\n      }\\n    } else {\\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n  function isVariable( str ) {\\n    return( RegExp( /^[a-z]/i ).test( str ) );\\n  }\\n}\\n// Node Compute: [DataFlow_Message] y = 25\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\\n// Node Compute: [DataFlow_Message] y=3*5+10\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\n// Node Compute: [DataFlow_Component] Log Result\\nfunction compute_45( name, value ) {\\n  \\n  console.log( value );\\n}\\n// Node Compute: [DataFlow_Component] Barrier\\nfunction MakeObject( name, value ) {\\n  \\n  const defaultInputStat = {\\n    'lValue': false,\\n    'lStatus': false,\\n    'rValue': false,\\n    'rStatus': false,\\n  };\\n  const inputStat = this.get( 'inputStat', defaultInputStat );\\n  \\n  inputStat[name] = true;\\n  let isObjectReady = true;\\n  for( const inName in inputStat ) {\\n    if( !inputStat[inName] ) {\\n      isObjectReady = false;\\n      break;\\n    }\\n  }\\n  \\n  if( isObjectReady ) {\\n    const outValue = {};\\n    for( const inName in inputStat ) {\\n      inputStat[inName] = false;\\n      outValue[inName] = this.getInput( inName, null );\\n    }\\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n\\n/********************\\n * System Start\\n ********************/\\nnodeData_7.doCompute( 'in' );\\nnodeData_38.doCompute( 'in' );\\nnodeData_42.doCompute( 'in' );\\nnodeData_46.doCompute( 'in' );\\nnodeData_50.doCompute( 'in' );\\n\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":6,\"location\":\"2180 -23200\",\"group\":17},\n{\"label\":\"File2.js\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":true,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    gen.computeBuffer = {};                // Store all generated compute functions\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '/********************',\\n    ' * Node Functions',\\n    ' ********************/',\\n    '// System function for reading properties',\\n    'function nodeData_getProperty( name, defaultValue ) {',\\n    '  // NOTE: this function access both nodeData fields and properties',\\n    '  if( this.nd_[name] != undefined ) {',\\n    '    return( this.nd_[name] );',\\n    '  } else if( this.nd_.props_[name] != undefined ) {',\\n    '    return( this.nd_.props_[name] );',\\n    '  } else {',\\n    '    return( defaultValue );',\\n    '  }',\\n    '}',\\n    '// System function for reading input',\\n    'function nodeData_getInput( name, defaultValue ) {',\\n    '  if( this.in_[name] == undefined ) {',\\n    '    this.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( this.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function nodeData_setInput( name, value ) {',\\n    '  this.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function nodeData_get( name, defaultValue ) {',\\n    '  if( this.st_[name] == undefined ) {',\\n    '    this.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( this.st_[name] );',\\n    '}',\\n    '// System function for firing inputs',\\n    'function nodeData_fireInput( name, value ) {',\\n    '  this.setInput( name, value );',\\n    '  this.doCompute( name, value );',\\n    '}',\\n    '',\\n    '/********************',\\n    ' * Model Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\\n      generateNodeState( gen, nodeInfo );\\n    }\\n  }\\n  \\n  const funcHeader = [\\n    '',\\n    '/********************',\\n    ' * Compute Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( funcHeader );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\\n      generateNodeCompute( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    const sysStart =[\\n      '',\\n      '/********************',\\n      ' * System Start',\\n      ' ********************/' ];\\n    // Add lines\\n    gen.lines = gen.lines.concat( sysStart );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  const nodeDataObjOpen = [\\n    `const nodeData_${ni.key} = {`,\\n    `  in_: {},     // Input`,\\n    `  st_: {},     // Storage`,\\n    `  nd_: { // Properties`,\\n    `    label: '${ni.data.label}',`, // Some fields could be put here\\n    '    props_: {}', // It could be translated here into key,value?\\n    `  },`,\\n    `  out_: {},     // Output` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObjOpen );\\n  \\n  generateNodeFire( gen, ni );\\n  const nodeDataObjClose = [\\n    `  getProperty: nodeData_getProperty,`,\\n    `  getInput: nodeData_getInput,`,\\n    `  setInput: nodeData_setInput,`,\\n    `  fireInput: nodeData_fireInput,`,\\n    `  get: nodeData_get,`,\\n    `  doCompute: ${getComputeId( gen, ni )},`,\\n    `};` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObjClose );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  \\n  // Generate fire function\\n  gen.lines.push( `  fireOutput: function ( name, value ) {` );\\n  // Generate fire body\\n  if( portLen ) {\\n    gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `    } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, ni, '      ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `    }` );\\n  }\\n  gen.lines.push( `  },` );\\n}\\nfunction generateLinkCall( gen, ni, indent, link, value ) {\\n  // Check link type\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  \\n  // Get target input port name\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  // Generate input update if node info is defined\\n  if( ni ) {\\n    gen.lines.push( `${indent}// Store new input` );\\n    gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );\\n  }\\n  // Generate compute call\\n  if( value ) {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Get compute identifier\\n  let computeId = getComputeId( gen, ni );\\n  // Generate compute only if necessary\\n  if( computeId ) {\\n    addComputeId( gen, computeId );\\n    // Generate compute function\\n    gen.lines.push( `function ${computeId}( name, value ) {` );\\n    for( let line of ni.src ) {\\n      if( !isMainDeclSkipped ) {\\n        if( gen.declLine.test( line ) ) {\\n          isMainDeclSkipped = true;\\n        }\\n      } else {\\n        if( gen.fireLine.test( line ) ) {\\n          line = line.replace( gen.fireLine, `this.fireOutput(` );\\n        } else if( gen.getInLine.test( line ) ) {\\n          line = line.replace( gen.getInLine, `this.getInput(` );\\n        } else if( gen.getLine.test( line ) ) {\\n          line = line.replace( gen.getLine, `this.get(` );\\n        }\\n        gen.lines.push( `  ${line}` );\\n      }\\n    }\\n    gen.lines.push( `}` );\\n  }\\n}\\nfunction getComputeId( gen, ni ) {\\n  let result = null;\\n  let computeId = null;\\n  \\n  if( ni.data.doCompute ) {\\n    computeId = ni.data.doCompute;\\n  } else if( ni.data.fileTypeName && ni.data.fileTypeName != 'Component' ) {\\n    computeId = ni.data.fileTypeName;\\n  } else {\\n    computeId = `compute_${ni.key}`;\\n  }\\n  // If we did not generate the compute yet\\n  if( !gen.computeBuffer[computeId] ) {\\n    result = computeId;\\n  }\\n  return( result );\\n}\\nfunction addComputeId( gen, computeId ) {\\n  gen.computeBuffer[computeId] = true;\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      //`  value = \\\"${nodeInfo.label}\\\";`,\\n      `  value = this.getProperty( 'label', '' );`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `this.fireOutput( 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\\n\\nvar module;\\nif( module ) {\\n  module.exports = generationRoot;\\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":7,\"location\":\"2180 -23030\",\"editorPosition\":[3039,1058,799,1814],\"group\":17},\n{\"label\":\"System Status: [DEPLOYED]\\ndone\\nFilesCount: 0 of 1\\nDirCount: 1 of 1\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"390 120\",\"buttons_\":[{\"name\":\"Deploy\",\"checked\":true},{\"name\":\"Start\",\"checked\":true},{\"name\":\"Stop\",\"checked\":false}],\"props_\":[{\"name\":\"isOverwrite\",\"value\":\"true\",\"valueChanged\":\"true\"},{\"name\":\"scriptPath\",\"value\":\"TestDeploy/1.0\",\"valueChanged\":\"true\"},{\"name\":\"isAllEnabled\",\"value\":\"false\"}],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n  // Uncomment the next line to start debugging\\n  //debugger;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\nlet script = '';\\nlet params = '';\\nconst scriptPath = getProperty( 'scriptPath' );\\n//const g = getMainGraph();\\nlet onLoaded = function(){};\\n\\nswitch( obj.data.name ) {\\n  case 'Deploy':\\n    const modelFileURL = getMainGraphURL();\\n    const deployKey = nodeData.key;\\n    \\n    script = `generateSystemLib.js`;\\n    params = `modelFileURL=${modelFileURL}&deployKey=${deployKey}`;\\n    onLoaded = function( msg ) {\\n      setNodeDataField( nodeData, 'label', 'System Status: [DEPLOYED]\\\\n'+msg );\\n    }\\n    break;\\n  case 'Start':\\n    script = 'serverManager';\\n    params = 'start '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STARTED]' );\\n    break;\\n  case 'Stop':\\n    script = 'serverManager';\\n    params = 'stop '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STOPPED]' );\\n    break;\\n}\\n\\nif( script ) {\\n  const cmd = `${script}${( params? '?'+params: '')}`;\\n  executeScript( cmd, onLoaded );\\n}\\n\\nfunction getProperty( name ) {\\n  let result = '';\\n  if( nodeData.props_ ) {\\n    nodeData.props_.find( (p)=> { if( p.name == name ) { result = p.value; return( true ) } } );\\n  }\\n  return( result );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":8,\"location\":\"3840 -23310\",\"editorPosition\":[3132,1920,758,959]},\n{\"label\":\"This file is a JavaScript code\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"283 58\",\"key\":9,\"location\":\"2600 -23240\"},\n{\"label\":\"DFEGenerator 1.0\",\"category\":\"CodeFlow_FeatureOnOff\",\"size\":\"338 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":10,\"location\":\"2470 -24110\",\"group\":12},\n{\"label\":\"DummyEnable1\",\"category\":\"CodeFlow_Feature\",\"size\":\"180 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":11,\"location\":\"2880 -24110\",\"group\":12},\n{\"label\":\"Releases & Features\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":12,\"location\":\"2450 -24070\"},\n{\"label\":\"Dummy Enabled Component\",\"category\":\"CodeFlow_Code\",\"size\":\"180 100\",\"color\":\"orange\",\"props_\":[],\"in_\":[],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":13,\"location\":\"1543.9494590209715 -23390.123949712066\",\"group\":14},\n{\"label\":\"DummyEnable1\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":14,\"location\":\"1523.9494590209715 -23387.623949712066\",\"color\":\"green\",\"colorSwap\":\"gray\"},\n{\"label\":\"File3.py\",\"color\":\"firebrick\",\"size\":\"265 126\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Python\",\"fileType\":\"text/python\",\"fileURL\":\"/fileServer/02/71.py\",\"key\":15,\"location\":\"2590 -22850\",\"group\":17},\n{\"label\":\"File4.py\",\"color\":\"firebrick\",\"size\":\"265 126\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Python\",\"fileType\":\"text/python\",\"fileURL\":\"/fileServer/02/70.py\",\"key\":16,\"location\":\"2930 -22850\",\"group\":17},\n{\"label\":\"TestDeploy/1.0\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":17,\"location\":\"2160 -22896.5\"},\n{\"label\":\"Deploy Template\",\"category\":\"TextLabels_Size6\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"2521 240\",\"key\":18,\"location\":\"1563.9498887169657 -24597.22417018102\"},\n{\"label\":\"startServer.bat\",\"color\":\"gray\",\"size\":\"250 35\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Shell\",\"fileType\":\"application/x-shellscript\",\"fileURL\":\"\",\"key\":19,\"location\":\"2970 -23020\",\"group\":17},\n{\"label\":\"startServer.sh\",\"color\":\"gray\",\"size\":\"250 35\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Shell\",\"fileType\":\"application/x-shellscript\",\"fileURL\":\"\",\"key\":20,\"location\":\"2970 -23150\",\"group\":17,\"isExecutable\":true},\n{\"label\":\"startServer.ps1\",\"color\":\"gray\",\"size\":\"250 35\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Shell\",\"fileType\":\"application/x-shellscript\",\"fileURL\":\"\",\"key\":21,\"location\":\"2970 -23220\",\"group\":17},\n{\"label\":\"This file is a PowerShell script\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"293 58\",\"key\":23,\"location\":\"3230 -23230\",\"group\":17},\n{\"label\":\"This file is a shell script. It must be executable once deployed. This is done by setting the property \\\"isExecutable\\\": true\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"293 58\",\"key\":25,\"location\":\"3230 -23120\",\"group\":17},\n{\"label\":\"This file is a PowerShell script\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"293 58\",\"key\":27,\"location\":\"3230 -23020\",\"group\":17},\n{\"label\":\"File5.js\",\"color\":\"orange\",\"size\":\"401 124\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/*\\n * This file is code generated by GenDFE 1.0\\n *\\n * Generated on Sun, 21 Jan 2024 10:50:20 GMT\\n */\\n\\n/********************\\n * Node Functions\\n ********************/\\n// System function for reading properties\\nfunction nodeData_getProperty( name, defaultValue ) {\\n  // NOTE: this function access both nodeData fields and properties\\n  if( this.nd_[name] != undefined ) {\\n    return( this.nd_[name] );\\n  } else if( this.nd_.props_[name] != undefined ) {\\n    return( this.nd_.props_[name] );\\n  } else {\\n    return( defaultValue );\\n  }\\n}\\n// System function for reading input\\nfunction nodeData_getInput( name, defaultValue ) {\\n  if( this.in_[name] == undefined ) {\\n    this.in_[name] = defaultValue;\\n  }\\n  return( this.in_[name] );\\n}\\n// System function for storing access\\nfunction nodeData_setInput( name, value ) {\\n  this.in_[name] = value;\\n}\\n// System function for instance data access\\nfunction nodeData_get( name, defaultValue ) {\\n  if( this.st_[name] == undefined ) {\\n    this.st_[name] = defaultValue;\\n  }\\n  return( this.st_[name] );\\n}\\n// System function for firing inputs\\nfunction nodeData_fireInput( name, value ) {\\n  this.setInput( name, value );\\n  this.doCompute( name, value );\\n}\\n\\n/********************\\n * Model Functions\\n ********************/\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\nconst nodeData_7 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=z',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_9 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Parser',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_19.setInput( 'in', value );\\n      nodeData_19.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Tokenizer\\nconst nodeData_15 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Tokenizer',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_18.setInput( 'in', value );\\n      nodeData_18.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_15,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_19 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compute',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rValue', value );\\n      nodeData_58.doCompute( 'rValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rStatus', value );\\n      nodeData_58.doCompute( 'rStatus', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Split\\nconst nodeData_18 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Split',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'lEq' ) {\\n      // Store new input\\n      nodeData_26.setInput( 'in', value );\\n      nodeData_26.doCompute( 'in', value );\\n    } else if( name == 'rEq' ) {\\n      // Store new input\\n      nodeData_9.setInput( 'in', value );\\n      nodeData_9.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_18,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_26 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Parser',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'in', value );\\n      nodeData_27.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_27 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compute',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lValue', value );\\n      nodeData_58.doCompute( 'lValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lStatus', value );\\n      nodeData_58.doCompute( 'lStatus', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Compare\\nconst nodeData_25 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Equation Compare',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_34.setInput( 'in', value );\\n      nodeData_34.doCompute( 'in', value );\\n      // Store new input\\n      nodeData_45.setInput( 'in', value );\\n      nodeData_45.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_25,\\n};\\n// Node Info: [DataFlow_Message] y = 25\\nconst nodeData_34 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'y = 25',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\\nconst nodeData_38 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=10-4',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\\nconst nodeData_42 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1=10-1',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] y=3*5+10\\nconst nodeData_46 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'y=3*5+10',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nconst nodeData_50 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: '2+3*5-(2+20*0.5)+1',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Log Result\\nconst nodeData_45 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Log Result',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: compute_45,\\n};\\n// Node Info: [DataFlow_Component] Barrier\\nconst nodeData_58 = {\\n  in_: {},     // Input\\n  st_: {},     // Storage\\n  nd_: { // Properties\\n    label: 'Barrier',\\n    props_: {}\\n  },\\n  out_: {},     // Output\\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_25.setInput( 'in', value );\\n      nodeData_25.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: nodeData_getProperty,\\n  getInput: nodeData_getInput,\\n  setInput: nodeData_setInput,\\n  fireInput: nodeData_fireInput,\\n  get: nodeData_get,\\n  doCompute: MakeObject,\\n};\\n\\n/********************\\n * Compute Functions\\n ********************/\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\nfunction DataFlow_Message( name, value ) {\\n  \\n  if( value == undefined ) {\\n    value = this.getProperty( 'label', '' );\\n    try {\\n      value = JSON.parse( value ); \\n    } catch( e ) {}\\n  }\\n  this.fireOutput( 'out', value );\\n}\\n// Node Compute: [DataFlow_Component] Equation Parser\\nfunction EquationParser( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Build the AST tree (recursive function)\\n    const outValue = buildAST( value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n  function buildAST( tokenList ) {\\n    if( tokenList.length == 0 ) {\\n      return( null );\\n    } else if( tokenList.length == 1 ) {\\n      return( tokenList[0] );\\n    }\\n  \\n    // Find the index of the lowest precedence operator\\n    let index = -1;\\n    let minPrecedence = Infinity;\\n    let parenthesis = 0;\\n    // Loop over all tokenList\\n    for( let i = 0; i < tokenList.length; ++i ) {\\n      if( tokenList[i] == '(' ) {\\n        parenthesis++;\\n      } else if( tokenList[i] == ')' ) {\\n        parenthesis--;\\n      } else if( parenthesis === 0 ) {\\n        // Compute precedences\\n        const operator = tokenList[i];\\n        let precedence = 0;\\n        if( ( operator == '+' ) || ( operator == '-' ) ) {\\n          precedence = 1;\\n        } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n          precedence = 2;\\n        } else {\\n          precedence = Infinity;\\n        }\\n        \\n        if( precedence <= minPrecedence ) {\\n          minPrecedence = precedence;\\n          index = i;\\n        }\\n      }\\n    }\\n  \\n    // Handle subexpressions inside parentheses\\n    if( index === -1 ) {\\n      return( buildAST( tokenList.slice( 1, -1 ) ) );\\n    }\\n  \\n    const result = [\\n      tokenList[index],\\n      buildAST( tokenList.slice( 0, index ) ),\\n      buildAST( tokenList.slice( index+1 ))\\n    ];\\n    return( result );\\n  }\\n  \\n}\\n// Node Compute: [DataFlow_Component] Equation Tokenizer\\nfunction compute_15( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Tokenize the input equation\\n    const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|[=a-zA-Z]/g;\\n    const tokenList = value.match( regex ).map( token => {\\n      return( isNaN( token ) ? token : parseFloat( token ) );\\n    });\\n    \\n    this.fireOutput( 'out', tokenList );\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Compute\\nfunction EquationCompute( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = NaN;\\n    let outStatus = 'Done';\\n    try {\\n      if( value == null ) {\\n        outValue = '';\\n      } else {\\n        outValue = evaluateAST( value );\\n      }\\n    } catch( e ) {\\n      outStatus = `Syntax error in expression: ${e}`;\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n    this.fireOutput( 'status', outStatus );\\n  }\\n  \\n  function evaluateAST( ast ) {\\n    if( RegExp( /^[a-z]/i ).test( ast ) ) {\\n      return( ast );\\n    } else if( typeof( ast ) === 'number' ) {\\n      // Base case: if the node is a number, return it.\\n      return( ast );\\n    }\\n  \\n    // Recursive case: evaluate the left and right operands.\\n    const left = evaluateAST( ast[1] );\\n    const right = evaluateAST( ast[2] );\\n  \\n    // Compute the result based on the operator.\\n    switch( ast[0] ) {\\n      case '+':\\n        return( left + right );\\n      case '-':\\n        return( left - right );\\n      case '*':\\n        return( left * right );\\n      case '/':\\n        return( left / right );\\n      default:\\n        throw new Error( 'Unknown operator: ' + ast[0] );\\n    }\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Split\\nfunction compute_18( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let i = value.indexOf( '=' );\\n    if( i == -1 ) {\\n      i = value.length;\\n    }\\n    \\n    const lEq = value.slice( 0, i );\\n    const rEq = value.slice( i+1 );\\n    \\n    this.fireOutput( 'lEq', lEq );\\n    this.fireOutput( 'rEq', rEq );\\n  }\\n}\\n// Node Compute: [DataFlow_Component] Equation Parser\\n// Node Compute: [DataFlow_Component] Equation Compute\\n// Node Compute: [DataFlow_Component] Equation Compare\\nfunction compute_25( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = '';\\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n        outValue = value.lValue || value.rValue;\\n      } else if( isVariable( value.lValue  ) ) {\\n        outValue = `${value.lValue} = ${value.rValue}`;\\n      } else if( isVariable( value.rValue ) ) {\\n        outValue = `${value.rValue} = ${value.lValue}`;\\n      } else {\\n        outValue = String( value.lValue == value.rValue );\\n      }\\n    } else {\\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n  function isVariable( str ) {\\n    return( RegExp( /^[a-z]/i ).test( str ) );\\n  }\\n}\\n// Node Compute: [DataFlow_Message] y = 25\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\\n// Node Compute: [DataFlow_Message] y=3*5+10\\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\n// Node Compute: [DataFlow_Component] Log Result\\nfunction compute_45( name, value ) {\\n  \\n  console.log( value );\\n}\\n// Node Compute: [DataFlow_Component] Barrier\\nfunction MakeObject( name, value ) {\\n  \\n  const defaultInputStat = {\\n    'lValue': false,\\n    'lStatus': false,\\n    'rValue': false,\\n    'rStatus': false,\\n  };\\n  const inputStat = this.get( 'inputStat', defaultInputStat );\\n  \\n  inputStat[name] = true;\\n  let isObjectReady = true;\\n  for( const inName in inputStat ) {\\n    if( !inputStat[inName] ) {\\n      isObjectReady = false;\\n      break;\\n    }\\n  }\\n  \\n  if( isObjectReady ) {\\n    const outValue = {};\\n    for( const inName in inputStat ) {\\n      inputStat[inName] = false;\\n      outValue[inName] = this.getInput( inName, null );\\n    }\\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n\\n/********************\\n * System Start\\n ********************/\\nnodeData_7.doCompute( 'in' );\\nnodeData_38.doCompute( 'in' );\\nnodeData_42.doCompute( 'in' );\\nnodeData_46.doCompute( 'in' );\\nnodeData_50.doCompute( 'in' );\\n\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":31,\"location\":\"2180 -22590\",\"group\":17},\n{\"label\":\"This file is not deployed when it is connected to a disabled group (gray title)\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"293 58\",\"key\":33,\"location\":\"2610 -22610\"},\n{\"label\":\"Dummy Enabled Component\",\"category\":\"CodeFlow_Code\",\"size\":\"180 100\",\"color\":\"orange\",\"props_\":[],\"in_\":[],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":36,\"location\":\"1550 -23160\",\"group\":37},\n{\"label\":\"DummyEnable2\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":37,\"location\":\"1530 -23157.5\",\"color\":\"gray\",\"colorSwap\":\"green\"},\n{\"label\":\"DFEGenerator 1.1\",\"category\":\"CodeFlow_FeatureOnOff\",\"size\":\"338 40\",\"color\":\"RebeccaPurple\",\"buttons_\":[{\"name\":\"\",\"checked\":false,\"color\":\"green\"}],\"key\":40,\"location\":\"2470 -24030.1\",\"group\":12},\n{\"label\":\"DummyEnable2\",\"category\":\"CodeFlow_Feature\",\"size\":\"180 40\",\"color\":\"RebeccaPurple\",\"buttons_\":[{\"name\":\"\",\"checked\":false,\"color\":\"green\"}],\"key\":41,\"location\":\"2880 -24030\",\"group\":12},\n{\"label\":\"These groups with nodes are used to enable/disable nodes in the deploy group connected them. Enabling (green title) and disabling (gray title) of nodes can be done in the \\\"Release & Feature\\\" by enabling or disabling the correspondent feature.\\nEnabled nodes in the deploy group (TestDeploy/1.0) will be deployed to the target directory. While disabled nodes will not be deployed\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"287 396\",\"key\":43,\"location\":\"1200 -23290\"},\n{\"label\":\"This group is used to define features and releases. Releases can be enabled/disabled by their checkbox. Features should have the same name as the group where the feature is implemented into. Green features/releases are enabled. The one in gray are disabled\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"390 215\",\"key\":44,\"location\":\"2040 -24080\"},\n{\"label\":\"This group is used to define all files that could be deployed\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"390 63\",\"key\":46,\"location\":\"2690 -23390\"},\n{\"label\":\"This node is the deployment function.\\nClick:\\n- Deploy: to execute deployment\\n- Start: to execute the start script in the deployment\\n- Stop: to execute the stop scrip in the deployment\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"390 188\",\"key\":48,\"location\":\"3840 -23484\"},\n{\"label\":\"NOTE: by setting property \\\"isAllEnabled\\\" = true, all files/directory in the deploy group will be generated regardless if connected to a generating node\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"390 130\",\"key\":38,\"location\":\"3850 -23110\",\"fontColor\":\"FireBrick\"}\n],\n  \"linkDataArray\": [\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":8,\"to\":17,\"points\":[3840,-23309.86071243901,3553.5,-23309.656066868636],\"key\":-3,\"color\":\"YellowGreen\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"Feature\",\"toPort\":\"Feature\",\"from\":10,\"to\":11,\"points\":[2808,-24110,2870,-24110,2880,-24110],\"key\":-4,\"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":13,\"to\":6,\"points\":[1764.4113730834715,-23390.123949712066,1774.4113730834715,-23390.123949712066,1920,-23390,1920,-23210,2180.0001175939356,-23204.360084217053],\"key\":-5,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":13,\"to\":7,\"points\":[1764.4113730834715,-23390.123949712066,1774.4113730834715,-23390.123949712066,1910,-23380,1910,-23030,2180,-23030],\"key\":-6,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":13,\"to\":15,\"points\":[1764.4113730834715,-23390.123949712066,1774.4113730834715,-23390.123949712066,1900,-23370,1900,-22850,2590,-22850],\"key\":-7,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":13,\"to\":16,\"points\":[1764.4113730834715,-23390.123949712066,1774.4113730834715,-23390.123949712066,1890,-23360,1890,-22930,3060,-22930,3060.6187631697053,-22913.499648807854],\"key\":-8,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":36,\"to\":31,\"points\":[1770.4619140625,-23160,1780.4619140625,-23160,1850,-23160,1850,-22590,2180,-22590],\"key\":-9,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"Feature\",\"toPort\":\"Feature\",\"from\":40,\"to\":41,\"points\":[2808,-24030.026839826838,2870,-24030,2880,-24030],\"key\":-10,\"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"Feature\",\"toPort\":\"Feature\",\"from\":40,\"to\":11,\"points\":[2721.853566958697,-24050.1,2870,-24110,2880,-24110],\"key\":-11,\"color\":\"RebeccaPurple\"}\n]}"
}