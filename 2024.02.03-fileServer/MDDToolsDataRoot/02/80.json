{
  "dslNameList": [
    "HierarchyDSL",
    "TextLabelsDSL",
    "CodeFlowDSL",
    "PicturesDSL",
    "DataFlowDSL"
  ],
  "view": {
    "scale": 0.5125099719364935,
    "position": [
      -6136.961020291637,
      -164.92973614003176
    ],
    "isGridOn": false
  },
  "graphFileServer": [],
  "model": "{ \"class\": \"GraphLinksModel\",\n  \"copiesArrays\": true,\n  \"copiesArrayObjects\": true,\n  \"copiesKey\": false,\n  \"linkKeyProperty\": \"key\",\n  \"linkFromPortIdProperty\": \"fromPort\",\n  \"linkToPortIdProperty\": \"toPort\",\n  \"nodeDataArray\": [\n{\"label\":\"Graph Info\",\"category\":\"Hierarchy_GraphInfo\",\"size\":\"180 80\",\"props_\":[{\"name\":\"Name\",\"value\":\"label@6\",\"valueChanged\":true},{\"name\":\"Version\",\"value\":\"1.0\"},{\"name\":\"Date\",\"value\":\"20/01/2024\"},{\"name\":\"Path\",\"value\":\"/fileServer/02/80.json\",\"valueChanged\":\"true\"},{\"name\":\"Authors\",\"value\":\"- Antonello\\n- Frank\",\"valueChanged\":\"true\"}],\"key\":0,\"location\":\"390 -70\"},\n{\"label\":\"Model\",\"size\":\"180 60\",\"category\":\"Hierarchy_Model\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphModel$\",\"key\":2,\"location\":\"130 -70\"},\n{\"label\":\"Selection\",\"size\":\"180 60\",\"category\":\"Hierarchy_Selection\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphSelection$\",\"key\":4,\"location\":\"130 20\"},\n{\"label\":\"Test DataFlow & Code Generation v.1.4\",\"category\":\"TextLabels_Size6\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"5269 240\",\"key\":6,\"location\":\"660 -10\"},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\ndebugger\\nif( name == 'in' ) {\\n  // Build the AST tree (recursive function)\\n  const outValue = buildAST( value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":9,\"location\":\"-880 3048.773\",\"editorPosition\":[1964,1907,466,193],\"group\":36},\n{\"label\":\"[\\n  \\\"+\\\",\\n  [\\n    \\\"*\\\",\\n    3,\\n    [\\n      \\\"sin\\\",\\n      null,\\n      2\\n    ]\\n  ],\\n  4\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":11,\"location\":\"-498.103515625 3468.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":55},\n{\"label\":\"DataFlow Engine\",\"color\":\"orange\",\"size\":\"420 140\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"fileURL\":\"lib/DataFlowEngine/1.5/DataFlowEngine.js\",\"key\":8,\"location\":\"4150 950\",\"editorPosition\":[1087,1811,666,1123]},\n{\"label\":\"New Engine Instance \\n         onLoad\",\"color\":\"orange\",\"size\":\"430 80\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"DataFlowEngine.getInstance();\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":10,\"location\":\"4150 1110\",\"isIncludeScript\":true},\n{\"label\":\"Equation Tokenizer\",\"category\":\"DataFlow_Component\",\"size\":\"255 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  // Split each line\\n  const lineList = value.split( '\\\\n' );\\n  for( const line of lineList ) {\\n    // Tokenize the input equation\\n    const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+/g;\\n    let tokenList = [];\\n    if( value ) {\\n      tokenList = line.match( regex ).map( token => {\\n        return( isNaN( token ) ? token : parseFloat( token ) );\\n      });\\n    }\\n    \\n    graphData.dfe.fireOutput( nodeData, 'out', tokenList );\\n  }\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":15,\"location\":\"-1970 2958.773\",\"group\":36,\"editorPosition\":[-4464,1910,494,263]},\n{\"label\":\"[\\n  \\\"test\\\",\\n  \\\"=\\\",\\n  3,\\n  \\\"*\\\",\\n  \\\"sin\\\",\\n  \\\"(\\\",\\n  2,\\n  \\\")\\\",\\n  \\\"+\\\",\\n  4\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 451\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":17,\"location\":\"-1598.103515625 3318.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":53},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"254 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"\\nvar nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = NaN;\\n  let outStatus = 'Done';\\n  try {\\n    if( value == null ) {\\n      outValue = '';\\n    } else {\\n      const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n      const variableValues = getVariableValues( variables );\\n\\n      outValue = evaluateAST( value, variableValues );\\n    }\\n  } catch( e ) {\\n    outStatus = `Syntax error in expression: ${e}`;\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\\n}\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":19,\"location\":\"-320 3068.773\",\"group\":36,\"editorPosition\":[2441,1906,560,417]},\n{\"label\":\"\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 64\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":21,\"location\":\"163.79296875 3224.431\",\"group\":56},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":23,\"location\":\"161.896484375 3295.1150000000002\",\"group\":56},\n{\"label\":\"Equation Split\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"lEq\"},{\"portId\":\"2out\",\"name\":\"rEq\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let i = value.indexOf( '=' );\\n  if( i == -1 ) {\\n    i = value.length;\\n  }\\n  \\n  const lEq = value.slice( 0, i );\\n  const rEq = value.slice( i+1 );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'lEq', lEq );\\n  graphData.dfe.fireOutput( nodeData, 'rEq', rEq );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":18,\"location\":\"-1420 2958.773\",\"group\":36},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  // Build the AST tree (recursive function)\\n  const outValue = buildAST( value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":26,\"location\":\"-860 2798.773\",\"editorPosition\":[1270,1836,523,943],\"group\":36},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"253 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"\\nvar nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = NaN;\\n  let outStatus = 'Done';\\n  try {\\n    if( value == null ) {\\n      outValue = '';\\n    } else {\\n      const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n      const variableValues = getVariableValues( variables );\\n\\n      outValue = evaluateAST( value, variableValues );\\n    }\\n  } catch( e ) {\\n    outStatus = `Syntax error in expression: ${e}`;\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\\n}\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":27,\"location\":\"-320 2808.773\",\"group\":36},\n{\"label\":\"6\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 68\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":28,\"location\":\"163.79296875 2654.431\",\"group\":48},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":29,\"location\":\"161.896484375 2727.1150000000002\",\"group\":48},\n{\"label\":\"[\\n  \\\"+\\\",\\n  [\\n    \\\"-\\\",\\n    [\\n      \\\"+\\\",\\n      2,\\n      [\\n        \\\"*\\\",\\n        3,\\n        5\\n      ]\\n    ],\\n    [\\n      \\\"+\\\",\\n      2,\\n      [\\n        \\\"*\\\",\\n        20,\\n        0.5\\n      ]\\n    ]\\n  ],\\n  1\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":31,\"location\":\"-518.103515625 2448.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":49},\n{\"label\":\"[\\n  \\\"test\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 352\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":33,\"location\":\"-1068.103515625 2588.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":52},\n{\"label\":\"[\\n  3,\\n  \\\"*\\\",\\n  \\\"sin\\\",\\n  \\\"(\\\",\\n  2,\\n  \\\")\\\",\\n  \\\"+\\\",\\n  4\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 293\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":35,\"location\":\"-1068.103515625 3288.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":54},\n{\"label\":\"Equation Evaluate\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"variable\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = '';\\n  if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n    if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n      outValue = value.lValue || value.rValue;\\n    } else if( isVariable( value.lValue  ) ) {\\n      outValue = `${value.lValue} = ${value.rValue}`;\\n      const varValue = { id: value.lValue, value: value.rValue };\\n      graphData.dfe.fireOutput( nodeData, 'variable', varValue );\\n    } else if( isVariable( value.rValue ) ) {\\n      outValue = `${value.rValue} = ${value.lValue}`;\\n      const varValue = { id: value.rValue, value: value.lValue };\\n      graphData.dfe.fireOutput( nodeData, 'variable', varValue );\\n    } else {\\n      outValue = String( value.lValue == value.rValue );\\n    }\\n  } else {\\n    outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":25,\"location\":\"580 2978.773\",\"group\":36,\"editorPosition\":[3690,1891,610,424]},\n{\"label\":\"6\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"364 72\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":34,\"location\":\"1000 2958.773\",\"group\":36},\n{\"label\":\"2+3*5-(2+20*0.5)+1\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":50,\"location\":\"-2700 2769.214\",\"group\":36},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":51,\"location\":\"-3680 2768.773\",\"group\":36},\n{\"label\":\"Simple Language Interpreter Model\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":36,\"location\":\"-3950 2940.815494140625\"},\n{\"label\":\"Executor: [Execution...Done]\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"412 120\",\"buttons_\":[{\"name\":\"Generate\",\"checked\":true},{\"name\":\"Execute\",\"checked\":false}],\"props_\":[],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Generation Instance Data\\nconst gen = getGenInfo( nodeData, 'javascript' );\\n\\nswitch( obj.data.name ) {\\n  \\n  case 'Generate':\\n    setNodeDataField( nodeData, 'label', 'Generator: [Generating...]' );\\n    const onGenerated = function( source, msg ) {\\n      if( msg.startsWith( 'Success:' ) ) {\\n        // Set target component source\\n        setNodeDataField( gen.targetData.key, 'fileContent', source );\\n      }\\n      // Update generator status\\n      setNodeDataField( nodeData, 'label', 'Generator: [Generation...Done]\\\\n'+msg );\\n    };\\n    \\n    if( gen.groupKey != null && gen.targetData ) {\\n      generationRoot( gen, onGenerated );\\n    } else {\\n      alert( 'Generation Components needs to have 2 fan out nodes:\\\\n'+\\n           '- Group (a group with a model, Group_BasicGroup),\\\\n'+\\n           '- Code (target source component, Hierarchy_CodeInGraph)' );\\n    }\\n    break;\\n  case 'Execute':\\n    setNodeDataField( nodeData, 'label', 'Executor: [Executing...]' );\\n    executeCode( gen );\\n    setNodeDataField( nodeData, 'label', 'Executor: [Execution...Done]' );\\n    break;\\n}\\n\\nfunction getGenInfo( nodeData, language ) {\\n  // Generation Instance Data\\n  const gen = {\\n    name: 'GenDFE 1.3',      // Code generator name and version\\n    groupKey: null,          // Group node key containing the Model to be generated\\n    targetData: null,        // Target node to store generated code\\n    me: null,                // ModelExplorer\\n    modelId: 'main',         // Model Id\\n    language: language,      // Target output language\\n    lang: dfeCGConfig.lang[language], // Language specific generators\\n  };\\n  \\n  // Initialize generation info\\n  const g = getMainGraph();\\n  // The model is the source of the WorkSpace (as found in the xx.json file)\\n  // it is in string form with full content\\n  const model = g.getJSONModel();\\n  // An alternative is to put in model the full source of the WorkSpace file\\n  // by reading it in text form from the server directory: .../xx/yy.json\\n  \\n  // Initialize ModelExplorer with full model\\n  gen.me = new ModelExplorer();\\n  gen.me.setJSONModel( gen.modelId, model );\\n  \\n  // Use Model to Code Generate\\n  const dataList = gen.me.getNodeListFanOutByNodeKey( gen.modelId, nodeData.key );\\n  // If at least a node has been found\\n  if( dataList && dataList.length ) {\\n    for( const data of dataList ) {\\n      if( data.category.startsWith( 'Group_' ) ) {\\n        gen.groupKey = data.key;\\n      } else if( data.category.startsWith( 'Hierarchy_CodeInGraph' ) ) {\\n        gen.targetData = data;\\n      }\\n    }\\n  }\\n  return( gen );\\n}\\nfunction executeCode( gen ) {\\n  console.log( 'Executing Generated Code...' );\\n  \\n  const source = gen.targetData.fileContent;\\n  eval( source );\\n  console.log( 'Execution Done.' );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":37,\"location\":\"1820 2080\",\"editorPosition\":[2562,1007,804,1305]},\n{\"label\":\"TargetCode.js\",\"color\":\"orange\",\"size\":\"211 124\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/*\\n * This file is code generated by GenDFE 1.3\\n * \\n * Generated on Thu, 25 Jan 2024 07:56:33 GMT\\n * \\n */\\n\\n\\n/*****************************************\\n * Node Functions\\n *****************************************/\\n// System function for reading properties\\nfunction DFE_getProperty( name, defaultValue ) {\\n  // NOTE: this function access both nodeData fields and properties\\n  if( this.nd_[name] != undefined ) {\\n    return( this.nd_[name] );\\n  } else if( this.nd_.props_[name] != undefined ) {\\n    return( this.nd_.props_[name] );\\n  } else {\\n    return( defaultValue );\\n  }\\n}\\n// System function for property data access\\nfunction DFE_getPropertyList() {\\n  return( this.nd_.props_ );\\n}\\n// System function for reading input\\nfunction DFE_getInput( name, defaultValue ) {\\n  if( this.in_[name] == undefined ) {\\n    this.in_[name] = defaultValue;\\n  }\\n  return( this.in_[name] );\\n}\\n// System function for storing input\\nfunction DFE_setInput( name, value ) {\\n  this.in_[name] = value;\\n}\\n// System function for getting input name list\\nfunction DFE_getInputNameList() {\\n  return( this.nd_.in_ );\\n}\\n// System function for getting output name list\\nfunction DFE_getOutputNameList() {\\n  return( this.nd_.out_ );\\n}\\n// System function for instance data access\\nfunction DFE_get( name, defaultValue ) {\\n  if( this.st_[name] == undefined ) {\\n    this.st_[name] = defaultValue;\\n  }\\n  return( this.st_[name] );\\n}\\n// System function for instance data storage\\nfunction DFE_set( name, value ) {\\n  this.st_[name] = value;\\n}\\n// System function for firing inputs\\nfunction DFE_fireInput( name, value ) {\\n  this.setInput( name, value );\\n  this.doCompute( name, value );\\n}\\n\\n\\n/*****************************************\\n * Node Functions/Model States\\n *****************************************/\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_9 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_19.setInput( 'in', value );\\n      nodeData_19.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Tokenizer\\nconst nodeData_15 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Tokenizer',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_18.setInput( 'in', value );\\n      nodeData_18.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_15,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_19 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rValue', value );\\n      nodeData_58.doCompute( 'rValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rStatus', value );\\n      nodeData_58.doCompute( 'rStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Split\\nconst nodeData_18 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Split',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'lEq',\\n      'rEq',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'lEq' ) {\\n      // Store new input\\n      nodeData_26.setInput( 'in', value );\\n      nodeData_26.doCompute( 'in', value );\\n    } else if( name == 'rEq' ) {\\n      // Store new input\\n      nodeData_9.setInput( 'in', value );\\n      nodeData_9.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_18,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_26 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'in', value );\\n      nodeData_27.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_27 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lValue', value );\\n      nodeData_58.doCompute( 'lValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lStatus', value );\\n      nodeData_58.doCompute( 'lStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Evaluate\\nconst nodeData_25 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Evaluate',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'variable',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_34.setInput( 'in', value );\\n      nodeData_34.doCompute( 'in', value );\\n      // Store new input\\n      nodeData_45.setInput( 'in', value );\\n      nodeData_45.doCompute( 'in', value );\\n    } else if( name == 'variable' ) {\\n      // Store new input\\n      nodeData_92.setInput( 'in', value );\\n      nodeData_92.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_25,\\n};\\n// Node Info: [DataFlow_Message] var = 33\\nconst nodeData_34 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'var = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nconst nodeData_50 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Log Result\\nconst nodeData_45 = {\\n  in_: {},       // Input values\\n  nd_: {         // Full node fields/properties\\n    label: 'Log Result',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '*',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_45,\\n};\\n// Node Info: [DataFlow_Component] Barrier\\nconst nodeData_58 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Barrier',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'lValue',\\n      'lStatus',\\n      'rValue',\\n      'rStatus',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_25.setInput( 'in', value );\\n      nodeData_25.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_MakeObject,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor\\nconst nodeData_122 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33\\nconst nodeData_88 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'variables', value );\\n      nodeData_27.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_19.setInput( 'variables', value );\\n      nodeData_19.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_92.setInput( 'variables', value );\\n      nodeData_92.doCompute( 'variables', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Variable Update\\nconst nodeData_92 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Variable Update',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_92,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\nconst nodeData_96 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n\\n/*****************************************\\n * Compute Functions\\n *****************************************/\\n// Node Compute[9]: [DataFlow_Component] Equation Parser\\nfunction compute_EquationParser( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Build the AST tree (recursive function)\\n    const outValue = buildAST( value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[15]: [DataFlow_Component] Equation Tokenizer\\nfunction compute_Component_15( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Split each line\\n    const lineList = value.split( '\\\\n' );\\n    for( const line of lineList ) {\\n      // Tokenize the input equation\\n      const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+/g;\\n      let tokenList = [];\\n      if( value ) {\\n        tokenList = line.match( regex ).map( token => {\\n          return( isNaN( token ) ? token : parseFloat( token ) );\\n        });\\n      }\\n      \\n      this.fireOutput( 'out', tokenList );\\n    }\\n  }\\n}\\n// Node Compute[19]: [DataFlow_Component] Equation Compute\\nfunction compute_EquationCompute( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = NaN;\\n    let outStatus = 'Done';\\n    try {\\n      if( value == null ) {\\n        outValue = '';\\n      } else {\\n        const variables = this.getInput( 'variables', '' );\\n        const variableValues = getVariableValues( variables );\\n  \\n        outValue = evaluateAST( value, variableValues );\\n      }\\n    } catch( e ) {\\n      outStatus = `Syntax error in expression: ${e}`;\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n    this.fireOutput( 'status', outStatus );\\n  }\\n}\\n// Node Compute[18]: [DataFlow_Component] Equation Split\\nfunction compute_Component_18( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let i = value.indexOf( '=' );\\n    if( i == -1 ) {\\n      i = value.length;\\n    }\\n    \\n    const lEq = value.slice( 0, i );\\n    const rEq = value.slice( i+1 );\\n    \\n    this.fireOutput( 'lEq', lEq );\\n    this.fireOutput( 'rEq', rEq );\\n  }\\n}\\n// Node Compute[25]: [DataFlow_Component] Equation Evaluate\\nfunction compute_Component_25( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = '';\\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n        outValue = value.lValue || value.rValue;\\n      } else if( isVariable( value.lValue  ) ) {\\n        outValue = `${value.lValue} = ${value.rValue}`;\\n        const varValue = { id: value.lValue, value: value.rValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else if( isVariable( value.rValue ) ) {\\n        outValue = `${value.rValue} = ${value.lValue}`;\\n        const varValue = { id: value.rValue, value: value.lValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else {\\n        outValue = String( value.lValue == value.rValue );\\n      }\\n    } else {\\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Compute[34]: [DataFlow_Message] var = 33\\nfunction compute_DataFlow_Message( name, value ) {\\n  \\n  if( value == undefined ) {\\n    value = this.getProperty( 'label', '' );\\n    try {\\n      value = JSON.parse( value ); \\n    } catch( e ) {}\\n  }\\n  this.fireOutput( 'out', value );\\n}\\n// Node Compute[45]: [DataFlow_Component] Log Result\\nfunction compute_Component_45( name, value ) {\\n  \\n  console.log( value );\\n}\\n// Node Compute[58]: [DataFlow_Component] Barrier\\nfunction compute_MakeObject( name, value ) {\\n  \\n  const inNameList = this.getInputNameList( );\\n  const inputStat = this.get( 'inputStat', {} );\\n  \\n  inputStat[name] = true;\\n  let isObjectReady = true;\\n  for( const inName of inNameList ) {\\n    if( !inputStat[inName] ) {\\n      isObjectReady = false;\\n      break;\\n    }\\n  }\\n  \\n  if( isObjectReady ) {\\n    this.set( 'inputStat', {} );\\n    \\n    const outValue = {};\\n    for( const inName of inNameList ) {\\n      outValue[inName] = this.getInput( inName, null );\\n    }\\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[92]: [DataFlow_Component] Variable Update\\nfunction compute_Component_92( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    const variables = this.getInput( 'variables', '' );\\n    let outValue = updateVariableValue( variables, value.id, value.value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Includes[94]: [Hierarchy_CodeInGraph] Helper Functions\\nfunction getVariableValues( variables ) {\\n  const result = {};\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    result[match[1]] = match[2];\\n  }\\n  return( result );\\n}\\nfunction updateVariableValue( variables, id, value ) {\\n  const result = [];\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n  let isVarUpdated = false;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    if( match[1] == id ) {\\n      isVarUpdated = true;\\n      result.push( `${match[1]} = ${value}` );\\n    } else {\\n     result.push( `${match[1]} = ${match[2]}` );\\n    }\\n  }\\n  if( !isVarUpdated ) {\\n    result.push( `${id} = ${value}` );\\n  }\\n  return( result.join( '\\\\n' ) );\\n}\\nfunction isVariable( str ) {\\n  return( RegExp( /^[a-z]/i ).test( str ) );\\n}\\nfunction buildAST( tokenList ) {\\n  if( tokenList.length == 0 ) {\\n    return( null );\\n  } else if( tokenList.length == 1 ) {\\n    return( tokenList[0] );\\n  }\\n\\n  // Find the index of the lowest precedence operator\\n  let index = -1;\\n  let minPrecedence = Infinity;\\n  let parenthesis = 0;\\n  // Loop over all tokenList\\n  for( let i = 0; i < tokenList.length; ++i ) {\\n    if( tokenList[i] == '(' ) {\\n      parenthesis++;\\n    } else if( tokenList[i] == ')' ) {\\n      parenthesis--;\\n    } else if( parenthesis === 0 ) {\\n      // Compute precedences\\n      const operator = tokenList[i];\\n      let precedence = 0;\\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\\n        precedence = 1;\\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n        precedence = 2;\\n      } else {\\n        precedence = Infinity;\\n      }\\n      \\n      if( precedence <= minPrecedence ) {\\n        minPrecedence = precedence;\\n        index = i;\\n      }\\n    }\\n  }\\n\\n  // Handle subexpressions inside parentheses\\n  if( index === -1 ) {\\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\\n  }\\n\\n  const result = [\\n    tokenList[index],\\n    buildAST( tokenList.slice( 0, index ) ),\\n    buildAST( tokenList.slice( index+1 ))\\n  ];\\n  return( result );\\n}\\nfunction evaluateAST( ast, variables ) {\\n  \\n  if( RegExp( /^[a-z_]/i ).test( ast ) ) {\\n    const varValue = variables[ast];\\n    if( varValue != undefined ) {\\n      return( parseFloat( varValue ) );\\n    } else {\\n      return( ast );\\n    }\\n  } else if( typeof( ast ) === 'number' ) {\\n    // Base case: if the node is a number, return it.\\n    return( ast );\\n  }\\n\\n  // Recursive case: evaluate the left and right operands.\\n  const left = evaluateAST( ast[1], variables );\\n  const right = evaluateAST( ast[2], variables );\\n\\n  // Compute the result based on the operator.\\n  switch( ast[0] ) {\\n    case '+':\\n      return( left + right );\\n    case '-':\\n      return( left - right );\\n    case '*':\\n      return( left * right );\\n    case '/':\\n      return( left / right );\\n    default:\\n      throw new Error( 'Unknown operator: ' + ast[0] );\\n  }\\n}\\n\\n/*****************************************\\n * System Start\\n *****************************************/\\nnodeData_96.doCompute( 'in' );\\nnodeData_50.doCompute( 'in' );\\nnodeData_96.doCompute( 'in' );\\nnodeData_122.doCompute( 'in' );\\n\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":44,\"location\":\"3100 2080\",\"group\":78,\"editorPosition\":[1449,992,670,1631]},\n{\"label\":\"Log Result\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"*\"}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nconsole.log( value );\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":45,\"location\":\"1000 3068.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":48,\"location\":\"110 2688.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":49,\"location\":\"-570 2448.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":52,\"location\":\"-1120 2588.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":53,\"location\":\"-1650 3318.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":54,\"location\":\"-1120 3288.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":55,\"location\":\"-550 3468.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":56,\"location\":\"110 3258.773\",\"group\":36},\n{\"label\":\"Barrier\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"lValue\"},{\"portId\":\"2in\",\"name\":\"lStatus\"},{\"portId\":\"3in\",\"name\":\"rValue\"},{\"portId\":\"4in\",\"name\":\"rStatus\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nconst inNameList = graphData.dfe.getInputNameList( nodeData );\\nconst inputStat = graphData.dfe.get( nodeData, 'inputStat', {} );\\n\\ninputStat[name] = true;\\nlet isObjectReady = true;\\nfor( const inName of inNameList ) {\\n  if( !inputStat[inName] ) {\\n    isObjectReady = false;\\n    break;\\n  }\\n}\\n\\nif( isObjectReady ) {\\n  graphData.dfe.set( nodeData, 'inputStat', {} );\\n  \\n  const outValue = {};\\n  for( const inName of inNameList ) {\\n    outValue[inName] = graphData.dfe.getInput( nodeData, inName, null );\\n  }\\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"MakeObject\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":58,\"location\":\"210 2978.773\",\"group\":36,\"editorPosition\":[2146,2191,674,512]},\n{\"label\":\"This WorkSpace demonstrate different concepts:\",\"category\":\"TextLabels_Size4\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"1689 92\",\"key\":59,\"location\":\"-1820 1560\"},\n{\"label\":\"1) Creation of a system through its model (Simple Language Interpreter Model)\\n2) Usage of the component model defined in DataFlowDSL+DataFlowEngine\\n3) Execution of a model by using DataFlowEngine\\n4) Code Generation of the model into a JavaScript program that do not depend from the DataFlowEngine\\n5) The execution of the generated code\",\"category\":\"TextLabels_Size3\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"2136 276\",\"key\":61,\"location\":\"-1800 1750\"},\n{\"label\":\"3) The system can be executed by pressing the start buttons\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"501 102\",\"key\":63,\"location\":\"-3920 2670\",\"group\":36},\n{\"label\":\"1) This model defines a simple programming language interpreter\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"556 114\",\"key\":65,\"location\":\"-1390 1970\"},\n{\"label\":\"2) The different components show examples of the component model usage. The code can be seen by clicking on the component's context menu and selecting \\\"Open File\\\"\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"698 145\",\"key\":67,\"location\":\"-1920 2818.773\",\"group\":36},\n{\"label\":\"NOTE: Log components are linked with a log link and are inserted into a group. These 2 choices make sure that such components are not included in the code-generation phase\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"613 145\",\"key\":69,\"location\":\"1010 2248.773\",\"group\":36},\n{\"label\":\"4) By clicking \\\"Generate\\\" the Equation Solver Model is code-generated into the Target Code  component\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"580 145\",\"key\":71,\"location\":\"2270 1970\"},\n{\"label\":\"5) By clicking \\\"Execute\\\" the code-generated system in the Target Code component is executed. Output can be seen in the JavaScript console\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"580 145\",\"key\":73,\"location\":\"2280 2220\"},\n{\"label\":\"NOTE: The DataFlow Engine is used to execute the Equation Solver Model from the model itself\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"374 102\",\"key\":75,\"location\":\"4650 930\"},\n{\"label\":\"This second component create a new instance of the DataFlow Engine once entered in the WorkSpace\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"372 102\",\"key\":77,\"location\":\"4650 1110\"},\n{\"label\":\"This is the DataFlow Engine Control Center. It can be opened by clicking on its context menu and selecting\\n\\\"Open File\\\"\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 117\",\"key\":79,\"location\":\"4650 1270\"},\n{\"label\":\"DFECodeGenerator.js\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":true,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',      // Code generator name and version\\n *          groupKey: null,          // Group node key containing the Model to be generated\\n *          me: null,                // ModelExplorer loaded with the model\\n *          modelId: 'main',         // Model Id\\n *          language: 'javascript',  // Target output language\\n *          lang: dfeCGConfig.lan['javascript'] // Language specific generators\\n *        };\\n *\\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    gen.computeCount = {};                // Store usage of compute functions\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  // Add File Header with basic functions\\n  gen.lang.generateHeader( gen );\\n  \\n  // Generate Basic Node Functions\\n  gen.lang.generateLine( gen );\\n  gen.lang.generateSessionComment( gen, 'Node Functions' );\\n  gen.lang.generateNodeFunctions( gen );\\n\\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n\\n  // (CP) Moved above due to Python not supporting forward declaration\\n  // Functions are needed when instantiating the NodeDatas\\n  // Add function header\\n  gen.lang.generateSessionComment( gen, 'Compute Functions' );\\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n    } else if( ( data.category == 'DataFlow_Component' ) || \\n                ( data.category == 'DataFlow_Message' ) ) {\\n      // Get nodeInfo\\n      const ni = getNodeInfo( gen, data );\\n      if( ni ) {\\n        generateNodeCompute( gen, ni );\\n      }\\n    } else if( ( data.category == 'Hierarchy_CodeInGraph' ) &&\\n                ( data.isIncludeScript ) ) {\\n      // Get nodeInfo\\n      const ni = getNodeInfo( gen, data );\\n      if( ni ) {\\n        generateNodeInclude( gen, ni );\\n      }\\n    }\\n  }\\n  \\n  gen.lang.generateLine( gen );\\n  gen.lang.generateSessionComment( gen, 'Node Functions/Model States' );\\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const ni = getNodeInfo( gen, data );\\n    if( ni ) {\\n      if( ( data.category == 'DataFlow_Component' ) || \\n          ( data.category == 'DataFlow_Message' ) ) {\\n        const computeId = getComputeId( gen, ni );\\n        gen.lang.generateNodeState( gen, ni, computeId );\\n      }\\n    }\\n  }\\n  \\n  // Generate Start Calls\\n  if( gen.startNodeList.length ) {\\n    // Add start header lines\\n    gen.lang.generateSessionComment( gen, 'System Start' );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  if( onGenerated ) {\\n    // Save source in target component\\n    const content = gen.lines.join( '\\\\n' );\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    gen.lang.generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  // Get compute identifier\\n  let computeId = getComputeId( gen, ni );\\n  \\n  // Generate compute only if necessary\\n  if( !isComputeIfGenerated( gen, computeId ) ) {\\n    gen.lang.generateComputeFunction( gen, ni, computeId );\\n  }\\n  \\n  // Add one more usage of compute function\\n  addComputeId( gen, computeId );\\n}\\nfunction generateNodeInclude( gen, ni ) {\\n  if( ni.data.fileContent ) {\\n    gen.lang.generateLineComment( gen, `Node Includes[${ni.data.key}]: ${ni.descr}` );\\n    const lineList = ni.data.fileContent.split( '\\\\n' );\\n    // Add lines\\n    gen.lines = gen.lines.concat( lineList );\\n  }\\n}\\nfunction getComputeId( gen, ni ) {\\n  let result = null;\\n  \\n  if( ni.data.doCompute ) {\\n    result = ni.data.doCompute;\\n  } else if( ni.data.fileTypeName ) {\\n    result = ni.data.fileTypeName;\\n    if( ni.data.fileTypeName == 'Component' ) {\\n      result = `${result}_${ni.key}`;\\n    }\\n  } else {\\n    result = ni.key;\\n  }\\n  result = `compute_${result}`;\\n  \\n  return( result );\\n}\\nfunction isComputeIfGenerated( gen, computeId ) {\\n  return( gen.computeCount[computeId] >= 1 );\\n}\\nfunction addComputeId( gen, computeId ) {\\n  if( !gen.computeCount[computeId] ) {\\n    gen.computeCount[computeId] = 1;\\n  } else {\\n    ++gen.computeCount[computeId];\\n  }\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const label = ( data.label? data.label.replaceAll( '\\\\n', '\\\\\\\\n' ): data.key ); \\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${label}`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = gen.lang.computeList['DataFlow_Message'];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\\n\\nvar module;\\nif( module ) {\\n  module.exports = generationRoot;\\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":62,\"location\":\"3010 2260\",\"editorPosition\":[2311,924,719,1983],\"group\":78},\n{\"label\":\"This is the code generator library.\\nNOTE: it is an include file for this workspace, as well as a file to be deployed on the server\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 58\",\"key\":64,\"location\":\"3440 2230\"},\n{\"label\":\"\",\"category\":\"Pictures_Basic\",\"size\":\"3427 1892\",\"isFile\":true,\"fileTypeName\":\"Image\",\"fileType\":\"image/png\",\"fileURL\":\"/fileServer/pictures/Test DataFlow & Code Generation-2.png\",\"key\":66,\"location\":\"7969 3620\"},\n{\"label\":\"Includes\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"2151 154\",\"key\":60,\"location\":\"3570 580\",\"color\":\"LightGreen\"},\n{\"label\":\"Screenshot\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"3539 154\",\"key\":70,\"location\":\"6380 1380\",\"color\":\"Yellow\"},\n{\"label\":\"  Development WorkSpace\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"6777 154\",\"key\":68,\"location\":\"-3949 930\",\"color\":\"#d2b4de\"},\n{\"label\":\"MainCodeGenerate.js 1.0\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '// System function for reading input',\\n    'function node_getInput( node, name, defaultValue ) {',\\n    '  if( node.in_[name] == undefined ) {',\\n    '    node.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( node.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function node_setInput( node, name, value ) {',\\n    '  node.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function node_get( node, name, defaultValue ) {',\\n    '  if( node.st_[name] == undefined ) {',\\n    '    node.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( node.st_[name] );',\\n    '}',\\n    '' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      generateNodeState( gen, nodeInfo );\\n      generateNodeCompute( gen, nodeInfo );\\n      generateNodeFire( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    gen.lines.push( '' );\\n    gen.lines.push( '/********************' );\\n    gen.lines.push( ' * System Start' );\\n    gen.lines.push( ' ********************/' );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  gen.lines.push( `const node_${ni.key} = {` );\\n  gen.lines.push( `  in_:  {}, // Input` );\\n  gen.lines.push( `  st_:  {}, // Storage` );\\n  gen.lines.push( `  out_: {}, // Output` );\\n  gen.lines.push( `};` );\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\\n  gen.lines.push( `` );\\n  gen.lines.push( `  // Store new input` );\\n  gen.lines.push( `  node_setInput( node_${ni.key}, name, value );` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `fire_${ni.key}(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `node_getInput( node_${ni.key},` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `node_get( node_${ni.key},` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  if( portLen ) {\\n    // Generate fire function\\n    gen.lines.push( `function fire_${ni.key}( name, value ) {` );\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n    gen.lines.push( `}` );\\n  }\\n}\\nfunction generateLinkCall( gen, indent, link, value ) {\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  if( value ) {\\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, '', link );\\n  }\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: ( data.label? data.label: data.key ),\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n    gen.lines.push( `// Node: ${nodeInfo.descr}` );\\n    \\n  } else if( data.category == 'DataFlow_Message' ) {\\n    gen.lines.push( `// Node: Message \\\"${nodeInfo.descr}\\\"` );\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      `  value = \\\"${nodeInfo.label}\\\";`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `fire_${nodeInfo.key}( 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":72,\"location\":\"2410 1130\"},\n{\"label\":\"MainCodeGenerate.js 1.1\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '/********************',\\n    ' * Node Functions',\\n    ' ********************/',\\n    '// System function for reading properties',\\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\\n    '  // NOTE: this function access both nodeData fields and properties',\\n    '  if( nodeData.nd_[name] != undefined ) {',\\n    '    return( nodeData.nd_[name] );',\\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\\n    '    return( nodeData.nd_.props_[name] );',\\n    '  } else {',\\n    '    return( defaultValue );',\\n    '  }',\\n    '}',\\n    '// System function for reading input',\\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.in_[name] == undefined ) {',\\n    '    nodeData.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function nodeData_setInput( nodeData, name, value ) {',\\n    '  nodeData.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function nodeData_get( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.st_[name] == undefined ) {',\\n    '    nodeData.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.st_[name] );',\\n    '}',\\n    '// System function for firing inputs',\\n    'function nodeData_fireInput( nodeData, name, value ) {',\\n    '  nodeData_setInput( nodeData, name, value );',\\n    '  nodeData.doCompute( nodeData, name, value );',\\n    '}',\\n    '',\\n    '/********************',\\n    ' * Model Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\\n      generateNodeFire( gen, nodeInfo );\\n      generateNodeState( gen, nodeInfo );\\n    }\\n  }\\n  \\n  const funcHeader = [\\n    '',\\n    '/********************',\\n    ' * Compute Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( funcHeader );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\\n      generateNodeCompute( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    const sysStart =[\\n      '',\\n      '/********************',\\n      ' * System Start',\\n      ' ********************/' ];\\n    // Add lines\\n    gen.lines = gen.lines.concat( sysStart );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  const nodeDataObj = [\\n    `const nodeData_${ni.key} = {`,\\n    `  in_: {},     // Input`,\\n    `  st_: {},     // Storage`,\\n    `  nd_: { // Properties`,\\n    `    label: '${ni.data.label}',`, // Some fields could be put here\\n    '    props_: {}', // It could be translated here into key,value?\\n    `  },`,\\n    `  out_: {},     // Output`,\\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\\n    `  doCompute: compute_${ni.key},     // Node compute function`,\\n    `};` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObj );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  \\n  // Generate fire function\\n  gen.lines.push( `function fireOutput_${ni.key}( nodeData, name, value ) {` );\\n  // Generate fire body\\n  if( portLen ) {\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, ni, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateLinkCall( gen, ni, indent, link, value ) {\\n  // Check link type\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  \\n  // Get target input port name\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  // Generate input update if node info is defined\\n  if( ni ) {\\n    gen.lines.push( `${indent}// Store new input` );\\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\\n  }\\n  // Generate compute call\\n  if( value ) {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( nodeData, name, value ) {` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `nodeData.fireOutput(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `nodeData_getInput(` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `nodeData_get(` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      //`  value = \\\"${nodeInfo.label}\\\";`,\\n      `  value = nodeData_getProperty( nodeData, 'label', '' );`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `nodeData.fireOutput( nodeData, 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":76,\"location\":\"2410 1300\",\"editorPosition\":[3188,1027,876,1871]},\n{\"label\":\"MainCodeGenerate.js 1.2\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '/********************',\\n    ' * Node Functions',\\n    ' ********************/',\\n    '// System function for reading properties',\\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\\n    '  // NOTE: this function access both nodeData fields and properties',\\n    '  if( nodeData.nd_[name] != undefined ) {',\\n    '    return( nodeData.nd_[name] );',\\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\\n    '    return( nodeData.nd_.props_[name] );',\\n    '  } else {',\\n    '    return( defaultValue );',\\n    '  }',\\n    '}',\\n    '// System function for reading input',\\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.in_[name] == undefined ) {',\\n    '    nodeData.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function nodeData_setInput( nodeData, name, value ) {',\\n    '  nodeData.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function nodeData_get( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.st_[name] == undefined ) {',\\n    '    nodeData.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.st_[name] );',\\n    '}',\\n    '// System function for firing inputs',\\n    'function nodeData_fireInput( nodeData, name, value ) {',\\n    '  nodeData_setInput( nodeData, name, value );',\\n    '  nodeData.doCompute( name, value );',\\n    '}',\\n    '',\\n    '/********************',\\n    ' * Model Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\\n      generateNodeFire( gen, nodeInfo );\\n      generateNodeState( gen, nodeInfo );\\n    }\\n  }\\n  \\n  const funcHeader = [\\n    '',\\n    '/********************',\\n    ' * Compute Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( funcHeader );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\\n      generateNodeCompute( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    const sysStart =[\\n      '',\\n      '/********************',\\n      ' * System Start',\\n      ' ********************/' ];\\n    // Add lines\\n    gen.lines = gen.lines.concat( sysStart );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  const nodeDataObjOpen = [\\n    `const nodeData_${ni.key} = {`,\\n    `  in_: {},     // Input`,\\n    `  st_: {},     // Storage`,\\n    `  nd_: { // Properties`,\\n    `    label: '${ni.data.label}',`, // Some fields could be put here\\n    '    props_: {}', // It could be translated here into key,value?\\n    `  },`,\\n    `  out_: {},     // Output`,\\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\\n    `  doCompute: compute_${ni.key},     // Node compute function`,\\n    `};` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObjOpen );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  \\n  // Generate fire function\\n  gen.lines.push( `function fireOutput_${ni.key}( name, value ) {` );\\n  // Generate fire body\\n  if( portLen ) {\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, ni, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateLinkCall( gen, ni, indent, link, value ) {\\n  // Check link type\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  \\n  // Get target input port name\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  // Generate input update if node info is defined\\n  if( ni ) {\\n    gen.lines.push( `${indent}// Store new input` );\\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\\n  }\\n  // Generate compute call\\n  if( value ) {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `this.fireOutput(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `nodeData_getInput( this,` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `nodeData_get( this,` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      //`  value = \\\"${nodeInfo.label}\\\";`,\\n      `  value = nodeData_getProperty( this, 'label', '' );`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `this.fireOutput( 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":74,\"location\":\"2420 1480\",\"editorPosition\":[3188,1027,876,1871]},\n{\"label\":\"DFEGen/1.3.3\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":78,\"location\":\"2990 2236.75\"},\n{\"label\":\"System Status: [DEPLOYED]\\ndone\\nFilesCount: 4 of 5\\nDirCount: 1 of 1\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"390 120\",\"buttons_\":[{\"name\":\"Deploy\",\"checked\":false},{\"name\":\"Start\",\"checked\":true},{\"name\":\"Stop\",\"checked\":false}],\"props_\":[{\"name\":\"isOverwrite\",\"value\":\"true\",\"valueChanged\":\"true\"},{\"name\":\"scriptPath\",\"value\":\"DFEGen/1.3.3\",\"valueChanged\":\"true\"}],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n  // Uncomment the next line to start debugging\\n  //debugger;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\nlet script = '';\\nlet params = '';\\nconst scriptPath = getProperty( 'scriptPath' );\\n//const g = getMainGraph();\\nlet onLoaded = function(){};\\n\\nswitch( obj.data.name ) {\\n  case 'Deploy':\\n    const modelFileURL = getMainGraphURL();\\n    const deployKey = nodeData.key;\\n    \\n    script = `generateSystemLib.js`;\\n    params = `modelFileURL=${modelFileURL}&deployKey=${deployKey}`;\\n    onLoaded = function( msg ) {\\n      setNodeDataField( nodeData, 'label', 'System Status: [DEPLOYED]\\\\n'+msg );\\n    }\\n    break;\\n  case 'Start':\\n    script = 'serverManager';\\n    params = 'start '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STARTED]' );\\n    break;\\n  case 'Stop':\\n    script = 'serverManager';\\n    params = 'stop '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STOPPED]' );\\n    break;\\n}\\n\\nif( script ) {\\n  const cmd = `${script}${( params? '?'+params: '')}`;\\n  executeScript( cmd, onLoaded );\\n}\\n\\nfunction getProperty( name ) {\\n  let result = '';\\n  if( nodeData.props_ ) {\\n    nodeData.props_.find( (p)=> { if( p.name == name ) { result = p.value; return( true ) } } );\\n  }\\n  return( result );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":80,\"location\":\"5000 1710\",\"editorPosition\":[3132,1920,758,959]},\n{\"label\":\"This is the reference generated target program (generated on the client)\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 58\",\"key\":82,\"location\":\"3430 2050\"},\n{\"label\":\"Dummy Enabled Component\",\"category\":\"CodeFlow_Code\",\"size\":\"180 100\",\"color\":\"orange\",\"props_\":[],\"in_\":[],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":86,\"location\":\"2730 1757.5000000000002\",\"group\":87},\n{\"label\":\"DummyEnable\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":87,\"location\":\"2710 1760.0000000000002\",\"color\":\"green\"},\n{\"label\":\"MainCodeGenerate.js\",\"color\":\"orange\",\"size\":\"404 132\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/**\\n * MainCodeGenerator.js\\n * \\n * Usage for javascript generation (default language):\\n * \\n *  node MainCodeGenerate.js \\\"{\\\\\\\"modelFileURL\\\\\\\":\\\\\\\"./41.json\\\\\\\",\\\\\\\"groupKey\\\\\\\":36}\\\"\\n * \\n * For other lanugage (e.g. Python)\\n *  node MainCodeGenerate.js \\\"{\\\\\\\"modelFileURL\\\\\\\":\\\\\\\"./41.json\\\\\\\",\\\\\\\"groupKey\\\\\\\":36,\\\\\\\"language\\\":\\\"python\\\"}\\\"\\n * \\n */\\n\\nconst fs = require( 'fs' );\\n\\nconsole.log( 'Code Generation started' );\\n\\nconst ModelExplorer = require( './ModelExplorer.js' );\\nconst dfeCGConfig = require( './DFEConfig.js' );\\nconst generationRoot = require( './DFECodeGenerator.js' );\\nconst isServer = true;\\n\\nlet args = '';\\nconsole.log( 'Arguments:' );\\nconsole.log( JSON.stringify( process.argv, null, 2 ) );\\nconsole.log();\\n\\nif( process.argv ) { // Case of execution from the shell\\n  args = process.argv[2];\\n  const output = initGeneration( args );\\n  console.log( output );\\n} else {\\n  console.log( 'Error, no parameters found' );\\n}\\n\\nfunction initGeneration( args ) {\\n  params = null;\\n  try {\\n    params = JSON.parse( args );\\n  } catch( e ) {\\n    console.log( e )\\n    console.log( 'Error in parameters' );\\n    return;\\n  }\\n  const modelFileURL = params.modelFileURL;\\n  const groupKey = params.groupKey;\\n  const language = ( params.language? params.language: 'javascript' );\\n\\n  startGeneration( modelFileURL, groupKey, language );\\n}\\n\\nfunction startGeneration( fileURL, groupKey, language ) {\\n  // Generation Instance Data\\n  const gen = {\\n    name: 'GenDFE 1.3',      // Code generator name and version\\n    groupKey,                // Group node key containing the Model to be generated\\n    me: null,                // ModelExplorer\\n    modelId: 'main',         // Model Id\\n    language: language,      // Target output language\\n    lang: dfeCGConfig.lang[language], // Language specific generators\\n  };\\n\\n  // Get graph source\\n  const graph = getModel( fileURL );\\n  try {\\n    // Get model\\n    const graphObj = JSON.parse( graph );\\n    const model = graphObj.model;\\n\\n    // Model ID for the current graph\\n    gen.modelId = 'main';\\n    // Create a new Model Explorer\\n    gen.me = new ModelExplorer();\\n    // Load current graph model in Model Explorer\\n    gen.me.setJSONModel( gen.modelId, model );\\n  } catch( e ) {}\\n\\n  const onGenerated = function( source, msg ) {\\n    if( msg.startsWith( 'Success:' ) ) {\\n      // Save target component source\\n      let filePathName;\\n      switch (language) {\\n        case 'javascript':\\n          filePathName = './OutCode.js';\\n          break;\\n        case 'python':\\n          filePathName = './OutCode.py';\\n          break;\\n        default:\\n          console.log( 'Warning: target language not specified!' )\\n          filePathName = './OutCode.txt';\\n      }\\n      \\n      saveFileContent( filePathName, source );\\n    }\\n  }\\n\\n  generationRoot( gen, onGenerated );\\n}\\nfunction getModel( fileURL ) {\\n  let model = '{}';\\n\\n  if( isServer ) {\\n    try {\\n      model = fs.readFileSync( fileURL, 'utf8' );\\n    } catch( e ) {}\\n  } else {\\n    // Get current graph model\\n    const g = getMainGraph();\\n    model = g.getJSONModel();\\n  }\\n  return( model );\\n}\\nfunction saveFileContent( filePathName, source ) {\\n  // Compute encoding...\\n  const fileInfo = { sourceEncoding: '' };\\n\\n  if( fileInfo.sourceEncoding == 'base64' ) {\\n    var sourceBuffer = Buffer.from( source, 'base64' );\\n    fs.writeFileSync( filePathName, sourceBuffer );\\n  } else {\\n    fs.writeFileSync( filePathName, source, 'utf8' );\\n  }\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":89,\"location\":\"4060 2060\",\"group\":78},\n{\"label\":\"This is the start file for code generation.\\nIt needs 2 parameters:\\n- modelFileURL: url of the model file\\n- gropuKey: key of the group with the model to be code generated\\n\\nParameters should be specified in a json string, like:\\n\\nnode MainCodeGenerate.js \\\"{\\\\\\\"modelFileURL\\\\\\\":\\\\\\\"./41.json\\\\\\\",\\\\\\\"groupKey\\\\\\\":36}\\\"\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"789 208\",\"key\":91,\"location\":\"4060 2250\",\"group\":78},\n{\"label\":\"51\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":93,\"location\":\"-3700 2738.773\",\"group\":36},\n{\"label\":\"50\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":103,\"location\":\"-2730 2733.029\",\"group\":36},\n{\"label\":\"15\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":113,\"location\":\"-2000 2908.773\",\"group\":36},\n{\"label\":\"18\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":115,\"location\":\"-1450 2918.773\",\"group\":36},\n{\"label\":\"26\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":117,\"location\":\"-890 2748.773\",\"group\":36},\n{\"label\":\"9\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":119,\"location\":\"-900 2998.773\",\"group\":36},\n{\"label\":\"27\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":121,\"location\":\"-350 2758.773\",\"group\":36},\n{\"label\":\"19\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":123,\"location\":\"-350 3018.773\",\"group\":36},\n{\"label\":\"58\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":125,\"location\":\"180 2918.773\",\"group\":36},\n{\"label\":\"25\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":127,\"location\":\"550 2928.773\",\"group\":36},\n{\"label\":\"45\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":129,\"location\":\"970 3008.773\",\"group\":36},\n{\"label\":\"118\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":116,\"location\":\"-3710 2818.773\",\"group\":36},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":118,\"location\":\"-3680 2858.773\",\"group\":36},\n{\"label\":\"122\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":120,\"location\":\"-2740 2822.898\",\"group\":36},\n{\"label\":\"2+3*5-(2+20*0.5)+1=z\\n2+3*5-(2+20*0.5)+1=10-4\\nvalue=3*5+10\\nfactor=2*beta\\n2+3*5-(2+20*0.5)+1=10-1\\nvar=3*5+alpha+factor\\ntest=3*sin( 2 )+4\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 452\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":122,\"location\":\"-2700 3045.398\",\"group\":36},\n{\"label\":\"alpha = 10\\nbeta = 4\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 458\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":88,\"location\":\"-2690 2428.773\",\"group\":36},\n{\"label\":\"Variable Update\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n  let outValue = updateVariableValue( variables, value.id, value.value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":92,\"location\":\"1000 3188.773\",\"group\":36,\"editorPosition\":[-1121,2267,621,162]},\n{\"label\":\"Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"344 44\",\"key\":95,\"location\":\"-2680 2178.773\",\"group\":36},\n{\"label\":\"92\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":97,\"location\":\"970 3138.773\",\"group\":36},\n{\"label\":\"34\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":99,\"location\":\"980 2908.773\",\"group\":36},\n{\"label\":\"Helper Functions\",\"color\":\"orange\",\"size\":\"400 180\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"function getVariableValues( variables ) {\\n  const result = {};\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    result[match[1]] = match[2];\\n  }\\n  return( result );\\n}\\nfunction updateVariableValue( variables, id, value ) {\\n  const result = [];\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n  let isVarUpdated = false;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    if( match[1] == id ) {\\n      isVarUpdated = true;\\n      result.push( `${match[1]} = ${value}` );\\n    } else {\\n     result.push( `${match[1]} = ${match[2]}` );\\n    }\\n  }\\n  if( !isVarUpdated ) {\\n    result.push( `${id} = ${value}` );\\n  }\\n  return( result.join( '\\\\n' ) );\\n}\\nfunction isVariable( str ) {\\n  return( RegExp( /^[a-z]/i ).test( str ) );\\n}\\nfunction buildAST( tokenList ) {\\n  if( tokenList.length == 0 ) {\\n    return( null );\\n  } else if( tokenList.length == 1 ) {\\n    return( tokenList[0] );\\n  }\\n\\n  // Find the index of the lowest precedence operator\\n  let index = -1;\\n  let minPrecedence = Infinity;\\n  let parenthesis = 0;\\n  // Loop over all tokenList\\n  for( let i = 0; i < tokenList.length; ++i ) {\\n    if( tokenList[i] == '(' ) {\\n      parenthesis++;\\n    } else if( tokenList[i] == ')' ) {\\n      parenthesis--;\\n    } else if( parenthesis === 0 ) {\\n      // Compute precedences\\n      const operator = tokenList[i];\\n      let precedence = 0;\\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\\n        precedence = 1;\\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n        precedence = 2;\\n      } else {\\n        precedence = Infinity;\\n      }\\n      \\n      if( precedence <= minPrecedence ) {\\n        minPrecedence = precedence;\\n        index = i;\\n      }\\n    }\\n  }\\n\\n  // Handle subexpressions inside parentheses\\n  if( index === -1 ) {\\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\\n  }\\n\\n  const result = [\\n    tokenList[index],\\n    buildAST( tokenList.slice( 0, index ) ),\\n    buildAST( tokenList.slice( index+1 ))\\n  ];\\n  return( result );\\n}\\nfunction evaluateAST( ast, variables ) {\\n  \\n  if( RegExp( /^[a-z_]/i ).test( ast ) ) {\\n    const varValue = variables[ast];\\n    if( varValue != undefined ) {\\n      return( parseFloat( varValue ) );\\n    } else {\\n      return( ast );\\n    }\\n  } else if( typeof( ast ) === 'number' ) {\\n    // Base case: if the node is a number, return it.\\n    return( ast );\\n  }\\n\\n  // Recursive case: evaluate the left and right operands.\\n  const left = evaluateAST( ast[1], variables );\\n  const right = evaluateAST( ast[2], variables );\\n\\n  // Compute the result based on the operator.\\n  switch( ast[0] ) {\\n    case '+':\\n      return( left + right );\\n    case '-':\\n      return( left - right );\\n    case '*':\\n      return( left * right );\\n    case '/':\\n      return( left / right );\\n    default:\\n      throw new Error( 'Unknown operator: ' + ast[0] );\\n  }\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":94,\"location\":\"-3770 2228.773\",\"group\":36,\"isIncludeScript\":true,\"editorPosition\":[-10557,1652,527,1094]},\n{\"label\":\"alpha = 10\\nbeta = 4\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"267 143\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":96,\"location\":\"-3250 2430\",\"group\":36},\n{\"label\":\"Initial Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"269 44\",\"key\":100,\"location\":\"-3240 2330\",\"group\":36},\n{\"label\":\"96\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":101,\"location\":\"-3290 2350\",\"group\":36},\n{\"label\":\"94\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":104,\"location\":\"-3800 2130\",\"group\":36},\n{\"label\":\"88\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":106,\"location\":\"-2730 2200\",\"group\":36},\n{\"label\":\"DFEConfig.js\",\"color\":\"orange\",\"size\":\"403 141\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/**\\n * This is the configuration file for the DFECodeGenerator\\n * \\n * This file defines configuration for language support\\n */\\n \\nconst dfeCGConfig = {\\n  lang: {\\n    /*\\n    *\\n    * Javascript\\n    * \\n    */\\n    'javascript': {\\n      generateLine: function( gen, text ) {\\n        text = text || '';\\n        gen.lines.push( text );\\n      },\\n      generateLineComment: function( gen, text ) {\\n        gen.lines.push( `// ${text}` );\\n      },\\n      generateMultiLineComment: function( gen, text ) {\\n        const comment = [\\n          '/*',\\n          ` * ${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          ' */' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateSessionComment: function( gen, text ) {\\n        const comment = [\\n          '',\\n          '/*****************************************',\\n          ` * ${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          ' *****************************************/' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateHeader: function( gen ) {\\n        const header = `This file is code generated by ${gen.name}\\\\n`+\\n                       `\\\\n`+\\n                       `Generated on ${gen.date}\\\\n`;\\n        this.generateMultiLineComment( gen, header );\\n      },\\n      generateNodeFunctions: function( gen ) {\\n        const nodeFunctions = [\\n          '// System function for reading properties',\\n          'function DFE_getProperty( name, defaultValue ) {',\\n          '  // NOTE: this function access both nodeData fields and properties',\\n          '  if( this.nd_[name] != undefined ) {',\\n          '    return( this.nd_[name] );',\\n          '  } else if( this.nd_.props_[name] != undefined ) {',\\n          '    return( this.nd_.props_[name] );',\\n          '  } else {',\\n          '    return( defaultValue );',\\n          '  }',\\n          '}',\\n          '// System function for property data access',\\n          'function DFE_getPropertyList() {',\\n          '  return( this.nd_.props_ );',\\n          '}',\\n          '// System function for reading input',\\n          'function DFE_getInput( name, defaultValue ) {',\\n          '  if( this.in_[name] == undefined ) {',\\n          '    this.in_[name] = defaultValue;',\\n          '  }',\\n          '  return( this.in_[name] );',\\n          '}',\\n          '// System function for storing input',\\n          'function DFE_setInput( name, value ) {',\\n          '  this.in_[name] = value;',\\n          '}',\\n          '// System function for getting input name list',\\n          'function DFE_getInputNameList() {',\\n          '  return( this.nd_.in_ );',\\n          '}',\\n          '// System function for getting output name list',\\n          'function DFE_getOutputNameList() {',\\n          '  return( this.nd_.out_ );',\\n          '}',\\n          '// System function for instance data access',\\n          'function DFE_get( name, defaultValue ) {',\\n          '  if( this.st_[name] == undefined ) {',\\n          '    this.st_[name] = defaultValue;',\\n          '  }',\\n          '  return( this.st_[name] );',\\n          '}',\\n          '// System function for instance data storage',\\n          'function DFE_set( name, value ) {',\\n          '  this.st_[name] = value;',\\n          '}',\\n          '// System function for firing inputs',\\n          'function DFE_fireInput( name, value ) {',\\n          '  this.setInput( name, value );',\\n          '  this.doCompute( name, value );',\\n          '}',];\\n        gen.lines = gen.lines.concat( nodeFunctions );\\n      },\\n      generateNodeState: function ( gen, ni, computeId ) {\\n        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );\\n        // Node data instance variable\\n        gen.lines.push( `const nodeData_${ni.key} = {` );\\n        // Node data fields\\n        this.generateNodeDataFields( gen, ni );\\n        // Node methods\\n        this.generateNodeFire( gen, ni );\\n        const nodeDataObjClose = [\\n          `  getProperty: DFE_getProperty,`,\\n          `  getPropertyList: DFE_getPropertyList,`,\\n          `  getInput: DFE_getInput,`,\\n          `  setInput: DFE_setInput,`,\\n          `  getInputNameList: DFE_getInputNameList,`,\\n          `  getOutputNameList: DFE_getOutputNameList,`,\\n          `  get: DFE_get,`,\\n          `  set: DFE_set,`,\\n          `  fireInput: DFE_fireInput,`,\\n          `  doCompute: ${computeId},`,\\n          `};` ];\\n        // Add lines\\n        gen.lines = gen.lines.concat( nodeDataObjClose );\\n      },\\n      generateNodeDataFields: function( gen, ni ) {\\n        if( ni.data.in_ && ni.data.in_.length ) {\\n          gen.lines.push( `  in_: {},       // Input values` );\\n        }\\n        if( ni.data.out_ && ni.data.out_.length ) {\\n          gen.lines.push( `  out_: {},      // Output values` );\\n        }\\n        gen.lines.push( `  nd_: {         // Full node fields/properties` );\\n        for( const field of [ 'label', 'color' ] ) {\\n          let value = ni.data[field];\\n          if( value != undefined ) {\\n            value = value.replaceAll( '\\\\n', '\\\\\\\\n' );\\n            gen.lines.push( `    ${field}: '${value}',` );\\n          }\\n        }\\n        gen.lines.push( `    in_: [       // Storage values ` );\\n        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );\\n        for( const name of inPortNameList ) {\\n          gen.lines.push( `      '${name}',` );\\n        }\\n        gen.lines.push( `    ],` );\\n        gen.lines.push( `    out_: [      // Storage values ` );\\n        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );\\n        for( const name of outPortNameList ) {\\n          gen.lines.push( `      '${name}',` );\\n        }\\n        gen.lines.push( `    ],` );\\n        gen.lines.push( `    props_: {    // Storage values ` );\\n        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );\\n        for( const name in propList ) {\\n          gen.lines.push( `      '${name}': '${propList[name]}',` );\\n        }\\n        gen.lines.push( `    },` );\\n        gen.lines.push( `  },` );\\n        gen.lines.push( `  st_: {},       // Storage values ` );\\n      },\\n      generateNodeFire: function( gen, ni ) {\\n        // Get out port list\\n        const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n        const portLen = outPortList.length\\n        \\n        // Generate fire function\\n        gen.lines.push( `  fireOutput: function ( name, value ) {` );\\n        // Generate fire body\\n        if( portLen ) {\\n          gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );\\n          // Loop on each output port\\n          for( let i = 0; i < portLen; ++i ) {\\n            const portName = outPortList[i];\\n            if( i > 0 ) {\\n              gen.lines.push( `    } else if( name == '${portName}' ) {` );\\n            }\\n            \\n            // Get output links\\n            const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n            for( const link of linkList ) {\\n              this.generateLinkCall( gen, ni, '      ', link, 'value' );\\n            }\\n          }\\n          gen.lines.push( `    }` );\\n        }\\n        gen.lines.push( `  },` );\\n      },\\n      generateLinkCall: function( gen, ni, indent, link, value ) {\\n        // Check link type\\n        if( link.category == 'DataFlow_Log' ) {\\n            return;\\n        } else if( link.category == 'DataFlow_Pause') {\\n          gen.lines.push( `${indent}debugger` );\\n        }\\n        \\n        // Get target input port name\\n        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n        // Generate input update if node info is defined\\n        if( ni ) {\\n          gen.lines.push( `${indent}// Store new input` );\\n          gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );\\n        }\\n        // Generate compute call\\n        if( value ) {\\n          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\\n        } else {\\n          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\\n        }\\n      },\\n      regExp: {\\n       // Match line: var nodeData, name, value;\\n       declLine: RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ ),\\n       // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n       fireLine: RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n       getInLine: RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );\\n       setInLine: RegExp( /graphData.dfe.setInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );\\n       getInNLLine: RegExp( /graphData.dfe.getInputNameList\\\\(\\\\s*nodeData/ ),\\n       // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );\\n       getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\\\\(\\\\s*nodeData/ ),\\n       // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n       getLine: RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );\\n       setLine: RegExp( /graphData.dfe.set\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const p = graphData.dfe.getPropertyList( nodeData );\\n       getPropListLine: RegExp( /graphData.dfe.getPropertyList\\\\(\\\\s*nodeData\\\\s*/ ),\\n       //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n       //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n      },\\n      generateComputeFunction: function( gen, ni, computeId ) {\\n        let isMainDeclSkipped = false;\\n        // Generate compute function\\n        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );\\n        gen.lines.push( `function ${computeId}( name, value ) {` );\\n        for( let line of ni.src ) {\\n          if( !isMainDeclSkipped ) {\\n            if( this.regExp.declLine.test( line ) ) {\\n              isMainDeclSkipped = true;\\n            }\\n          } else {\\n            if( this.regExp.fireLine.test( line ) ) {\\n              line = line.replace( this.regExp.fireLine, `this.fireOutput(` );\\n            } else if( this.regExp.getInLine.test( line ) ) {\\n              line = line.replace( this.regExp.getInLine, `this.getInput(` );\\n            } else if( this.regExp.setInLine.test( line ) ) {\\n              line = line.replace( this.regExp.setInLine, `this.setInput(` );\\n            } else if( this.regExp.getInNLLine.test( line ) ) {\\n              line = line.replace( this.regExp.getInNLLine, `this.getInputNameList(` );\\n            } else if( this.regExp.getOutNLLine.test( line ) ) {\\n              line = line.replace( this.regExp.getOutNLLine, `this.getOutputNameList(` );\\n            } else if( this.regExp.getLine.test( line ) ) {\\n              line = line.replace( this.regExp.getLine, `this.get(` );\\n            } else if( this.regExp.setLine.test( line ) ) {\\n              line = line.replace( this.regExp.setLine, `this.set(` );\\n            } else if( this.regExp.getPropListLine.test( line ) ) {\\n              line = line.replace( this.regExp.getPropListLine, `this.getPropertyList(` );\\n            }\\n            gen.lines.push( `  ${line}` );\\n          }\\n        }\\n        gen.lines.push( `}` );\\n      },\\n      computeList: {\\n        'DataFlow_Message': [\\n          `var nodeData, name, value;`,\\n          ``,\\n          `if( value == undefined ) {`,\\n          `  value = this.getProperty( 'label', '' );`,\\n          `  try {`,\\n          `    value = JSON.parse( value ); `,\\n          `  } catch( e ) {}`,\\n          `}`,\\n          `this.fireOutput( 'out', value );` \\n        ],\\n      }\\n    },\\n    /*\\n    *\\n    * Python\\n    * \\n    */\\n    'python': {\\n      generateLine: function( gen, text ) {\\n        text = text || '';\\n        gen.lines.push( text );\\n      },\\n      generateLineComment: function( gen, text ) {\\n        gen.lines.push( `# ${text}` );\\n      },\\n      generateMultiLineComment: function( gen, text ) {\\n        const comment = [\\n          '\\\\'\\\\'\\\\'',\\n          `${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          '\\\\'\\\\'\\\\'' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateSessionComment: function( gen, text ) {\\n        const comment = [\\n          '\\\\'\\\\'\\\\'',\\n          '****************************************',\\n          `* ${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          '****************************************',\\n          '\\\\'\\\\'\\\\'' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateHeader: function( gen ) {\\n        const header = `This file is code generated by ${gen.name}\\\\n`+\\n                      `\\\\n`+\\n                      `Generated on ${gen.date}\\\\n`;\\n        this.generateMultiLineComment( gen, header );\\n      },\\n      generateNodeFunctions : function ( gen ) {\\n        const nodeFunctions = [\\n          'import json',\\n          'import re',\\n          'from dataclasses import dataclass',\\n          'from typing import Callable, Dict, List',\\n          '',\\n          '@dataclass',\\n          'class NodeData:',\\n          '    #********************',\\n          '    # Node System Dependant Functions',\\n          '    #********************',\\n          '    # System function for reading properties',\\n          '    def DFE_get_property(self, name, default_value):',\\n          '        # NOTE: this function accesses both nodeData fields and properties',\\n          '        if name in self.nd_:',\\n          '            return self.nd_[name]',\\n          '        elif name in self.nd_[\\\\'props_\\\\']:',\\n          '            return self.nd_[\\\\'props_\\\\'][name]',\\n          '        else:',\\n          '            return default_value',\\n          '        ',\\n          '    # System function for property data access',\\n          '    def DFE_get_property_list(self):',\\n          '        return self.nd_[\\\\'props_\\\\']',\\n          '',\\n          '    # System function for reading input',\\n          '    def DFE_get_input(self, name, default_value):',\\n          '        if name not in self.in_:',\\n          '            self.in_[name] = default_value',\\n          '        return self.in_[name]',\\n          '',\\n          '    # System function for storing access',\\n          '    def DFE_set_input(self, name, value):',\\n          '        self.in_[name] = value',\\n          '',\\n          '    # System function for getting input name list',\\n          '    def DFE_get_input_name_list(self):',\\n          '        return self.nd_[\\\\'in_\\\\']',\\n          '    ',\\n          '    # System function for getting output name list',\\n          '    def DFE_get_output_name_list(self):',\\n          '        return self.nd_[\\\\'out_\\\\']',\\n          '',\\n          '    # System function for instance data access',\\n          '    def DFE_get(self, name, default_value):',\\n          '        if name not in self.st_:',\\n          '            self.st_[name] = default_value',\\n          '        return self.st_[name]',\\n          '    ',\\n          '    # System function for instance data storage',\\n          '    def DFE_set(self, name, value):',\\n          '        self.st_[\\\\'name\\\\'] = value',\\n          '',\\n          '    # System function for firing inputs',\\n          '    def DFE_fire_input(self, name, value):',\\n          '        self.set_input(name, value)',\\n          '        self.do_compute(name, value)',\\n          '',\\n          '    #********************',\\n          '    # Node Fields',\\n          '    #********************',\\n          '    in_: Dict ',\\n          '    out_: Dict',\\n          '    nd_ : Dict',\\n          '    st_ : Dict',\\n          '    fire_output: Callable',\\n          '    get_property = DFE_get_property',\\n          '    get_input = DFE_get_input',\\n          '    set_input = DFE_set_input',\\n          '    get_input_name_list= DFE_get_input_name_list',\\n          '    get_output_name_list = DFE_get_output_name_list',\\n          '    get = DFE_get',\\n          '    set = DFE_set',\\n          '    fire_input = DFE_fire_input',\\n          '    get = DFE_get_property',\\n          '    do_compute: Callable'\\n        ]\\n        gen.lines = gen.lines.concat( nodeFunctions );\\n      },\\n      generateNodeState: function ( gen, ni, computeId ) {\\n        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );\\n        // Node data instance variable\\n        gen.lines.push( `nodeData_${ni.key} = NodeData(` );\\n        // Node data fields\\n        this.generateNodeDataFields( gen, ni );\\n        // Node methods\\n        this.generateNodeFire( gen, ni );\\n        const nodeDataObjClose = [\\n          // (CP) TODO - decide if necessary here\\n          // `    getProperty = DFE_get_property,`,\\n          // `    getPropertyList =  DFE_get_property_list,`,\\n          // `    getInput: DFE_get_input,`,\\n          // `    setInput: DFE_set_input,`,\\n          // `    getInputNameList: DFE_get_input_name_list,`,\\n          // `    getOutputNameList: DFE_get_output_name_list,`,\\n          // `    get: DFE_get,`,\\n          // `    set: DFE_set,`,\\n          // `    fireInput: DFE_fire_input,`,\\n          `    do_compute= ${computeId},`,\\n          `)` ];\\n        // Add lines\\n        gen.lines = gen.lines.concat( nodeDataObjClose );\\n      },\\n      generateNodeDataFields: function( gen, ni ) {\\n        if( ni.data.in_ && ni.data.in_.length ) {\\n          gen.lines.push( `    in_= {},       # Input values` );\\n        }\\n        if( ni.data.out_ && ni.data.out_.length ) {\\n          gen.lines.push( `    out_= {},      # Output values` );\\n        }\\n        gen.lines.push( `    nd_= {         # Full node fields/properties` );\\n        for( const field of [ 'label', 'color' ] ) {\\n          let value = ni.data[field];\\n          if( value != undefined ) {\\n            value = value.replaceAll( '\\\\n', '\\\\\\\\n' );\\n            gen.lines.push( `        '${field}': '${value}',` );\\n          }\\n        }\\n        gen.lines.push( `        'in_': [       # Storage values ` );\\n        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );\\n        for( const name of inPortNameList ) {\\n          gen.lines.push( `            '${name}',` );\\n        }\\n        gen.lines.push( `        ],` );\\n        gen.lines.push( `        'out_': [      # Storage values ` );\\n        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );\\n        for( const name of outPortNameList ) {\\n          gen.lines.push( `            '${name}',` );\\n        }\\n        gen.lines.push( `        ],` );\\n        gen.lines.push( `        'props_': {    # Storage values ` );\\n        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );\\n        for( const name in propList ) {\\n          gen.lines.push( `            '${name}': '${propList[name]}',` );\\n        }\\n        gen.lines.push( `        },` );\\n        gen.lines.push( `    },` );\\n        gen.lines.push( `    st_= {},       # Storage values ` );\\n      }, \\n      generateNodeFire: function(gen, ni) {\\n        // Get out port list\\n        const outPortList = gen.me.getOutPortNameList('main', ni.key);\\n        const portLen = outPortList.length;\\n    \\n        // Generate fire function\\n        gen.lines.push(`    fire_output = lambda name, value: (`);\\n    \\n        // Generate fire body\\n        if (portLen) {\\n          for (let i = 0; i < portLen; ++i) {\\n            const portName = outPortList[i];\\n            // Get output links\\n            const linkList = gen.me.getLinkListFanOutByNodeKey(gen.modelId, ni.key, portName);\\n            for (const link of linkList) {\\n              this.generateLinkCall(gen, ni, '        ', link, 'value', `name == '${portName}'`);\\n            }\\n          }\\n          gen.lines.push(`        None`);\\n        }\\n        gen.lines.push(`    ),`);\\n      },\\n      generateLinkCall: function( gen, ni, indent, link, value, lambdaCondition=undefined ) {\\n        // Check link type\\n        if( link.category == 'DataFlow_Log' ) {\\n            return;\\n        } else if( link.category == 'DataFlow_Pause') {\\n          gen.lines.push( `${indent}debugger` );\\n        }\\n        \\n        // Get target input port name\\n        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n\\n        if ( ni ) {\\n          if ( value ) {\\n            gen.lines = gen.lines.concat( `${indent}( `);\\n          }\\n          gen.lines.push( `${indent}# Store new input` );\\n          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.set_input( '${toPortName}', value ), ` );\\n        } \\n        if( value ) {\\n          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.do_compute( '${toPortName}', ${value} )` );\\n        } else {\\n          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.do_compute( '${toPortName}', None )` );\\n        }\\n\\n        // Trailing lambda `if ${lambdaCondition} else`\\n        let lIfElse = '';\\n        if ( lambdaCondition != undefined ) {\\n          lIfElse = `if ${lambdaCondition} else`\\n          if ( ni ) {\\n            gen.lines.push( `${indent}) ${lIfElse}` );\\n          } else {\\n            // No closing bracket\\n            gen.lines.push( `${indent} ${lIfElse}` );\\n          }\\n        }\\n      },\\n      regExp: {\\n        // Match line: args = [self, name, value]\\n        declLine: RegExp( /args\\\\s*=\\\\s*\\\\[.*self.*\\\\]/ ),\\n        // // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n        // fireLine: RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n        // // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n        // getInLine: RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n        // // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );\\n        // setInLine: RegExp( /graphData.dfe.setInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n        // // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );\\n        // getInNLLine: RegExp( /graphData.dfe.getInputNameList\\\\(\\\\s*nodeData/ ),\\n        // // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );\\n        // getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\\\\(\\\\s*nodeData/ ),\\n        // // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n        // getLine: RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ ),\\n        // // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );\\n        // setLine: RegExp( /graphData.dfe.set\\\\(\\\\s*nodeData\\\\s*,/ ),\\n        // // Match line: const p = graphData.dfe.getPropertyList( nodeData );\\n        // getPropListLine: RegExp( /graphData.dfe.getPropertyList\\\\(\\\\s*nodeData\\\\s*/ ),\\n        // //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n        // //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n      },\\n      generateComputeFunction: function( gen, ni, computeId ) {\\n        let isMainDeclSkipped = false;\\n        let firstLineMainDecl = false;\\n        // Generate compute function\\n        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );\\n        gen.lines.push( `def ${computeId}( self : NodeData, name, value ):` );\\n        for( let line of ni.src ) {\\n          if( !isMainDeclSkipped ) {\\n            if( this.regExp.declLine.test( line ) ) {\\n              isMainDeclSkipped = true;\\n            }\\n          } else {\\n          //   if( this.regExp.fireLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.fireLine, `self.fire_output(` );\\n          //   } else if( this.regExp.getInLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.getInLine, `self.get_input(` );\\n          //   } else if( this.regExp.setInLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.setInLine, `self.set_input(` );\\n          //   } else if( this.regExp.getInNLLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.getInNLLine, `self.get_input_name_list(` );\\n          //   } else if( this.regExp.getOutNLLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.getOutNLLine, `self.get_output_name_list(` );\\n          //   } else if( this.regExp.getLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.getLine, `self.get(` );\\n          //   } else if( this.regExp.setLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.setLine, `self.set(` );\\n          //   } else if( this.regExp.getPropListLine.test( line ) ) {\\n          //     line = line.replace( this.regExp.getPropListLine, `self.get_property_list(` );\\n          //   }\\n            gen.lines.push( `  ${line}` );\\n          }\\n        }\\n      },\\n      computeList: { // (CP) This needs a second thought...used same JS approach\\n        'DataFlow_Message': [\\n            `args = [self, name, value]`,\\n            `if value is None:`,\\n            `    value = self.get_property('label', '')`,\\n            `try:`,\\n            `    value = json.loads(value)`,\\n            `except Exception as e:  # Use 'Exception' to catch all exceptions`,\\n            `    pass`,\\n            `self.fire_output('out', value)`\\n        ],\\n      }\\n    }\\n  },\\n};\\n\\nvar module;\\nif( module ) {\\n  module.exports = dfeCGConfig;\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":102,\"location\":\"3010 2410\",\"group\":78,\"isIncludeScript\":true,\"editorPosition\":[3062,927,866,2010]},\n{\"label\":\"Engine Control\",\"color\":\"lightsalmon\",\"size\":\"416 110\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"<div style=\\\"display:grid\\\">\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.loadModel();\\\" style=\\\"font-size: 24px;\\\">Load Model</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.clearInstanceData();\\\" style=\\\"font-size: 24px;\\\">Clear Instance Data</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.doPause();\\\" style=\\\"font-size: 24px;\\\">Pause</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.doContinue();\\\" style=\\\"font-size: 24px;\\\">Continue</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setState( 'isLogOn', true );\\\" style=\\\"font-size: 24px;\\\">Set Log On</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setState( 'isLogOn', false );\\\" style=\\\"font-size: 24px;\\\">Set Log Off</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setState( 'isTraceLogOn', true );\\\" style=\\\"font-size: 24px;\\\">Set Trace Log On</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setState( 'isTraceLogOn', false );\\\" style=\\\"font-size: 24px;\\\">Set Trace Log Off</button>\\n</div>\",\"fileTypeName\":\"Web Page\",\"fileType\":\"application/html\",\"key\":98,\"location\":\"4170 1270\",\"isLocalDiv\":true,\"editorPosition\":[3771,1041,400,350]},\n{\"label\":\"Log on 27.01.2024 01.49pm\",\"category\":\"DataFlow_Data\",\"size\":\"363 80\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\",\"tooltip\":\"this input expects a string\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\",\"tooltip\":\"this output is a string\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"[\\n  { \\\"key\\\": 7 },  // 2+3*5-(2+20*0.5)+1=z\\n  { \\\"key\\\": 15 },  // Equation Tokenizer\\n  { \\\"key\\\": 18 },  // Equation Split\\n  { \\\"key\\\": 33 },  // [   \\\"y\\\" ]\\n  { \\\"key\\\": 26 },  // Equation Parser\\n  { \\\"key\\\": 27 },  // Equation Compute\\n  { \\\"key\\\": 28 },  // y\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 29 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 31 },  // y\\n  { \\\"key\\\": 35 },  // [   3,   \\\"*\\\",   5,   \\\"+\\\",   10...\\n  { \\\"key\\\": 9 },  // Equation Parser\\n  { \\\"key\\\": 11 },  // [   \\\"+\\\",   [     \\\"*\\\",     3,  ...\\n  { \\\"key\\\": 19 },  // Equation Compute\\n  { \\\"key\\\": 21 },  // 25\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 23 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 25 },  // Equation Compare\\n  { \\\"key\\\": 34 },  // y = 25\\n  { \\\"key\\\": 45 },  // Log Result\\n  { \\\"key\\\": 17 }  // [   \\\"y\\\",   \\\"=\\\",   3,   \\\"*\\\",   ...\\n]\",\"fileTypeName\":\"Text\",\"fileType\":\"text/text\",\"iconURL\":\"/fileServer/pictures/Text_Data.png\",\"doCompute\":\"DataFlow_Data\",\"key\":105,\"location\":\"3820 3280\"},\n{\"label\":\"Log on 27.01.2024 01.45pm\",\"category\":\"DataFlow_Data\",\"size\":\"363 80\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\",\"tooltip\":\"this input expects a string\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\",\"tooltip\":\"this output is a string\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"[\\n  { \\\"key\\\": 46 },  // y=3*5+10\\n  { \\\"key\\\": 15 },  // Equation Tokenizer\\n  { \\\"key\\\": 18 },  // Equation Split\\n  { \\\"key\\\": 33 },  // [   \\\"y\\\" ]\\n  { \\\"key\\\": 26 },  // Equation Parser\\n  { \\\"key\\\": 27 },  // Equation Compute\\n  { \\\"key\\\": 28 },  // y\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 29 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 31 },  // y\\n  { \\\"key\\\": 35 },  // [   3,   \\\"*\\\",   5,   \\\"+\\\",   10...\\n  { \\\"key\\\": 9 },  // Equation Parser\\n  { \\\"key\\\": 11 },  // [   \\\"+\\\",   [     \\\"*\\\",     3,  ...\\n  { \\\"key\\\": 19 },  // Equation Compute\\n  { \\\"key\\\": 21 },  // 25\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 23 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 25 },  // Equation Compare\\n  { \\\"key\\\": 34 },  // y = 25\\n  { \\\"key\\\": 45 },  // Log Result\\n  { \\\"key\\\": 17 }  // [   \\\"y\\\",   \\\"=\\\",   3,   \\\"*\\\",   ...\\n]\",\"fileTypeName\":\"Text\",\"fileType\":\"text/text\",\"iconURL\":\"/fileServer/pictures/Text_Data.png\",\"doCompute\":\"DataFlow_Data\",\"key\":107,\"location\":\"3820 3180\"},\n{\"label\":\"Log on 27.01.2024 01.08pm\",\"category\":\"DataFlow_Data\",\"size\":\"363 80\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\",\"tooltip\":\"this input expects a string\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\",\"tooltip\":\"this output is a string\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"[\\n  { \\\"key\\\": 50 },  // 2+3*5-(2+20*0.5)+1\\n  { \\\"key\\\": 15 },  // Equation Tokenizer\\n  { \\\"key\\\": 18 },  // Equation Split\\n  { \\\"key\\\": 33 },  // [   2,   \\\"+\\\",   3,   \\\"*\\\",   5,...\\n  { \\\"key\\\": 26 },  // Equation Parser\\n  { \\\"key\\\": 27 },  // Equation Compute\\n  { \\\"key\\\": 28 },  // 6\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 29 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 31 },  // [   \\\"+\\\",   [     \\\"-\\\",     [   ...\\n  { \\\"key\\\": 35 },  // []\\n  { \\\"key\\\": 9 },  // Equation Parser\\n  { \\\"key\\\": 11 },  // [   \\\"+\\\",   [     \\\"*\\\",     3,  ...\\n  { \\\"key\\\": 19 },  // Equation Compute\\n  { \\\"key\\\": 21 },  // DataFlow_Message\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 23 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 25 },  // Equation Compare\\n  { \\\"key\\\": 34 },  // 6\\n  { \\\"key\\\": 45 },  // Log Result\\n  { \\\"key\\\": 17 }  // [   2,   \\\"+\\\",   3,   \\\"*\\\",   5,...\\n]\",\"fileTypeName\":\"Text\",\"fileType\":\"text/text\",\"iconURL\":\"/fileServer/pictures/Text_Data.png\",\"doCompute\":\"DataFlow_Data\",\"key\":108,\"location\":\"3820 3080\"},\n{\"label\":\"Log on 27.01.2024 02.07pm\",\"category\":\"DataFlow_Data\",\"size\":\"363 80\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\",\"tooltip\":\"this input expects a string\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\",\"tooltip\":\"this output is a string\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"[\\n  { \\\"key\\\": 42 },  // 2+3*5-(2+20*0.5)+1=10-1\\n  { \\\"key\\\": 15 },  // Equation Tokenizer\\n  { \\\"key\\\": 18 },  // Equation Split\\n  { \\\"key\\\": 33 },  // [   2,   \\\"+\\\",   3,   \\\"*\\\",   5,...\\n  { \\\"key\\\": 26 },  // Equation Parser\\n  { \\\"key\\\": 27 },  // Equation Compute\\n  { \\\"key\\\": 28 },  // 6\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 29 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 31 },  // [   \\\"+\\\",   [     \\\"-\\\",     [   ...\\n  { \\\"key\\\": 35 },  // [   10,   \\\"-\\\",   4 ]\\n  { \\\"key\\\": 9 },  // Equation Parser\\n  { \\\"key\\\": 11 },  // [   \\\"-\\\",   10,   4 ]\\n  { \\\"key\\\": 19 },  // Equation Compute\\n  { \\\"key\\\": 21 },  // 6\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 23 },  // Done\\n  { \\\"key\\\": 58 },  // Barrier\\n  { \\\"key\\\": 25 },  // Equation Compare\\n  { \\\"key\\\": 34 },  // true\\n  { \\\"key\\\": 45 },  // Log Result\\n  { \\\"key\\\": 17 }  // [   2,   \\\"+\\\",   3,   \\\"*\\\",   5,...\\n]\",\"fileTypeName\":\"Text\",\"fileType\":\"text/text\",\"iconURL\":\"/fileServer/pictures/Text_Data.png\",\"doCompute\":\"DataFlow_Data\",\"key\":109,\"location\":\"3290 3080\"},\n{\"label\":\"Get Trace Log\",\"category\":\"DataFlow_TrigComponent\",\"size\":\"299 80\",\"buttons_\":[{\"name\":\"Update\",\"checked\":true}],\"in_\":[],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"var nodeData;\\n\\ngraphData.dfe.loadModel();\\nconst outValue = graphData.dfe.getTraceLog( true );\\ngraphData.dfe.fireOutput( nodeData, 'out', outValue );\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":110,\"location\":\"2860 3080\"},\n{\"label\":\"Execution Trace Logs\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"1432 154\",\"key\":111,\"location\":\"2760 2880\",\"color\":\"LightGray\"},\n{\"label\":\"DummyEnable\",\"category\":\"CodeFlow_Feature\",\"size\":\"180 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":112,\"location\":\"4090.000136589022 1729.9995558231706\",\"group\":124},\n{\"label\":\"DFEGenerator 1.3\",\"category\":\"CodeFlow_FeatureOnOff\",\"size\":\"338 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":114,\"location\":\"3680 1730\",\"group\":124},\n{\"label\":\"Releases & Features\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":124,\"location\":\"3660 1729.9997779115852\"},\n{\"label\":\"OutCode_ANTO.js\",\"color\":\"orange\",\"size\":\"251 35\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/*\\n * This file is code generated by GenDFE 1.3\\n * \\n * Generated on Thu, 25 Jan 2024 08:09:28 GMT\\n * \\n */\\n\\n\\n/*****************************************\\n * Node Functions\\n *****************************************/\\n// System function for reading properties\\nfunction DFE_getProperty( name, defaultValue ) {\\n  // NOTE: this function access both nodeData fields and properties\\n  if( this.nd_[name] != undefined ) {\\n    return( this.nd_[name] );\\n  } else if( this.nd_.props_[name] != undefined ) {\\n    return( this.nd_.props_[name] );\\n  } else {\\n    return( defaultValue );\\n  }\\n}\\n// System function for property data access\\nfunction DFE_getPropertyList() {\\n  return( this.nd_.props_ );\\n}\\n// System function for reading input\\nfunction DFE_getInput( name, defaultValue ) {\\n  if( this.in_[name] == undefined ) {\\n    this.in_[name] = defaultValue;\\n  }\\n  return( this.in_[name] );\\n}\\n// System function for storing input\\nfunction DFE_setInput( name, value ) {\\n  this.in_[name] = value;\\n}\\n// System function for getting input name list\\nfunction DFE_getInputNameList() {\\n  return( this.nd_.in_ );\\n}\\n// System function for getting output name list\\nfunction DFE_getOutputNameList() {\\n  return( this.nd_.out_ );\\n}\\n// System function for instance data access\\nfunction DFE_get( name, defaultValue ) {\\n  if( this.st_[name] == undefined ) {\\n    this.st_[name] = defaultValue;\\n  }\\n  return( this.st_[name] );\\n}\\n// System function for instance data storage\\nfunction DFE_set( name, value ) {\\n  this.st_[name] = value;\\n}\\n// System function for firing inputs\\nfunction DFE_fireInput( name, value ) {\\n  this.setInput( name, value );\\n  this.doCompute( name, value );\\n}\\n\\n\\n/*****************************************\\n * Node Functions/Model States\\n *****************************************/\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_9 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_19.setInput( 'in', value );\\n      nodeData_19.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Tokenizer\\nconst nodeData_15 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Tokenizer',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_18.setInput( 'in', value );\\n      nodeData_18.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_15,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_19 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rValue', value );\\n      nodeData_58.doCompute( 'rValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rStatus', value );\\n      nodeData_58.doCompute( 'rStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Split\\nconst nodeData_18 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Split',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'lEq',\\n      'rEq',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'lEq' ) {\\n      // Store new input\\n      nodeData_26.setInput( 'in', value );\\n      nodeData_26.doCompute( 'in', value );\\n    } else if( name == 'rEq' ) {\\n      // Store new input\\n      nodeData_9.setInput( 'in', value );\\n      nodeData_9.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_18,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_26 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'in', value );\\n      nodeData_27.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_27 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lValue', value );\\n      nodeData_58.doCompute( 'lValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lStatus', value );\\n      nodeData_58.doCompute( 'lStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Evaluate\\nconst nodeData_25 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Evaluate',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'variable',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_34.setInput( 'in', value );\\n      nodeData_34.doCompute( 'in', value );\\n      // Store new input\\n      nodeData_45.setInput( 'in', value );\\n      nodeData_45.doCompute( 'in', value );\\n    } else if( name == 'variable' ) {\\n      // Store new input\\n      nodeData_92.setInput( 'in', value );\\n      nodeData_92.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_25,\\n};\\n// Node Info: [DataFlow_Message] var = 33\\nconst nodeData_34 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'var = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nconst nodeData_50 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Log Result\\nconst nodeData_45 = {\\n  in_: {},       // Input values\\n  nd_: {         // Full node fields/properties\\n    label: 'Log Result',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '*',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_45,\\n};\\n// Node Info: [DataFlow_Component] Barrier\\nconst nodeData_58 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Barrier',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'lValue',\\n      'lStatus',\\n      'rValue',\\n      'rStatus',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_25.setInput( 'in', value );\\n      nodeData_25.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_MakeObject,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor\\nconst nodeData_122 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33\\nconst nodeData_88 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'variables', value );\\n      nodeData_27.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_19.setInput( 'variables', value );\\n      nodeData_19.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_92.setInput( 'variables', value );\\n      nodeData_92.doCompute( 'variables', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Variable Update\\nconst nodeData_92 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Variable Update',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_92,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\nconst nodeData_96 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n\\n/*****************************************\\n * Compute Functions\\n *****************************************/\\n// Node Compute[9]: [DataFlow_Component] Equation Parser\\nfunction compute_EquationParser( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Build the AST tree (recursive function)\\n    const outValue = buildAST( value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[15]: [DataFlow_Component] Equation Tokenizer\\nfunction compute_Component_15( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Split each line\\n    const lineList = value.split( '\\\\n' );\\n    for( const line of lineList ) {\\n      // Tokenize the input equation\\n      const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+/g;\\n      let tokenList = [];\\n      if( value ) {\\n        tokenList = line.match( regex ).map( token => {\\n          return( isNaN( token ) ? token : parseFloat( token ) );\\n        });\\n      }\\n      \\n      this.fireOutput( 'out', tokenList );\\n    }\\n  }\\n}\\n// Node Compute[19]: [DataFlow_Component] Equation Compute\\nfunction compute_EquationCompute( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = NaN;\\n    let outStatus = 'Done';\\n    try {\\n      if( value == null ) {\\n        outValue = '';\\n      } else {\\n        const variables = this.getInput( 'variables', '' );\\n        const variableValues = getVariableValues( variables );\\n  \\n        outValue = evaluateAST( value, variableValues );\\n      }\\n    } catch( e ) {\\n      outStatus = `Syntax error in expression: ${e}`;\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n    this.fireOutput( 'status', outStatus );\\n  }\\n}\\n// Node Compute[18]: [DataFlow_Component] Equation Split\\nfunction compute_Component_18( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let i = value.indexOf( '=' );\\n    if( i == -1 ) {\\n      i = value.length;\\n    }\\n    \\n    const lEq = value.slice( 0, i );\\n    const rEq = value.slice( i+1 );\\n    \\n    this.fireOutput( 'lEq', lEq );\\n    this.fireOutput( 'rEq', rEq );\\n  }\\n}\\n// Node Compute[25]: [DataFlow_Component] Equation Evaluate\\nfunction compute_Component_25( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = '';\\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n        outValue = value.lValue || value.rValue;\\n      } else if( isVariable( value.lValue  ) ) {\\n        outValue = `${value.lValue} = ${value.rValue}`;\\n        const varValue = { id: value.lValue, value: value.rValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else if( isVariable( value.rValue ) ) {\\n        outValue = `${value.rValue} = ${value.lValue}`;\\n        const varValue = { id: value.rValue, value: value.lValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else {\\n        outValue = String( value.lValue == value.rValue );\\n      }\\n    } else {\\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Compute[34]: [DataFlow_Message] var = 33\\nfunction compute_DataFlow_Message( name, value ) {\\n  \\n  if( value == undefined ) {\\n    value = this.getProperty( 'label', '' );\\n    try {\\n      value = JSON.parse( value ); \\n    } catch( e ) {}\\n  }\\n  this.fireOutput( 'out', value );\\n}\\n// Node Compute[45]: [DataFlow_Component] Log Result\\nfunction compute_Component_45( name, value ) {\\n  \\n  console.log( value );\\n}\\n// Node Compute[58]: [DataFlow_Component] Barrier\\nfunction compute_MakeObject( name, value ) {\\n  \\n  const inNameList = this.getInputNameList( );\\n  const inputStat = this.get( 'inputStat', {} );\\n  \\n  inputStat[name] = true;\\n  let isObjectReady = true;\\n  for( const inName of inNameList ) {\\n    if( !inputStat[inName] ) {\\n      isObjectReady = false;\\n      break;\\n    }\\n  }\\n  \\n  if( isObjectReady ) {\\n    this.set( 'inputStat', {} );\\n    \\n    const outValue = {};\\n    for( const inName of inNameList ) {\\n      outValue[inName] = this.getInput( inName, null );\\n    }\\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[92]: [DataFlow_Component] Variable Update\\nfunction compute_Component_92( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    const variables = this.getInput( 'variables', '' );\\n    let outValue = updateVariableValue( variables, value.id, value.value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Includes[94]: [Hierarchy_CodeInGraph] Helper Functions\\nfunction getVariableValues( variables ) {\\n  const result = {};\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    result[match[1]] = match[2];\\n  }\\n  return( result );\\n}\\nfunction updateVariableValue( variables, id, value ) {\\n  const result = [];\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n  let isVarUpdated = false;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    if( match[1] == id ) {\\n      isVarUpdated = true;\\n      result.push( `${match[1]} = ${value}` );\\n    } else {\\n     result.push( `${match[1]} = ${match[2]}` );\\n    }\\n  }\\n  if( !isVarUpdated ) {\\n    result.push( `${id} = ${value}` );\\n  }\\n  return( result.join( '\\\\n' ) );\\n}\\nfunction isVariable( str ) {\\n  return( RegExp( /^[a-z]/i ).test( str ) );\\n}\\nfunction buildAST( tokenList ) {\\n  if( tokenList.length == 0 ) {\\n    return( null );\\n  } else if( tokenList.length == 1 ) {\\n    return( tokenList[0] );\\n  }\\n\\n  // Find the index of the lowest precedence operator\\n  let index = -1;\\n  let minPrecedence = Infinity;\\n  let parenthesis = 0;\\n  // Loop over all tokenList\\n  for( let i = 0; i < tokenList.length; ++i ) {\\n    if( tokenList[i] == '(' ) {\\n      parenthesis++;\\n    } else if( tokenList[i] == ')' ) {\\n      parenthesis--;\\n    } else if( parenthesis === 0 ) {\\n      // Compute precedences\\n      const operator = tokenList[i];\\n      let precedence = 0;\\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\\n        precedence = 1;\\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n        precedence = 2;\\n      } else {\\n        precedence = Infinity;\\n      }\\n      \\n      if( precedence <= minPrecedence ) {\\n        minPrecedence = precedence;\\n        index = i;\\n      }\\n    }\\n  }\\n\\n  // Handle subexpressions inside parentheses\\n  if( index === -1 ) {\\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\\n  }\\n\\n  const result = [\\n    tokenList[index],\\n    buildAST( tokenList.slice( 0, index ) ),\\n    buildAST( tokenList.slice( index+1 ))\\n  ];\\n  return( result );\\n}\\nfunction evaluateAST( ast, variables ) {\\n  \\n  if( RegExp( /^[a-z_]/i ).test( ast ) ) {\\n    const varValue = variables[ast];\\n    if( varValue != undefined ) {\\n      return( parseFloat( varValue ) );\\n    } else {\\n      return( ast );\\n    }\\n  } else if( typeof( ast ) === 'number' ) {\\n    // Base case: if the node is a number, return it.\\n    return( ast );\\n  }\\n\\n  // Recursive case: evaluate the left and right operands.\\n  const left = evaluateAST( ast[1], variables );\\n  const right = evaluateAST( ast[2], variables );\\n\\n  // Compute the result based on the operator.\\n  switch( ast[0] ) {\\n    case '+':\\n      return( left + right );\\n    case '-':\\n      return( left - right );\\n    case '*':\\n      return( left * right );\\n    case '/':\\n      return( left / right );\\n    default:\\n      throw new Error( 'Unknown operator: ' + ast[0] );\\n  }\\n}\\n\\n/*****************************************\\n * System Start\\n *****************************************/\\nnodeData_96.doCompute( 'in' );\\nnodeData_50.doCompute( 'in' );\\nnodeData_96.doCompute( 'in' );\\nnodeData_122.doCompute( 'in' );\\n\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":128,\"location\":\"4260 2410\",\"editorPosition\":[2227,1594,597,1366],\"group\":78},\n{\"label\":\"OutCode_ANTO.py\",\"color\":\"firebrick\",\"size\":\"251 35\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"'''\\nThis file is code generated by GenDFE 1.3\\n * \\n * Generated on Wed, 31 Jan 2024 18:47:13 GMT\\n * \\n'''\\n\\n'''\\n****************************************\\n* Node Functions\\n****************************************\\n'''\\nimport json\\nimport re\\nfrom dataclasses import dataclass\\nfrom typing import Callable, Dict, List\\n\\n@dataclass\\nclass NodeData:\\n    #********************\\n    # Node System Dependant Functions\\n    #********************\\n    # System function for reading properties\\n    def DFE_get_property(self, name, default_value):\\n        # NOTE: this function accesses both nodeData fields and properties\\n        if name in self.nd_:\\n            return self.nd_[name]\\n        elif name in self.nd_['props_']:\\n            return self.nd_['props_'][name]\\n        else:\\n            return default_value\\n        \\n    # System function for property data access\\n    def DFE_get_property_list(self):\\n        return self.nd_['props_']\\n\\n    # System function for reading input\\n    def DFE_get_input(self, name, default_value):\\n        if name not in self.in_:\\n            self.in_[name] = default_value\\n        return self.in_[name]\\n\\n    # System function for storing access\\n    def DFE_set_input(self, name, value):\\n        self.in_[name] = value\\n\\n    # System function for getting input name list\\n    def DFE_get_input_name_list(self):\\n        return self.nd_['in_']\\n    \\n    # System function for getting output name list\\n    def DFE_get_output_name_list(self):\\n        return self.nd_['out_']\\n\\n    # System function for instance data access\\n    def DFE_get(self, name, default_value):\\n        if name not in self.st_:\\n            self.st_[name] = default_value\\n        return self.st_[name]\\n    \\n    # System function for instance data storage\\n    def DFE_set(self, name, value):\\n        self.st_['name'] = value\\n\\n    # System function for firing inputs\\n    def DFE_fire_input(self, name, value):\\n        self.set_input(name, value)\\n        self.do_compute(name, value)\\n\\n    #********************\\n    # Node Fields\\n    #********************\\n    in_: Dict \\n    out_: Dict\\n    nd_ : Dict\\n    st_ : Dict\\n    fire_output: Callable\\n    get_property = DFE_get_property\\n    get_input = DFE_get_input\\n    set_input = DFE_set_input\\n    get_input_name_list= DFE_get_input_name_list\\n    get_output_name_list = DFE_get_output_name_list\\n    get = DFE_get\\n    set = DFE_set\\n    fire_input = DFE_fire_input\\n    get = DFE_get_property\\n    do_compute: Callable\\n'''\\n****************************************\\n* Compute Functions\\n****************************************\\n'''\\n# Node Compute[9]: [DataFlow_Component] Equation Parser\\ndef compute_EquationParser(self : NodeData, name, value):\\n    if name == 'in':\\n        # Build the AST tree (recursive function)\\n        out_value = buildAST(value)\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[15]: [DataFlow_Component] Equation Tokenizer\\ndef compute_Component_15(self : NodeData, name, value):\\n    if name == 'in':\\n        # Split each line\\n        line_list = value.split('\\\\n')\\n        for line in line_list:\\n            # Tokenize the input equation\\n            regex = r'\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+'\\n            token_list = []\\n            if value:\\n                token_list = [float(token) if token.isdigit() or (token[0] == '-' and token[1:].isdigit()) else token\\n                              for token in re.findall(regex, line)]\\n\\n            self.fire_output('out', token_list)\\n\\n# Node Compute[19]: [DataFlow_Component] Equation Compute\\ndef compute_EquationCompute(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = float('nan')\\n        out_status = 'Done'\\n        try:\\n            if value is None:\\n                out_value = ''\\n            else:\\n                variables = self.get_input('variables', '')\\n                variable_values = getVariableValues(variables)\\n\\n                out_value = evaluateAST(value, variable_values)\\n        except Exception as e:\\n            out_status = f'Syntax error in expression: {e}'\\n\\n        self.fire_output('out', out_value)\\n        self.fire_output('status', out_status)\\n\\n# Node Compute[18]: [DataFlow_Component] Equation Split\\ndef compute_Component_18(self : NodeData, name, value):\\n    if name == 'in':\\n        i = value.find('=')\\n        if i == -1:\\n            i = len(value)\\n\\n        l_eq = value[:i]\\n        r_eq = value[i+1:]\\n\\n        self.fire_output('lEq', l_eq)\\n        self.fire_output('rEq', r_eq)\\n\\n# Node Compute[25]: [DataFlow_Component] Equation Evaluate\\ndef compute_Component_25(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = ''\\n        if value['lStatus'] == 'Done' and value['rStatus'] == 'Done':\\n            if value['lValue'] == '' or value['rValue'] == '':\\n                out_value = value['lValue'] or value['rValue']\\n            elif isVariable(value['lValue']):\\n                out_value = f\\\"{value['lValue']} = {value['rValue']}\\\"\\n                var_value = {'id': value['lValue'], 'value': value['rValue']}\\n                self.fire_output('variable', var_value)\\n            elif isVariable(value['rValue']):\\n                out_value = f\\\"{value['rValue']} = {value['lValue']}\\\"\\n                var_value = {'id': value['rValue'], 'value': value['lValue']}\\n                self.fire_output('variable', var_value)\\n            else:\\n                out_value = str(value['lValue'] == value['rValue'])\\n        else:\\n            out_value = value['rStatus'] if value['lStatus'] == 'Done' else value['lStatus']\\n\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[34]: [DataFlow_Message] var = 33\\ndef compute_DataFlow_Message( self : NodeData, name, value ):\\n  if value is None:\\n      value = self.get_property('label', '')\\n  try:\\n      value = json.loads(value)\\n  except Exception as e:  # Use 'Exception' to catch all exceptions\\n      pass\\n  self.fire_output('out', value)\\n# Node Compute[45]: [DataFlow_Component] Log Result\\ndef compute_Component_45( self : NodeData, name, value ):\\n  if name == 'in':\\n      print(value)\\n\\n# Node Compute[58]: [DataFlow_Component] Barrier\\ndef compute_MakeObject( self : NodeData, name, value ):\\n    in_name_list = self.get_input_name_list()\\n    input_stat = self.get('inputStat', {})\\n\\n    input_stat[name] = True\\n    is_object_ready = all(input_stat[in_name] for in_name in in_name_list)\\n\\n    if is_object_ready:\\n        self.set('inputStat', {})\\n\\n        out_value = {in_name: self.get_input(in_name, None) for in_name in in_name_list}\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[92]: [DataFlow_Component] Variable Update\\ndef compute_Component_92( self : NodeData, name, value ):\\n  if name == 'in':\\n      variables = self.get_input('variables', '')\\n      out_value = updateVariableValue(variables, value['id'], value['value'])\\n\\n      self.fire_output('out', out_value)\\n\\n# Node Includes[94]: [Hierarchy_CodeInGraph] Helper Functions\\ndef getVariableValues(variables):\\n    result = {}\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n\\n    for match in matches:\\n        result[match.group(1)] = match.group(2)\\n\\n    return result\\n\\ndef updateVariableValue(variables, id, value):\\n    result = []\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n    is_var_updated = False\\n\\n    for match in matches:\\n        if match.group(1) == id:\\n            is_var_updated = True\\n            result.append(f'{match.group(1)} = {value}')\\n        else:\\n            result.append(f'{match.group(1)} = {match.group(2)}')\\n\\n    if not is_var_updated:\\n        result.append(f'{id} = {value}')\\n\\n    return '\\\\n'.join(result)\\n\\ndef isVariable(s):\\n    return re.match(r'^[a-z]', s, re.IGNORECASE) is not None\\n\\ndef buildAST(token_list):\\n    if len(token_list) == 0:\\n        return None\\n    elif len(token_list) == 1:\\n        return token_list[0]\\n\\n    # Find the index of the lowest precedence operator\\n    index = -1\\n    min_precedence = float('inf')\\n    parenthesis = 0\\n    # Loop over all token_list\\n    for i in range(len(token_list)):\\n        if token_list[i] == '(':\\n            parenthesis += 1\\n        elif token_list[i] == ')':\\n            parenthesis -= 1\\n        elif parenthesis == 0:\\n            # Compute precedences\\n            operator = token_list[i]\\n            precedence = 0\\n            if operator in ('+', '-'):\\n                precedence = 1\\n            elif operator in ('*', '/'):\\n                precedence = 2\\n            else:\\n                precedence = float('inf')\\n\\n            if precedence <= min_precedence:\\n                min_precedence = precedence\\n                index = i\\n\\n    # Handle subexpressions inside parentheses\\n    if index == -1:\\n        return buildAST(token_list[1:-1])\\n\\n    result = [\\n        token_list[index],\\n        buildAST(token_list[:index]),\\n        buildAST(token_list[index+1:])\\n    ]\\n    return result\\n\\ndef evaluateAST(ast, variables):\\n    if re.match(r'^[a-z_]', ast, re.IGNORECASE):\\n        var_value = variables.get(ast)\\n        if var_value is not None:\\n            return float(var_value)\\n        else:\\n            return ast\\n    elif isinstance(ast, (int, float)):\\n        # Base case: if the node is a number, return it.\\n        return ast\\n\\n    # Recursive case: evaluate the left and right operands.\\n    left = evaluateAST(ast[1], variables)\\n    right = evaluateAST(ast[2], variables)\\n\\n    # Compute the result based on the operator.\\n    if ast[0] == '+':\\n        return left + right\\n    elif ast[0] == '-':\\n        return left - right\\n    elif ast[0] == '*':\\n        return left * right\\n    elif ast[0] == '/':\\n        return left / right\\n    else:\\n        raise ValueError('Unknown operator: ' + ast[0])\\n\\n'''\\n****************************************\\n* Node Functions/Model States\\n****************************************\\n'''\\n# Node Info: [DataFlow_Component] Equation Parser\\nnodeData_9 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Parser',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_19.set_input( 'in', value ), \\n        nodeData_19.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_EquationParser,\\n)\\n# Node Info: [DataFlow_Component] Equation Tokenizer\\nnodeData_15 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Tokenizer',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_18.set_input( 'in', value ), \\n        nodeData_18.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_Component_15,\\n)\\n# Node Info: [DataFlow_Component] Equation Compute\\nnodeData_19 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Compute',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'status',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'rValue', value ), \\n        nodeData_58.do_compute( 'rValue', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'rStatus', value ), \\n        nodeData_58.do_compute( 'rStatus', value )\\n        ) if name == 'status' else\\n        None\\n    ),\\n    do_compute= compute_EquationCompute,\\n)\\n# Node Info: [DataFlow_Component] Equation Split\\nnodeData_18 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Split',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'lEq',\\n            'rEq',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_26.set_input( 'in', value ), \\n        nodeData_26.do_compute( 'in', value )\\n        ) if name == 'lEq' else\\n        ( \\n        # Store new input\\n        nodeData_9.set_input( 'in', value ), \\n        nodeData_9.do_compute( 'in', value )\\n        ) if name == 'rEq' else\\n        None\\n    ),\\n    do_compute= compute_Component_18,\\n)\\n# Node Info: [DataFlow_Component] Equation Parser\\nnodeData_26 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Parser',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_27.set_input( 'in', value ), \\n        nodeData_27.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_EquationParser,\\n)\\n# Node Info: [DataFlow_Component] Equation Compute\\nnodeData_27 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Compute',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'status',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'lValue', value ), \\n        nodeData_58.do_compute( 'lValue', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'lStatus', value ), \\n        nodeData_58.do_compute( 'lStatus', value )\\n        ) if name == 'status' else\\n        None\\n    ),\\n    do_compute= compute_EquationCompute,\\n)\\n# Node Info: [DataFlow_Component] Equation Evaluate\\nnodeData_25 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Evaluate',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'variable',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_34.set_input( 'in', value ), \\n        nodeData_34.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_45.set_input( 'in', value ), \\n        nodeData_45.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_92.set_input( 'in', value ), \\n        nodeData_92.do_compute( 'in', value )\\n        ) if name == 'variable' else\\n        None\\n    ),\\n    do_compute= compute_Component_25,\\n)\\n# Node Info: [DataFlow_Message] var = 33\\nnodeData_34 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'var = 33',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nnodeData_50 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': '2+3*5-(2+20*0.5)+1',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_15.set_input( 'in', value ), \\n        nodeData_15.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Component] Log Result\\nnodeData_45 = NodeData(\\n    in_= {},       # Input values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Log Result',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '*',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n    ),\\n    do_compute= compute_Component_45,\\n)\\n# Node Info: [DataFlow_Component] Barrier\\nnodeData_58 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Barrier',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'lValue',\\n            'lStatus',\\n            'rValue',\\n            'rStatus',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_25.set_input( 'in', value ), \\n        nodeData_25.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_MakeObject,\\n)\\n# Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor\\nnodeData_122 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': '2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_15.set_input( 'in', value ), \\n        nodeData_15.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33\\nnodeData_88 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_27.set_input( 'variables', value ), \\n        nodeData_27.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_19.set_input( 'variables', value ), \\n        nodeData_19.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_92.set_input( 'variables', value ), \\n        nodeData_92.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Component] Variable Update\\nnodeData_92 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Variable Update',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_88.set_input( 'in', value ), \\n        nodeData_88.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_Component_92,\\n)\\n# Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\nnodeData_96 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'alpha = 10\\\\nbeta = 4',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_88.set_input( 'in', value ), \\n        nodeData_88.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n'''\\n****************************************\\n* System Start\\n****************************************\\n'''\\nnodeData_96.do_compute( 'in', None )\\nnodeData_50.do_compute( 'in', None )\\nnodeData_96.do_compute( 'in', None )\\nnodeData_122.do_compute( 'in', None )\\n\",\"fileTypeName\":\"Python\",\"fileType\":\"text/python\",\"key\":131,\"location\":\"4260 2460\",\"editorPosition\":[2830,1595,615,1353],\"group\":78},\n{\"label\":\"run.sh\",\"color\":\"gray\",\"size\":\"180 35\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"#!/bin/bash\\n\\n# 1.3.2\\nnode MainCodeGenerate.js '{\\\"modelFileURL\\\": \\\"43.json\\\", \\\"groupKey\\\": 36, \\\"language\\\" : \\\"python\\\"}'\\n\",\"fileTypeName\":\"Shell\",\"fileType\":\"application/x-shellscript\",\"key\":133,\"location\":\"4060 2460\",\"editorPosition\":[1729,2057,400,350],\"group\":78},\n{\"label\":\"TargetCode.py\",\"color\":\"firebrick\",\"size\":\"180 35\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"'''\\nThis file is code generated by GenDFE 1.3\\n * \\n * Generated on Wed, 31 Jan 2024 18:47:13 GMT\\n * \\n'''\\n\\n'''\\n****************************************\\n* Node Functions\\n****************************************\\n'''\\nimport json\\nimport re\\nfrom dataclasses import dataclass\\nfrom typing import Callable, Dict, List\\n\\n@dataclass\\nclass NodeData:\\n    #********************\\n    # Node System Dependant Functions\\n    #********************\\n    # System function for reading properties\\n    def DFE_get_property(self, name, default_value):\\n        # NOTE: this function accesses both nodeData fields and properties\\n        if name in self.nd_:\\n            return self.nd_[name]\\n        elif name in self.nd_['props_']:\\n            return self.nd_['props_'][name]\\n        else:\\n            return default_value\\n        \\n    # System function for property data access\\n    def DFE_get_property_list(self):\\n        return self.nd_['props_']\\n\\n    # System function for reading input\\n    def DFE_get_input(self, name, default_value):\\n        if name not in self.in_:\\n            self.in_[name] = default_value\\n        return self.in_[name]\\n\\n    # System function for storing access\\n    def DFE_set_input(self, name, value):\\n        self.in_[name] = value\\n\\n    # System function for getting input name list\\n    def DFE_get_input_name_list(self):\\n        return self.nd_['in_']\\n    \\n    # System function for getting output name list\\n    def DFE_get_output_name_list(self):\\n        return self.nd_['out_']\\n\\n    # System function for instance data access\\n    def DFE_get(self, name, default_value):\\n        if name not in self.st_:\\n            self.st_[name] = default_value\\n        return self.st_[name]\\n    \\n    # System function for instance data storage\\n    def DFE_set(self, name, value):\\n        self.st_['name'] = value\\n\\n    # System function for firing inputs\\n    def DFE_fire_input(self, name, value):\\n        self.set_input(name, value)\\n        self.do_compute(name, value)\\n\\n    #********************\\n    # Node Fields\\n    #********************\\n    in_: Dict \\n    out_: Dict\\n    nd_ : Dict\\n    st_ : Dict\\n    fire_output: Callable\\n    get_property = DFE_get_property\\n    get_input = DFE_get_input\\n    set_input = DFE_set_input\\n    get_input_name_list= DFE_get_input_name_list\\n    get_output_name_list = DFE_get_output_name_list\\n    get = DFE_get\\n    set = DFE_set\\n    fire_input = DFE_fire_input\\n    get = DFE_get_property\\n    do_compute: Callable\\n'''\\n****************************************\\n* Compute Functions\\n****************************************\\n'''\\n# Node Compute[9]: [DataFlow_Component] Equation Parser\\ndef compute_EquationParser(self : NodeData, name, value):\\n    if name == 'in':\\n        # Build the AST tree (recursive function)\\n        out_value = buildAST(value)\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[15]: [DataFlow_Component] Equation Tokenizer\\ndef compute_Component_15(self : NodeData, name, value):\\n    if name == 'in':\\n        # Split each line\\n        line_list = value.split('\\\\n')\\n        for line in line_list:\\n            # Tokenize the input equation\\n            regex = r'\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+'\\n            token_list = []\\n            if value:\\n                token_list = [float(token) if token.isdigit() or (token[0] == '-' and token[1:].isdigit()) else token\\n                              for token in re.findall(regex, line)]\\n\\n            self.fire_output('out', token_list)\\n\\n# Node Compute[19]: [DataFlow_Component] Equation Compute\\ndef compute_EquationCompute(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = float('nan')\\n        out_status = 'Done'\\n        try:\\n            if value is None:\\n                out_value = ''\\n            else:\\n                variables = self.get_input('variables', '')\\n                variable_values = getVariableValues(variables)\\n\\n                out_value = evaluateAST(value, variable_values)\\n        except Exception as e:\\n            out_status = f'Syntax error in expression: {e}'\\n\\n        self.fire_output('out', out_value)\\n        self.fire_output('status', out_status)\\n\\n# Node Compute[18]: [DataFlow_Component] Equation Split\\ndef compute_Component_18(self : NodeData, name, value):\\n    if name == 'in':\\n        i = value.find('=')\\n        if i == -1:\\n            i = len(value)\\n\\n        l_eq = value[:i]\\n        r_eq = value[i+1:]\\n\\n        self.fire_output('lEq', l_eq)\\n        self.fire_output('rEq', r_eq)\\n\\n# Node Compute[25]: [DataFlow_Component] Equation Evaluate\\ndef compute_Component_25(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = ''\\n        if value['lStatus'] == 'Done' and value['rStatus'] == 'Done':\\n            if value['lValue'] == '' or value['rValue'] == '':\\n                out_value = value['lValue'] or value['rValue']\\n            elif isVariable(value['lValue']):\\n                out_value = f\\\"{value['lValue']} = {value['rValue']}\\\"\\n                var_value = {'id': value['lValue'], 'value': value['rValue']}\\n                self.fire_output('variable', var_value)\\n            elif isVariable(value['rValue']):\\n                out_value = f\\\"{value['rValue']} = {value['lValue']}\\\"\\n                var_value = {'id': value['rValue'], 'value': value['lValue']}\\n                self.fire_output('variable', var_value)\\n            else:\\n                out_value = str(value['lValue'] == value['rValue'])\\n        else:\\n            out_value = value['rStatus'] if value['lStatus'] == 'Done' else value['lStatus']\\n\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[34]: [DataFlow_Message] var = 33\\ndef compute_DataFlow_Message( self : NodeData, name, value ):\\n  if value is None:\\n      value = self.get_property('label', '')\\n  try:\\n      value = json.loads(value)\\n  except Exception as e:  # Use 'Exception' to catch all exceptions\\n      pass\\n  self.fire_output('out', value)\\n# Node Compute[45]: [DataFlow_Component] Log Result\\ndef compute_Component_45( self : NodeData, name, value ):\\n  if name == 'in':\\n      print(value)\\n\\n# Node Compute[58]: [DataFlow_Component] Barrier\\ndef compute_MakeObject( self : NodeData, name, value ):\\n    in_name_list = self.get_input_name_list()\\n    input_stat = self.get('inputStat', {})\\n\\n    input_stat[name] = True\\n    is_object_ready = all(input_stat[in_name] for in_name in in_name_list)\\n\\n    if is_object_ready:\\n        self.set('inputStat', {})\\n\\n        out_value = {in_name: self.get_input(in_name, None) for in_name in in_name_list}\\n        self.fire_output('out', out_value)\\n\\n# Node Compute[92]: [DataFlow_Component] Variable Update\\ndef compute_Component_92( self : NodeData, name, value ):\\n  if name == 'in':\\n      variables = self.get_input('variables', '')\\n      out_value = updateVariableValue(variables, value['id'], value['value'])\\n\\n      self.fire_output('out', out_value)\\n\\n# Node Includes[94]: [Hierarchy_CodeInGraph] Helper Functions\\ndef getVariableValues(variables):\\n    result = {}\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n\\n    for match in matches:\\n        result[match.group(1)] = match.group(2)\\n\\n    return result\\n\\ndef updateVariableValue(variables, id, value):\\n    result = []\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n    is_var_updated = False\\n\\n    for match in matches:\\n        if match.group(1) == id:\\n            is_var_updated = True\\n            result.append(f'{match.group(1)} = {value}')\\n        else:\\n            result.append(f'{match.group(1)} = {match.group(2)}')\\n\\n    if not is_var_updated:\\n        result.append(f'{id} = {value}')\\n\\n    return '\\\\n'.join(result)\\n\\ndef isVariable(s):\\n    return re.match(r'^[a-z]', s, re.IGNORECASE) is not None\\n\\ndef buildAST(token_list):\\n    if len(token_list) == 0:\\n        return None\\n    elif len(token_list) == 1:\\n        return token_list[0]\\n\\n    # Find the index of the lowest precedence operator\\n    index = -1\\n    min_precedence = float('inf')\\n    parenthesis = 0\\n    # Loop over all token_list\\n    for i in range(len(token_list)):\\n        if token_list[i] == '(':\\n            parenthesis += 1\\n        elif token_list[i] == ')':\\n            parenthesis -= 1\\n        elif parenthesis == 0:\\n            # Compute precedences\\n            operator = token_list[i]\\n            precedence = 0\\n            if operator in ('+', '-'):\\n                precedence = 1\\n            elif operator in ('*', '/'):\\n                precedence = 2\\n            else:\\n                precedence = float('inf')\\n\\n            if precedence <= min_precedence:\\n                min_precedence = precedence\\n                index = i\\n\\n    # Handle subexpressions inside parentheses\\n    if index == -1:\\n        return buildAST(token_list[1:-1])\\n\\n    result = [\\n        token_list[index],\\n        buildAST(token_list[:index]),\\n        buildAST(token_list[index+1:])\\n    ]\\n    return result\\n\\ndef evaluateAST(ast, variables):\\n    if re.match(r'^[a-z_]', ast, re.IGNORECASE):\\n        var_value = variables.get(ast)\\n        if var_value is not None:\\n            return float(var_value)\\n        else:\\n            return ast\\n    elif isinstance(ast, (int, float)):\\n        # Base case: if the node is a number, return it.\\n        return ast\\n\\n    # Recursive case: evaluate the left and right operands.\\n    left = evaluateAST(ast[1], variables)\\n    right = evaluateAST(ast[2], variables)\\n\\n    # Compute the result based on the operator.\\n    if ast[0] == '+':\\n        return left + right\\n    elif ast[0] == '-':\\n        return left - right\\n    elif ast[0] == '*':\\n        return left * right\\n    elif ast[0] == '/':\\n        return left / right\\n    else:\\n        raise ValueError('Unknown operator: ' + ast[0])\\n\\n'''\\n****************************************\\n* Node Functions/Model States\\n****************************************\\n'''\\n# Node Info: [DataFlow_Component] Equation Parser\\nnodeData_9 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Parser',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_19.set_input( 'in', value ), \\n        nodeData_19.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_EquationParser,\\n)\\n# Node Info: [DataFlow_Component] Equation Tokenizer\\nnodeData_15 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Tokenizer',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_18.set_input( 'in', value ), \\n        nodeData_18.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_Component_15,\\n)\\n# Node Info: [DataFlow_Component] Equation Compute\\nnodeData_19 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Compute',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'status',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'rValue', value ), \\n        nodeData_58.do_compute( 'rValue', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'rStatus', value ), \\n        nodeData_58.do_compute( 'rStatus', value )\\n        ) if name == 'status' else\\n        None\\n    ),\\n    do_compute= compute_EquationCompute,\\n)\\n# Node Info: [DataFlow_Component] Equation Split\\nnodeData_18 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Split',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'lEq',\\n            'rEq',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_26.set_input( 'in', value ), \\n        nodeData_26.do_compute( 'in', value )\\n        ) if name == 'lEq' else\\n        ( \\n        # Store new input\\n        nodeData_9.set_input( 'in', value ), \\n        nodeData_9.do_compute( 'in', value )\\n        ) if name == 'rEq' else\\n        None\\n    ),\\n    do_compute= compute_Component_18,\\n)\\n# Node Info: [DataFlow_Component] Equation Parser\\nnodeData_26 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Parser',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_27.set_input( 'in', value ), \\n        nodeData_27.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_EquationParser,\\n)\\n# Node Info: [DataFlow_Component] Equation Compute\\nnodeData_27 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Compute',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'status',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'lValue', value ), \\n        nodeData_58.do_compute( 'lValue', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_58.set_input( 'lStatus', value ), \\n        nodeData_58.do_compute( 'lStatus', value )\\n        ) if name == 'status' else\\n        None\\n    ),\\n    do_compute= compute_EquationCompute,\\n)\\n# Node Info: [DataFlow_Component] Equation Evaluate\\nnodeData_25 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Equation Evaluate',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n            'variable',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_34.set_input( 'in', value ), \\n        nodeData_34.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_45.set_input( 'in', value ), \\n        nodeData_45.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_92.set_input( 'in', value ), \\n        nodeData_92.do_compute( 'in', value )\\n        ) if name == 'variable' else\\n        None\\n    ),\\n    do_compute= compute_Component_25,\\n)\\n# Node Info: [DataFlow_Message] var = 33\\nnodeData_34 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'var = 33',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nnodeData_50 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': '2+3*5-(2+20*0.5)+1',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_15.set_input( 'in', value ), \\n        nodeData_15.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Component] Log Result\\nnodeData_45 = NodeData(\\n    in_= {},       # Input values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Log Result',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '*',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n    ),\\n    do_compute= compute_Component_45,\\n)\\n# Node Info: [DataFlow_Component] Barrier\\nnodeData_58 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Barrier',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'lValue',\\n            'lStatus',\\n            'rValue',\\n            'rStatus',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_25.set_input( 'in', value ), \\n        nodeData_25.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_MakeObject,\\n)\\n# Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor\\nnodeData_122 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': '2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_15.set_input( 'in', value ), \\n        nodeData_15.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33\\nnodeData_88 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_27.set_input( 'variables', value ), \\n        nodeData_27.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_19.set_input( 'variables', value ), \\n        nodeData_19.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        ( \\n        # Store new input\\n        nodeData_92.set_input( 'variables', value ), \\n        nodeData_92.do_compute( 'variables', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n# Node Info: [DataFlow_Component] Variable Update\\nnodeData_92 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'Variable Update',\\n        'color': 'LightSeaGreen',\\n        'in_': [       # Storage values \\n            'in',\\n            'variables',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n            'computeBarrier': '',\\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_88.set_input( 'in', value ), \\n        nodeData_88.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_Component_92,\\n)\\n# Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\nnodeData_96 = NodeData(\\n    in_= {},       # Input values\\n    out_= {},      # Output values\\n    nd_= {         # Full node fields/properties\\n        'label': 'alpha = 10\\\\nbeta = 4',\\n        'in_': [       # Storage values \\n            'in',\\n        ],\\n        'out_': [      # Storage values \\n            'out',\\n        ],\\n        'props_': {    # Storage values \\n        },\\n    },\\n    st_= {},       # Storage values \\n    fire_output = lambda name, value: (\\n        ( \\n        # Store new input\\n        nodeData_88.set_input( 'in', value ), \\n        nodeData_88.do_compute( 'in', value )\\n        ) if name == 'out' else\\n        None\\n    ),\\n    do_compute= compute_DataFlow_Message,\\n)\\n'''\\n****************************************\\n* System Start\\n****************************************\\n'''\\nnodeData_96.do_compute( 'in', None )\\nnodeData_50.do_compute( 'in', None )\\nnodeData_96.do_compute( 'in', None )\\nnodeData_122.do_compute( 'in', None )\\n\",\"fileTypeName\":\"Python\",\"fileType\":\"text/python\",\"key\":135,\"location\":\"3320 2120\",\"editorPosition\":[2928,1268,527,1436],\"group\":78},\n{\"label\":\"System Status: [DEPLOYED]\\ndone\\nFilesCount: 8 of 9\\nDirCount: 1 of 1\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"390 120\",\"buttons_\":[{\"name\":\"Deploy\",\"checked\":false},{\"name\":\"Start\",\"checked\":true},{\"name\":\"Stop\",\"checked\":false}],\"props_\":[{\"name\":\"isOverwrite\",\"value\":\"true\",\"valueChanged\":\"true\"},{\"name\":\"scriptPath\",\"value\":\"DFEGen/1.3.3\",\"valueChanged\":\"true\"},{\"name\":\"isAllEnabled\",\"value\":\"true\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n  // Uncomment the next line to start debugging\\n  //debugger;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\nlet script = '';\\nlet params = '';\\nconst scriptPath = getProperty( 'scriptPath' );\\n//const g = getMainGraph();\\nlet onLoaded = function(){};\\n\\nswitch( obj.data.name ) {\\n  case 'Deploy':\\n    const modelFileURL = getMainGraphURL();\\n    const deployKey = nodeData.key;\\n    \\n    script = `generateSystemLib.js`;\\n    params = `modelFileURL=${modelFileURL}&deployKey=${deployKey}`;\\n    onLoaded = function( msg ) {\\n      setNodeDataField( nodeData, 'label', 'System Status: [DEPLOYED]\\\\n'+msg );\\n    }\\n    break;\\n  case 'Start':\\n    script = 'serverManager';\\n    params = 'start '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STARTED]' );\\n    break;\\n  case 'Stop':\\n    script = 'serverManager';\\n    params = 'stop '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STOPPED]' );\\n    break;\\n}\\n\\nif( script ) {\\n  const cmd = `${script}${( params? '?'+params: '')}`;\\n  executeScript( cmd, onLoaded );\\n}\\n\\nfunction getProperty( name ) {\\n  let result = '';\\n  if( nodeData.props_ ) {\\n    nodeData.props_.find( (p)=> { if( p.name == name ) { result = p.value; return( true ) } } );\\n  }\\n  return( result );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":126,\"location\":\"4980 1950\",\"editorPosition\":[3132,1920,758,959]},\n{\"label\":\"192\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"54 35\",\"key\":130,\"location\":\"-10280 2140\"},\n{\"label\":\"145\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"43 35\",\"key\":132,\"location\":\"-9060 2320\",\"group\":192},\n{\"label\":\"140\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"39 35\",\"key\":134,\"location\":\"-10114.99989302025 2253.77674335835\",\"group\":192},\n{\"label\":\"139\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":136,\"location\":\"-9610 2470\",\"group\":192},\n{\"label\":\"Initial Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"269 44\",\"key\":137,\"location\":\"-9549.99989302025 2453.77674335835\",\"group\":192},\n{\"label\":\"alpha = 10\\nbeta = 4\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"267 143\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":139,\"location\":\"-9559.99989302025 2553.77674335835\",\"group\":192},\n{\"label\":\"Helper Functions\",\"color\":\"firebrick\",\"size\":\"400 180\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"def getVariableValues(variables):\\n    result = {}\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n\\n    for match in matches:\\n        result[match.group(1)] = match.group(2)\\n\\n    return result\\n\\ndef updateVariableValue(variables, id, value):\\n    result = []\\n    # Match: var = 10\\n    regex = re.compile(r'\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)', re.MULTILINE)\\n    matches = regex.finditer(variables)\\n    is_var_updated = False\\n\\n    for match in matches:\\n        if match.group(1) == id:\\n            is_var_updated = True\\n            result.append(f'{match.group(1)} = {value}')\\n        else:\\n            result.append(f'{match.group(1)} = {match.group(2)}')\\n\\n    if not is_var_updated:\\n        result.append(f'{id} = {value}')\\n\\n    return '\\\\n'.join(result)\\n\\ndef isVariable(s):\\n    return re.match(r'^[a-z]', s, re.IGNORECASE) is not None\\n\\ndef buildAST(token_list):\\n    if len(token_list) == 0:\\n        return None\\n    elif len(token_list) == 1:\\n        return token_list[0]\\n\\n    # Find the index of the lowest precedence operator\\n    index = -1\\n    min_precedence = float('inf')\\n    parenthesis = 0\\n    # Loop over all token_list\\n    for i in range(len(token_list)):\\n        if token_list[i] == '(':\\n            parenthesis += 1\\n        elif token_list[i] == ')':\\n            parenthesis -= 1\\n        elif parenthesis == 0:\\n            # Compute precedences\\n            operator = token_list[i]\\n            precedence = 0\\n            if operator in ('+', '-'):\\n                precedence = 1\\n            elif operator in ('*', '/'):\\n                precedence = 2\\n            else:\\n                precedence = float('inf')\\n\\n            if precedence <= min_precedence:\\n                min_precedence = precedence\\n                index = i\\n\\n    # Handle subexpressions inside parentheses\\n    if index == -1:\\n        return buildAST(token_list[1:-1])\\n\\n    result = [\\n        token_list[index],\\n        buildAST(token_list[:index]),\\n        buildAST(token_list[index+1:])\\n    ]\\n    return result\\n\\ndef evaluateAST(ast, variables):\\n    if re.match(r'^[a-z_]', ast, re.IGNORECASE):\\n        var_value = variables.get(ast)\\n        if var_value is not None:\\n            return float(var_value)\\n        else:\\n            return ast\\n    elif isinstance(ast, (int, float)):\\n        # Base case: if the node is a number, return it.\\n        return ast\\n\\n    # Recursive case: evaluate the left and right operands.\\n    left = evaluateAST(ast[1], variables)\\n    right = evaluateAST(ast[2], variables)\\n\\n    # Compute the result based on the operator.\\n    if ast[0] == '+':\\n        return left + right\\n    elif ast[0] == '-':\\n        return left - right\\n    elif ast[0] == '*':\\n        return left * right\\n    elif ast[0] == '/':\\n        return left / right\\n    else:\\n        raise ValueError('Unknown operator: ' + ast[0])\",\"fileTypeName\":\"Python\",\"fileType\":\"text/python\",\"key\":140,\"location\":\"-10079.99989302025 2352.549743358351\",\"group\":192,\"isIncludeScript\":true,\"editorPosition\":[246,1841,527,1094]},\n{\"label\":\"184\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"48 35\",\"key\":141,\"location\":\"-5343.999893020249 3032.54974335835\",\"group\":192},\n{\"label\":\"144\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"43 35\",\"key\":142,\"location\":\"-5348.999893020249 3262.54974335835\",\"group\":192},\n{\"label\":\"Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"344 44\",\"key\":143,\"location\":\"-8989.99989302025 2302.549743358351\",\"group\":192},\n{\"label\":\"Variable Update\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute( self : NodeData, name, value ):\\n  if name == 'in':\\n      variables = self.get_input('variables', '')\\n      out_value = updateVariableValue(variables, value['id'], value['value'])\\n\\n      self.fire_output('out', out_value)\",\"fileTypeName\":\"Component\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":144,\"location\":\"-5310 3310\",\"group\":192,\"editorPosition\":[2861,2205,778,494]},\n{\"label\":\"alpha = 10\\nbeta = 4\\nz = 6\\nvalue = 25\\nfactor = 8\\nvar = 33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 458\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":145,\"location\":\"-8999.99989302025 2552.549743358351\",\"group\":192},\n{\"label\":\"2+3*5-(2+20*0.5)+1=z\\n2+3*5-(2+20*0.5)+1=10-4\\nvalue=3*5+10\\nfactor=2*beta\\n2+3*5-(2+20*0.5)+1=10-1\\nvar=3*5+alpha+factor\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 364\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":146,\"location\":\"-9009.99989302025 3125.174743358351\",\"group\":192},\n{\"label\":\"146\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":147,\"location\":\"-9070 2940\",\"group\":192},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":148,\"location\":\"-9989.99989302025 2982.549743358351\",\"group\":192},\n{\"label\":\"148\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":149,\"location\":\"-10030 2940\",\"group\":192},\n{\"label\":\"181\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"48 35\",\"key\":150,\"location\":\"-5353.999893020249 3144.5917433583495\",\"group\":192},\n{\"label\":\"185\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":151,\"location\":\"-5769.999893020249 3054.5917433583504\",\"group\":192},\n{\"label\":\"164\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"45 35\",\"key\":152,\"location\":\"-6140.999893020249 3042.54974335835\",\"group\":192},\n{\"label\":\"189\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"47 35\",\"key\":153,\"location\":\"-6672.999893020249 3142.54974335835\",\"group\":192},\n{\"label\":\"186\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"44 35\",\"key\":154,\"location\":\"-6669.999893020249 2882.54974335835\",\"group\":192},\n{\"label\":\"191\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"46 35\",\"key\":155,\"location\":\"-7231.999893020249 3124.5917433583495\",\"group\":192},\n{\"label\":\"187\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"49 35\",\"key\":156,\"location\":\"-7209.999893020249 2874.5917433583495\",\"group\":192},\n{\"label\":\"188\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"45 35\",\"key\":157,\"location\":\"-7779.999893020249 3044.5917433583504\",\"group\":192},\n{\"label\":\"190\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"48 35\",\"key\":158,\"location\":\"-8323.99989302025 3032.549743358351\",\"group\":192},\n{\"label\":\"183\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"51 35\",\"key\":159,\"location\":\"-9060 2850\",\"group\":192},\n{\"label\":\"182\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"44 35\",\"key\":160,\"location\":\"-10030 2850\",\"group\":192},\n{\"label\":\"NOTE: Log components are linked with a log link and are inserted into a group. These 2 choices make sure that such components are not included in the code-generation phase\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"613 145\",\"key\":161,\"location\":\"-5299.999893020249 2372.549743358351\",\"group\":192},\n{\"label\":\"2) The different components show examples of the component model usage. The code can be seen by clicking on the component's context menu and selecting \\\"Open File\\\"\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"698 145\",\"key\":162,\"location\":\"-8229.99989302025 2942.549743358351\",\"group\":192},\n{\"label\":\"3) The system can be executed by pressing the start buttons\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"501 102\",\"key\":163,\"location\":\"-10229.99989302025 2793.77674335835\",\"group\":192},\n{\"label\":\"Barrier\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"lValue\"},{\"portId\":\"2in\",\"name\":\"lStatus\"},{\"portId\":\"3in\",\"name\":\"rValue\"},{\"portId\":\"4in\",\"name\":\"rStatus\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"def compute( self : NodeData, name, value ):\\n    in_name_list = self.get_input_name_list()\\n    input_stat = self.get('inputStat', {})\\n\\n    input_stat[name] = True\\n    is_object_ready = all(input_stat[in_name] for in_name in in_name_list)\\n\\n    if is_object_ready:\\n        self.set('inputStat', {})\\n\\n        out_value = {in_name: self.get_input(in_name, None) for in_name in in_name_list}\\n        self.fire_output('out', out_value)\",\"fileTypeName\":\"MakeObject\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":164,\"location\":\"-6099.999893020249 3102.549743358351\",\"group\":192,\"editorPosition\":[2146,2191,674,512]},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":165,\"location\":\"-6148.1038930202485 3418.8917433583497\",\"group\":167},\n{\"label\":\"33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 64\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":166,\"location\":\"-6146.2068930202495 3348.2077433583504\",\"group\":167},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":167,\"location\":\"-6200.0003773952485 3382.54974335835\",\"group\":192},\n{\"label\":\"[\\n  \\\"+\\\",\\n  [\\n    \\\"+\\\",\\n    [\\n      \\\"*\\\",\\n      3,\\n      5\\n    ],\\n    \\\"alpha\\\"\\n  ],\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":168,\"location\":\"-6808.1038930202485 3592.549743358351\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":169},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":169,\"location\":\"-6860.0003773952485 3592.549743358351\",\"group\":192},\n{\"label\":\"[\\n  3,\\n  \\\"*\\\",\\n  5,\\n  \\\"+\\\",\\n  \\\"alpha\\\",\\n  \\\"+\\\",\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 293\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":170,\"location\":\"-7378.1038930202485 3412.549743358351\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":171},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":171,\"location\":\"-7430.0003773952485 3412.549743358351\",\"group\":192},\n{\"label\":\"[\\n  \\\"var\\\",\\n  \\\"=\\\",\\n  3,\\n  \\\"*\\\",\\n  5,\\n  \\\"+\\\",\\n  \\\"alpha\\\",\\n  \\\"+\\\",\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 451\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":172,\"location\":\"-7908.1038930202485 3442.549743358351\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":173},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":173,\"location\":\"-7960.0003773952485 3442.549743358351\",\"group\":192},\n{\"label\":\"[\\n  \\\"var\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 352\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":174,\"location\":\"-7378.1038930202485 2712.549743358351\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":175},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":175,\"location\":\"-7430.0003773952485 2712.549743358351\",\"group\":192},\n{\"label\":\"var\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":176,\"location\":\"-6828.1038930202485 2572.549743358351\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":177},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":177,\"location\":\"-6880.0003773952485 2572.549743358351\",\"group\":192},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":178,\"location\":\"-6148.1038930202485 2850.8917433583497\",\"group\":180},\n{\"label\":\"var\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 68\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":179,\"location\":\"-6146.2068930202495 2778.2077433583504\",\"group\":180},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":180,\"location\":\"-6200.0003773952485 2812.54974335835\",\"group\":192},\n{\"label\":\"Log Result\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"*\"}],\"isFile\":true,\"fileContent\":\"def compute( self : NodeData, name, value ):\\n  if name == 'in':\\n      print(value)\\n\",\"fileTypeName\":\"Component\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":181,\"location\":\"-5309.999893020249 3192.549743358351\",\"group\":192},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":182,\"location\":\"-9989.99989302025 2892.549743358351\",\"group\":192},\n{\"label\":\"2+3*5-(2+20*0.5)+1\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":183,\"location\":\"-9009.99989302025 2892.99074335835\",\"group\":192},\n{\"label\":\"var = 33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"364 72\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":184,\"location\":\"-5309.999893020249 3082.549743358351\",\"group\":192},\n{\"label\":\"Equation Evaluate\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"variable\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = ''\\n        if value['lStatus'] == 'Done' and value['rStatus'] == 'Done':\\n            if value['lValue'] == '' or value['rValue'] == '':\\n                out_value = value['lValue'] or value['rValue']\\n            elif isVariable(value['lValue']):\\n                out_value = f\\\"{value['lValue']} = {value['rValue']}\\\"\\n                var_value = {'id': value['lValue'], 'value': value['rValue']}\\n                self.fire_output('variable', var_value)\\n            elif isVariable(value['rValue']):\\n                out_value = f\\\"{value['rValue']} = {value['lValue']}\\\"\\n                var_value = {'id': value['rValue'], 'value': value['lValue']}\\n                self.fire_output('variable', var_value)\\n            else:\\n                out_value = str(value['lValue'] == value['rValue'])\\n        else:\\n            out_value = value['rStatus'] if value['lStatus'] == 'Done' else value['lStatus']\\n\\n        self.fire_output('out', out_value)\",\"fileTypeName\":\"Component\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":185,\"location\":\"-5729.999893020249 3102.549743358351\",\"group\":192,\"editorPosition\":[3690,1891,610,424]},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"253 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = float('nan')\\n        out_status = 'Done'\\n        try:\\n            if value is None:\\n                out_value = ''\\n            else:\\n                variables = self.get_input('variables', '')\\n                variable_values = getVariableValues(variables)\\n\\n                out_value = evaluateAST(value, variable_values)\\n        except Exception as e:\\n            out_status = f'Syntax error in expression: {e}'\\n\\n        self.fire_output('out', out_value)\\n        self.fire_output('status', out_status)\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":186,\"location\":\"-6630 2930\",\"group\":192},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        # Build the AST tree (recursive function)\\n        out_value = buildAST(value)\\n        self.fire_output('out', out_value)\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":187,\"location\":\"-7169.999893020249 2922.549743358351\",\"editorPosition\":[1270,1836,523,943],\"group\":192},\n{\"label\":\"Equation Split\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"lEq\"},{\"portId\":\"2out\",\"name\":\"rEq\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        i = value.find('=')\\n        if i == -1:\\n            i = len(value)\\n\\n        l_eq = value[:i]\\n        r_eq = value[i+1:]\\n\\n        self.fire_output('lEq', l_eq)\\n        self.fire_output('rEq', r_eq)\",\"fileTypeName\":\"Component\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":188,\"location\":\"-7729.999893020249 3082.549743358351\",\"group\":192},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"254 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        out_value = float('nan')\\n        out_status = 'Done'\\n        try:\\n            if value is None:\\n                out_value = ''\\n            else:\\n                variables = self.get_input('variables', '')\\n                variable_values = getVariableValues(variables)\\n\\n                out_value = evaluateAST(value, variable_values)\\n        except Exception as e:\\n            out_status = f'Syntax error in expression: {e}'\\n\\n        self.fire_output('out', out_value)\\n        self.fire_output('status', out_status)\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":189,\"location\":\"-6630 3190\",\"group\":192,\"editorPosition\":[2441,1906,560,417]},\n{\"label\":\"Equation Tokenizer\",\"category\":\"DataFlow_Component\",\"size\":\"255 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        # Split each line\\n        line_list = value.split('\\\\n')\\n        for line in line_list:\\n            # Tokenize the input equation\\n            regex = r'\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+'\\n            token_list = []\\n            if value:\\n                token_list = [float(token) if token.isdigit() or (token[0] == '-' and token[1:].isdigit()) else token\\n                              for token in re.findall(regex, line)]\\n\\n            self.fire_output('out', token_list)\\n\",\"fileTypeName\":\"Component\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":190,\"location\":\"-8279.99989302025 3082.549743358351\",\"group\":192,\"editorPosition\":[-4464,1910,494,263]},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"def compute(self : NodeData, name, value):\\n    if name == 'in':\\n        # Build the AST tree (recursive function)\\n        out_value = buildAST(value)\\n        self.fire_output('out', out_value)\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/python\",\"iconURL\":\"\",\"key\":191,\"location\":\"-7189.999893020249 3172.549743358351\",\"editorPosition\":[1964,1907,466,193],\"group\":192},\n{\"label\":\"Simple Language Interpreter Model (Python)\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":192,\"location\":\"-10259.99989302025 3059.592237498976\"}\n],\n  \"linkDataArray\": [\n{\"category\":\"DataFlow_Arrow\",\"from\":9,\"to\":11,\"points\":[-599.5380859375,3048.773,-589.5380859375,3048.773,-540,3468.773,-530,3468.773],\"fromPort\":\"1out\",\"toPort\":\"1in\",\"key\":-2},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":15,\"to\":17,\"points\":[-1674.5380859375,2958.773,-1664.5380859375,2958.773,-1640,3318.773,-1630,3318.773],\"key\":-5},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":9,\"to\":19,\"points\":[-599.5380859375,3048.773,-589.5380859375,3048.773,-407.02734375,3058.773,-397.02734375,3058.773],\"key\":-6},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":19,\"to\":21,\"points\":[-7.6484375,3058.773,2.3515625,3058.773,121.896484375,3224.431,131.896484375,3224.431],\"key\":-7},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":19,\"to\":23,\"points\":[-7.6484375,3078.773,2.3515625,3078.773,120,3295.1150000000002,130,3295.1150000000002],\"key\":-8},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":26,\"to\":27,\"points\":[-579.5380859375,2798.773,-569.5380859375,2798.773,-407.02734375,2798.773,-397.02734375,2798.773],\"key\":-10},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":27,\"to\":28,\"points\":[-8.6484375,2798.773,1.3515625,2798.773,121.896484375,2654.431,131.896484375,2654.431],\"key\":-11},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":27,\"to\":29,\"points\":[-8.6484375,2818.773,1.3515625,2818.773,120,2727.1150000000002,130,2727.1150000000002],\"key\":-12},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":26,\"to\":31,\"points\":[-579.5380859375,2798.773,-569.5380859375,2798.773,-560,2448.773,-550,2448.773],\"key\":-14},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":18,\"to\":33,\"points\":[-1137.2138671875,2948.773,-1127.2138671875,2948.773,-1110,2588.773,-1100,2588.773],\"key\":-15},\n{\"category\":\"DataFlow_Arrow\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":18,\"to\":35,\"points\":[-1137.2138671875,2968.773,-1127.2138671875,2968.773,-1110,3288.773,-1100,3288.773],\"key\":-16},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":27,\"to\":58,\"points\":[-8.6484375,2798.773,1.3515625,2798.773,134.6484375,2948.773,144.6484375,2948.773],\"key\":-17},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"2in\",\"from\":27,\"to\":58,\"points\":[-8.6484375,2818.773,1.3515625,2818.773,134.6484375,2968.773,144.6484375,2968.773],\"key\":-18},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"3in\",\"from\":19,\"to\":58,\"points\":[-7.6484375,3058.773,2.3515625,3058.773,134.6484375,2988.773,144.6484375,2988.773],\"key\":-19},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"4in\",\"from\":19,\"to\":58,\"points\":[-7.6484375,3078.773,2.3515625,3078.773,134.6484375,3008.773,144.6484375,3008.773],\"key\":-20},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":18,\"to\":9,\"points\":[-1137.2138671875,2968.773,-1127.2138671875,2968.773,-921.896484375,3048.773,-911.896484375,3048.773],\"key\":-21},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":18,\"to\":26,\"points\":[-1137.2138671875,2948.773,-1127.2138671875,2948.773,-901.896484375,2798.773,-891.896484375,2798.773],\"key\":-22},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":25,\"to\":34,\"points\":[899.02734375,2968.773,909.02734375,2968.773,958.103515625,2958.773,968.103515625,2958.773],\"key\":-23},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":50,\"to\":15,\"points\":[-2090.5380859375,2769.214,-2080.5380859375,2769.214,-2011.896484375,2958.773,-2001.896484375,2958.773],\"key\":-31},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":37,\"to\":36,\"points\":[1820,2078.9896159213067,1653.5,2078.172970537314],\"key\":-32,\"color\":\"YellowGreen\"},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":37,\"to\":44,\"points\":[2232,2080,3100,2080],\"key\":-33,\"color\":\"YellowGreen\"},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"label\":\"log\",\"from\":25,\"to\":45,\"points\":[899.02734375,2968.773,909.02734375,2968.773,958.103515625,3068.773,968.103515625,3068.773],\"key\":-34},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":58,\"to\":25,\"points\":[490.4619140625,2978.773,500.4619140625,2978.773,538.103515625,2978.773,548.103515625,2978.773],\"key\":-35},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":126,\"to\":78,\"points\":[4980,1949.5035472717655,4879.5,1949.2476831733677],\"key\":-36,\"color\":\"YellowGreen\"},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":15,\"to\":18,\"points\":[-1674.5380859375,2958.773,-1664.5380859375,2958.773,-1461.896484375,2958.773,-1451.896484375,2958.773],\"key\":-44},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":122,\"to\":15,\"points\":[-2090.5380859375,3045.398,-2080.5380859375,3045.398,-2042.896484375,2959.014,-2011.896484375,2958.773,-2001.896484375,2958.773],\"key\":-46},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":92,\"to\":88,\"points\":[1289.4619140625,3188.773,1299.4619140625,3188.773,1340,3191.543,1330,3771.543,-2790,3768.773,-2790,2438.773,-2731.896484375,2428.773,-2721.896484375,2428.773],\"key\":-42},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":27,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2040,2428.773,-2040,3621.543,-640,3621.543,-640,3101.543,-480,3101.543,-480,2818.773,-407.02734375,2818.773,-397.02734375,2818.773],\"key\":-43},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":19,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2050,2448.773,-2050,3631.543,-630,3631.543,-630,3111.543,-470,3111.543,-470,3078.773,-407.02734375,3078.773,-397.02734375,3078.773],\"key\":-47},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":51,\"to\":96,\"points\":[-3559.5380859375,2768.773,-3549.5380859375,2768.773,-3540,2780,-3390,2780,-3390,2430,-3291.896484375,2430,-3281.896484375,2430],\"key\":-48},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":51,\"to\":50,\"points\":[-3559.5380859375,2768.773,-3549.5380859375,2768.773,-2741.896484375,2769.214,-2731.896484375,2769.214],\"key\":-49},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":118,\"to\":96,\"points\":[-3559.5380859375,2858.773,-3549.5380859375,2858.773,-3530,2870,-3380,2870,-3380,2440,-3291.896484375,2430,-3281.896484375,2430],\"key\":-45},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":118,\"to\":122,\"points\":[-3559.5380859375,2858.773,-3549.5380859375,2858.773,-3120,2861.543,-2770,2861.543,-2770,2981.543,-2741.896484375,3045.398,-2731.896484375,3045.398],\"key\":-50},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":25,\"to\":92,\"points\":[899.02734375,2988.773,909.02734375,2988.773,912.97265625,3178.773,922.97265625,3178.773],\"key\":-41},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":92,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2060,2458.773,-2060,3758.773,860,3761.543,860,3201.543,912.97265625,3198.773,922.97265625,3198.773],\"key\":-51},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":96,\"to\":88,\"points\":[-2942.5380859375,2430,-2932.5380859375,2430,-2731.896484375,2428.773,-2721.896484375,2428.773],\"key\":-52},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":110,\"to\":109,\"points\":[3199.4619140625,3080,3209.4619140625,3080,3248.103515625,3080,3258.103515625,3080],\"key\":-54},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"Feature\",\"toPort\":\"Feature\",\"from\":114,\"to\":112,\"points\":[4018,1729.9996750396547,4080.000136589022,1729.9995558231706,4090.000136589022,1729.9995558231706],\"key\":-55,\"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":139,\"to\":145,\"points\":[-9262.53797895775,2543.77674335835,-9252.53797895775,2543.77674335835,-9051.89637739525,2542.549743358351,-9041.89637739525,2542.549743358351],\"key\":-56},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":145,\"to\":144,\"points\":[-8390.53797895775,2552.549743358351,-8380.53797895775,2552.549743358351,-8379.99989302025,2572.549743358351,-8379.99989302025,3872.549743358351,-5459.999893020249,3875.3197433583514,-5460,3320,-5397.02734375,3320,-5387.02734375,3320],\"key\":-57},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":185,\"to\":144,\"points\":[-5410.972549270249,3112.549743358351,-5400.972549270249,3112.549743358351,-5397.02734375,3300,-5387.02734375,3300],\"key\":-58},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":148,\"to\":146,\"points\":[-9879.53797895775,2972.549743358351,-9869.53797895775,2972.549743358351,-9439.99989302025,2975.3197433583514,-9089.99989302025,2975.3197433583514,-9089.99989302025,3095.3197433583514,-9061.89637739525,3115.174743358351,-9051.89637739525,3115.174743358351],\"key\":-59},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":148,\"to\":139,\"points\":[-9879.53797895775,2972.549743358351,-9869.53797895775,2972.549743358351,-9849.99989302025,2983.776743358351,-9699.99989302025,2983.776743358351,-9699.99989302025,2553.776743358351,-9611.89637739525,2543.77674335835,-9601.89637739525,2543.77674335835],\"key\":-60},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":182,\"to\":183,\"points\":[-9879.53797895775,2882.549743358351,-9869.53797895775,2882.549743358351,-9061.89637739525,2882.99074335835,-9051.89637739525,2882.99074335835],\"key\":-61},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":182,\"to\":139,\"points\":[-9879.53797895775,2882.549743358351,-9869.53797895775,2882.549743358351,-9859.99989302025,2893.776743358351,-9709.99989302025,2893.776743358351,-9709.99989302025,2543.776743358351,-9611.89637739525,2543.77674335835,-9601.89637739525,2543.77674335835],\"key\":-62},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":145,\"to\":189,\"points\":[-8390.53797895775,2552.549743358351,-8380.53797895775,2552.549743358351,-8369.99989302025,2562.549743358351,-8369.99989302025,3745.3197433583514,-6949.999893020249,3745.3197433583514,-6949.999893020249,3225.3197433583514,-6789.999893020249,3225.3197433583514,-6790,3200,-6717.02734375,3200,-6707.02734375,3200],\"key\":-63},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":145,\"to\":186,\"points\":[-8390.53797895775,2552.549743358351,-8380.53797895775,2552.549743358351,-8359.99989302025,2542.549743358351,-8359.99989302025,3735.3197433583514,-6959.999893020249,3735.3197433583514,-6959.999893020249,3215.3197433583514,-6799.999893020249,3215.3197433583514,-6800,2940,-6717.02734375,2940,-6707.02734375,2940],\"key\":-64},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":144,\"to\":145,\"points\":[-5020.5380859375,3310,-5010.5380859375,3310,-4980,3310,-4989.999893020249,3885.3197433583514,-9109.99989302025,3882.549743358351,-9109.99989302025,2552.549743358351,-9041.89637739525,2552.549743358351,-9031.89637739525,2552.549743358351],\"key\":-65},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":146,\"to\":190,\"points\":[-8400.53797895775,3125.174743358351,-8390.53797895775,3125.174743358351,-8362.89637739525,3072.790743358351,-8321.89637739525,3082.549743358351,-8311.89637739525,3082.549743358351],\"key\":-66},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":190,\"to\":188,\"points\":[-7984.537978957749,3082.549743358351,-7974.537978957749,3082.549743358351,-7771.896377395249,3082.549743358351,-7761.896377395249,3082.549743358351],\"key\":-67},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":164,\"to\":185,\"points\":[-5819.537978957749,3102.549743358351,-5809.537978957749,3102.549743358351,-5771.896377395249,3102.549743358351,-5761.896377395249,3102.549743358351],\"key\":-68},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"label\":\"log\",\"from\":185,\"to\":181,\"points\":[-5410.972549270249,3092.549743358351,-5400.972549270249,3092.549743358351,-5351.896377395249,3192.549743358351,-5341.896377395249,3192.549743358351],\"key\":-69},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":183,\"to\":190,\"points\":[-8400.53797895775,2892.99074335835,-8390.53797895775,2892.99074335835,-8321.89637739525,3082.549743358351,-8311.89637739525,3082.549743358351],\"key\":-70},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":185,\"to\":184,\"points\":[-5410.972549270249,3092.549743358351,-5400.972549270249,3092.549743358351,-5351.896377395249,3082.549743358351,-5341.896377395249,3082.549743358351],\"key\":-71},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":188,\"to\":187,\"points\":[-7447.213760207749,3072.549743358351,-7437.213760207749,3072.549743358351,-7211.896377395249,2922.549743358351,-7201.896377395249,2922.549743358351],\"key\":-72},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":188,\"to\":191,\"points\":[-7447.213760207749,3092.549743358351,-7437.213760207749,3092.549743358351,-7231.896377395249,3172.549743358351,-7221.896377395249,3172.549743358351],\"key\":-73},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"4in\",\"from\":189,\"to\":164,\"points\":[-6317.6484375,3200,-6307.6484375,3200,-6175.351455520249,3132.549743358351,-6165.351455520249,3132.549743358351],\"key\":-74},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"3in\",\"from\":189,\"to\":164,\"points\":[-6317.6484375,3180,-6307.6484375,3180,-6175.351455520249,3112.549743358351,-6165.351455520249,3112.549743358351],\"key\":-75},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"2in\",\"from\":186,\"to\":164,\"points\":[-6318.6484375,2940,-6308.6484375,2940,-6175.351455520249,3092.549743358351,-6165.351455520249,3092.549743358351],\"key\":-76},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":186,\"to\":164,\"points\":[-6318.6484375,2920,-6308.6484375,2920,-6175.351455520249,3072.549743358351,-6165.351455520249,3072.549743358351],\"key\":-77},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":188,\"to\":170,\"points\":[-7447.213760207749,3092.549743358351,-7437.213760207749,3092.549743358351,-7420.0003773952485,3412.549743358351,-7410.0003773952485,3412.549743358351],\"key\":-78},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":188,\"to\":174,\"points\":[-7447.213760207749,3072.549743358351,-7437.213760207749,3072.549743358351,-7420.0003773952485,2712.549743358351,-7410.0003773952485,2712.549743358351],\"key\":-79},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":187,\"to\":176,\"points\":[-6889.537978957749,2922.549743358351,-6879.537978957749,2922.549743358351,-6870.0003773952485,2572.549743358351,-6860.0003773952485,2572.549743358351],\"key\":-80},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":186,\"to\":178,\"points\":[-6318.6484375,2940,-6308.6484375,2940,-6190.0003773952485,2850.8917433583497,-6180.0003773952485,2850.8917433583497],\"key\":-81},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":186,\"to\":179,\"points\":[-6318.6484375,2920,-6308.6484375,2920,-6188.1033773952495,2778.2077433583504,-6178.1033773952495,2778.2077433583504],\"key\":-82},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":187,\"to\":186,\"points\":[-6889.537978957749,2922.549743358351,-6879.537978957749,2922.549743358351,-6717.02734375,2920,-6707.02734375,2920],\"key\":-83},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":189,\"to\":165,\"points\":[-6317.6484375,3200,-6307.6484375,3200,-6190.0003773952485,3418.8917433583497,-6180.0003773952485,3418.8917433583497],\"key\":-84},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":189,\"to\":166,\"points\":[-6317.6484375,3180,-6307.6484375,3180,-6188.1033773952495,3348.2077433583504,-6178.1033773952495,3348.2077433583504],\"key\":-85},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":191,\"to\":189,\"points\":[-6909.537978957749,3172.549743358351,-6899.537978957749,3172.549743358351,-6717.02734375,3180,-6707.02734375,3180],\"key\":-86},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":190,\"to\":172,\"points\":[-7984.537978957749,3082.549743358351,-7974.537978957749,3082.549743358351,-7950.0003773952485,3442.549743358351,-7940.0003773952485,3442.549743358351],\"key\":-87},\n{\"category\":\"DataFlow_Log\",\"from\":191,\"to\":168,\"points\":[-6909.537978957749,3172.549743358351,-6899.537978957749,3172.549743358351,-6850.0003773952485,3592.549743358351,-6840.0003773952485,3592.549743358351],\"fromPort\":\"1out\",\"toPort\":\"1in\",\"key\":-88}\n]}"
}