{
  "class": "GraphLinksModel",
  "copiesArrays": true,
  "copiesArrayObjects": true,
  "copiesKey": false,
  "linkKeyProperty": "key",
  "linkFromPortIdProperty": "fromPort",
  "linkToPortIdProperty": "toPort",
  "nodeDataArray": [
    {
      "label": "Graph Info",
      "category": "Hierarchy_GraphInfo",
      "size": "180 80",
      "props_": [
        {
          "name": "Name",
          "value": "label@6",
          "valueChanged": true
        },
        {
          "name": "Version",
          "value": "1.0"
        },
        {
          "name": "Date",
          "value": "20/01/2024"
        },
        {
          "name": "Path",
          "value": "/fileServer/02/41.json"
        },
        {
          "name": "Authors",
          "value": "Antonello",
          "valueChanged": true
        }
      ],
      "key": 0,
      "location": "390 -70"
    },
    {
      "label": "Model",
      "size": "180 60",
      "category": "Hierarchy_Model",
      "isFile": true,
      "fileType": "text/json",
      "isSystem": "$GraphModel$",
      "key": 2,
      "location": "130 -70"
    },
    {
      "label": "Selection",
      "size": "180 60",
      "category": "Hierarchy_Selection",
      "isFile": true,
      "fileType": "text/json",
      "isSystem": "$GraphSelection$",
      "key": 4,
      "location": "130 20"
    },
    {
      "label": "Test DataFlow & Code Generation",
      "category": "TextLabels_Size6",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "5269 240",
      "key": 6,
      "location": "660 -10"
    },
    {
      "label": "2+3*5-(2+20*0.5)+1=z",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "569 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 7,
      "location": "-2190 2846.316",
      "group": 36
    },
    {
      "label": "Equation Parser",
      "category": "DataFlow_Component",
      "size": "240 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  // Build the AST tree (recursive function)\n  const outValue = buildAST( value );\n  \n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n}\n\nfunction buildAST( tokenList ) {\n  if( tokenList.length == 0 ) {\n    return( null );\n  } else if( tokenList.length == 1 ) {\n    return( tokenList[0] );\n  }\n\n  // Find the index of the lowest precedence operator\n  let index = -1;\n  let minPrecedence = Infinity;\n  let parenthesis = 0;\n  // Loop over all tokenList\n  for( let i = 0; i < tokenList.length; ++i ) {\n    if( tokenList[i] == '(' ) {\n      parenthesis++;\n    } else if( tokenList[i] == ')' ) {\n      parenthesis--;\n    } else if( parenthesis === 0 ) {\n      // Compute precedences\n      const operator = tokenList[i];\n      let precedence = 0;\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\n        precedence = 1;\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\n        precedence = 2;\n      } else {\n        precedence = Infinity;\n      }\n      \n      if( precedence <= minPrecedence ) {\n        minPrecedence = precedence;\n        index = i;\n      }\n    }\n  }\n\n  // Handle subexpressions inside parentheses\n  if( index === -1 ) {\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\n  }\n\n  const result = [\n    tokenList[index],\n    buildAST( tokenList.slice( 0, index ) ),\n    buildAST( tokenList.slice( index+1 ))\n  ];\n  return( result );\n}\n",
      "fileTypeName": "EquationParser",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 9,
      "location": "-380 3046.316",
      "editorPosition": [
        1270,
        1836,
        523,
        943
      ],
      "group": 36
    },
    {
      "label": "[\n  \"+\",\n  [\n    \"*\",\n    3,\n    5\n  ],\n  10\n]",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "125 511",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 11,
      "location": "-18.103515625 3423.158",
      "font": "17px sans-serif",
      "labelFont": "17px sans-serif",
      "group": 55
    },
    {
      "label": "",
      "category": "DataFlow_Start",
      "size": "80 80",
      "buttons_": [
        {
          "name": "Start",
          "checked": false
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "key": 13,
      "location": "-2400 2846.316",
      "group": 36
    },
    {
      "label": "DataFlow Engine",
      "color": "orange",
      "size": "420 140",
      "category": "Hierarchy_CodeInFile",
      "isFile": true,
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "fileURL": "lib/DataFlowEngine/1.5/DataFlowEngine.js",
      "key": 8,
      "location": "4150 950",
      "editorPosition": [
        1087,
        1811,
        666,
        1123
      ]
    },
    {
      "label": "New Engine Instance \n         onLoad",
      "color": "orange",
      "size": "430 80",
      "category": "Hierarchy_CodeInGraph",
      "isFile": true,
      "fileContent": "DataFlowEngine.getInstance();",
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 10,
      "location": "4150 1110",
      "isIncludeScript": true
    },
    {
      "label": "Engine Control",
      "color": "DarkKhaki",
      "size": "416 110",
      "category": "Hierarchy_CodeInGraph",
      "isFile": true,
      "fileContent": "<div style=\"display:grid\">\n  <button type=\"Button\" onclick=\"graphData.dfe.loadModel();\" style=\"font-size: 24px;\">Load Model</button>\n  <button type=\"Button\" onclick=\"graphData.dfe.clearInstanceData();\" style=\"font-size: 24px;\">Clear Instance Data</button>\n  <button type=\"Button\" onclick=\"graphData.dfe.doPause();\" style=\"font-size: 24px;\">Pause</button>\n  <button type=\"Button\" onclick=\"graphData.dfe.doContinue();\" style=\"font-size: 24px;\">Continue</button>\n  <button type=\"Button\" onclick=\"graphData.dfe.setLogOn();\" style=\"font-size: 24px;\">Set Log On</button>\n  <button type=\"Button\" onclick=\"graphData.dfe.setLogOff();\" style=\"font-size: 24px;\">Set Log Off</button>\n</div>",
      "fileTypeName": "Web Page",
      "fileType": "application/html",
      "key": 12,
      "location": "4160 1270",
      "isLocalDiv": true,
      "editorPosition": [
        1459,
        20,
        345,
        245
      ]
    },
    {
      "label": "Equation Tokenizer",
      "category": "DataFlow_Component",
      "size": "255 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  // Tokenize the input equation\n  const regex = /\\d+(\\.\\d+)?|[\\+\\-\\*\\/\\(\\)]|[=a-zA-Z]/g;\n  const tokenList = value.match( regex ).map( token => {\n    return( isNaN( token ) ? token : parseFloat( token ) );\n  });\n  \n  graphData.dfe.fireOutput( nodeData, 'out', tokenList );\n}",
      "fileTypeName": "Component",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 15,
      "location": "-1490 2956.316",
      "group": 36
    },
    {
      "label": "[\n  \"y\",\n  \"=\",\n  3,\n  \"*\",\n  5,\n  \"+\",\n  10\n]",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "114 451",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 17,
      "location": "-1118.103515625 3310",
      "font": "17px sans-serif",
      "labelFont": "17px sans-serif",
      "group": 53
    },
    {
      "label": "Equation Compute",
      "category": "DataFlow_Component",
      "size": "254 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        },
        {
          "portId": "2out",
          "name": "status"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  let outValue = NaN;\n  let outStatus = 'Done';\n  try {\n    if( value == null ) {\n      outValue = '';\n    } else {\n      outValue = evaluateAST( value );\n    }\n  } catch( e ) {\n    outStatus = `Syntax error in expression: ${e}`;\n  }\n  \n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\n}\n\nfunction evaluateAST( ast ) {\n  if( RegExp( /^[a-z]/i ).test( ast ) ) {\n    return( ast );\n  } else if( typeof( ast ) === 'number' ) {\n    // Base case: if the node is a number, return it.\n    return( ast );\n  }\n\n  // Recursive case: evaluate the left and right operands.\n  const left = evaluateAST( ast[1] );\n  const right = evaluateAST( ast[2] );\n\n  // Compute the result based on the operator.\n  switch( ast[0] ) {\n    case '+':\n      return( left + right );\n    case '-':\n      return( left - right );\n    case '*':\n      return( left * right );\n    case '/':\n      return( left / right );\n    default:\n      throw new Error( 'Unknown operator: ' + ast[0] );\n  }\n}",
      "fileTypeName": "EquationCompute",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 19,
      "location": "160 3046.016",
      "group": 36
    },
    {
      "label": "25",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "247 64",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 21,
      "location": "641.896484375 3219.316",
      "group": 56
    },
    {
      "label": "Done",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "617 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 23,
      "location": "640 3290",
      "group": 56
    },
    {
      "label": "Equation Split",
      "category": "DataFlow_Component",
      "size": "240 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "lEq"
        },
        {
          "portId": "2out",
          "name": "rEq"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  let i = value.indexOf( '=' );\n  if( i == -1 ) {\n    i = value.length;\n  }\n  \n  const lEq = value.slice( 0, i );\n  const rEq = value.slice( i+1 );\n  \n  graphData.dfe.fireOutput( nodeData, 'lEq', lEq );\n  graphData.dfe.fireOutput( nodeData, 'rEq', rEq );\n}",
      "fileTypeName": "Component",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 18,
      "location": "-940 2955.916",
      "group": 36
    },
    {
      "label": "Equation Parser",
      "category": "DataFlow_Component",
      "size": "240 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  // Build the AST tree (recursive function)\n  const outValue = buildAST( value );\n  \n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n}\n\nfunction buildAST( tokenList ) {\n  if( tokenList.length == 0 ) {\n    return( null );\n  } else if( tokenList.length == 1 ) {\n    return( tokenList[0] );\n  }\n\n  // Find the index of the lowest precedence operator\n  let index = -1;\n  let minPrecedence = Infinity;\n  let parenthesis = 0;\n  // Loop over all tokenList\n  for( let i = 0; i < tokenList.length; ++i ) {\n    if( tokenList[i] == '(' ) {\n      parenthesis++;\n    } else if( tokenList[i] == ')' ) {\n      parenthesis--;\n    } else if( parenthesis === 0 ) {\n      // Compute precedences\n      const operator = tokenList[i];\n      let precedence = 0;\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\n        precedence = 1;\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\n        precedence = 2;\n      } else {\n        precedence = Infinity;\n      }\n      \n      if( precedence <= minPrecedence ) {\n        minPrecedence = precedence;\n        index = i;\n      }\n    }\n  }\n\n  // Handle subexpressions inside parentheses\n  if( index === -1 ) {\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\n  }\n\n  const result = [\n    tokenList[index],\n    buildAST( tokenList.slice( 0, index ) ),\n    buildAST( tokenList.slice( index+1 ))\n  ];\n  return( result );\n}\n",
      "fileTypeName": "EquationParser",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 26,
      "location": "-380 2886.316",
      "editorPosition": [
        1270,
        1836,
        523,
        943
      ],
      "group": 36
    },
    {
      "label": "Equation Compute",
      "category": "DataFlow_Component",
      "size": "253 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        },
        {
          "portId": "2out",
          "name": "status"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  let outValue = NaN;\n  let outStatus = 'Done';\n  try {\n    if( value == null ) {\n      outValue = '';\n    } else {\n      outValue = evaluateAST( value );\n    }\n  } catch( e ) {\n    outStatus = `Syntax error in expression: ${e}`;\n  }\n  \n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\n}\n\nfunction evaluateAST( ast ) {\n  if( RegExp( /^[a-z]/i ).test( ast ) ) {\n    return( ast );\n  } else if( typeof( ast ) === 'number' ) {\n    // Base case: if the node is a number, return it.\n    return( ast );\n  }\n\n  // Recursive case: evaluate the left and right operands.\n  const left = evaluateAST( ast[1] );\n  const right = evaluateAST( ast[2] );\n\n  // Compute the result based on the operator.\n  switch( ast[0] ) {\n    case '+':\n      return( left + right );\n    case '-':\n      return( left - right );\n    case '*':\n      return( left * right );\n    case '/':\n      return( left / right );\n    default:\n      throw new Error( 'Unknown operator: ' + ast[0] );\n  }\n}",
      "fileTypeName": "EquationCompute",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 27,
      "location": "160 2885.8160000000003",
      "group": 36
    },
    {
      "label": "y",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "247 68",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 28,
      "location": "641.896484375 2737.316",
      "group": 48
    },
    {
      "label": "Done",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "617 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 29,
      "location": "640 2810",
      "group": 48
    },
    {
      "label": "y",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "125 511",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 31,
      "location": "-38.103515625 2583.158",
      "font": "17px sans-serif",
      "labelFont": "17px sans-serif",
      "group": 49
    },
    {
      "label": "[\n  \"y\"\n]",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "114 352",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 33,
      "location": "-590 2681.316",
      "font": "17px sans-serif",
      "labelFont": "17px sans-serif",
      "group": 52
    },
    {
      "label": "[\n  3,\n  \"*\",\n  5,\n  \"+\",\n  10\n]",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "114 293",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 35,
      "location": "-588.103515625 3281.316",
      "font": "17px sans-serif",
      "labelFont": "17px sans-serif",
      "group": 54
    },
    {
      "label": "Equation Compare",
      "category": "DataFlow_Component",
      "size": "249 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "",
          "valueChanged": true
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nif( name == 'in' ) {\n  let outValue = '';\n  if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\n    if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\n      outValue = value.lValue || value.rValue;\n    } else if( isVariable( value.lValue  ) ) {\n      outValue = `${value.lValue} = ${value.rValue}`;\n    } else if( isVariable( value.rValue ) ) {\n      outValue = `${value.rValue} = ${value.lValue}`;\n    } else {\n      outValue = String( value.lValue == value.rValue );\n    }\n  } else {\n    outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\n  }\n  \n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n}\n\nfunction isVariable( str ) {\n  return( RegExp( /^[a-z]/i ).test( str ) );\n}",
      "fileTypeName": "Component",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 25,
      "location": "1060 2973.158",
      "group": 36,
      "editorPosition": [
        2861,
        2205,
        778,
        494
      ]
    },
    {
      "label": "y = 25",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "242 72",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 34,
      "location": "1450 2967.158",
      "group": 36
    },
    {
      "label": "2+3*5-(2+20*0.5)+1=10-4",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "569 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 38,
      "location": "-2190 2926.216",
      "group": 36
    },
    {
      "label": "",
      "category": "DataFlow_Start",
      "size": "80 80",
      "buttons_": [
        {
          "name": "Start",
          "checked": false
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "key": 39,
      "location": "-2400 2926.316",
      "group": 36
    },
    {
      "label": "2+3*5-(2+20*0.5)+1=10-1",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "569 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 42,
      "location": "-2190 3006.216",
      "group": 36
    },
    {
      "label": "",
      "category": "DataFlow_Start",
      "size": "80 80",
      "buttons_": [
        {
          "name": "Start",
          "checked": false
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "key": 43,
      "location": "-2400 3006.316",
      "group": 36
    },
    {
      "label": "y=3*5+10",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "569 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 46,
      "location": "-2190 3086.316",
      "group": 36
    },
    {
      "label": "",
      "category": "DataFlow_Start",
      "size": "80 80",
      "buttons_": [
        {
          "name": "Start",
          "checked": false
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "key": 47,
      "location": "-2400 3086.316",
      "group": 36
    },
    {
      "label": "2+3*5-(2+20*0.5)+1",
      "category": "DataFlow_Message",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "569 60",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "doCompute": "DataFlow_Message",
      "key": 50,
      "location": "-2190 2766.316",
      "group": 36
    },
    {
      "label": "",
      "category": "DataFlow_Start",
      "size": "80 80",
      "buttons_": [
        {
          "name": "Start",
          "checked": false
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "key": 51,
      "location": "-2400 2766.316",
      "group": 36
    },
    {
      "label": "Equation Solver Model",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 36,
      "location": "-2450 2979.999796875"
    },
    {
      "label": "Executor: [Execution...Done]",
      "category": "CodeFlow_Button",
      "color": "YellowGreen",
      "size": "412 120",
      "buttons_": [
        {
          "name": "Generate",
          "checked": false
        },
        {
          "name": "Execute",
          "checked": true
        }
      ],
      "props_": [],
      "isFile": true,
      "fileContent": "var event, obj, nodeData;\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\n//console.log( 'Button Label: '+obj.data.name );\n//console.log( 'Button Status: '+obj.data.checked );\n\n// Generation Instance Data\nconst gen = getGenInfo( nodeData );\n\nswitch( obj.data.name ) {\n  \n  case 'Generate':\n    setNodeDataField( nodeData, 'label', 'Generator: [Generating...]' );\n    const onGenerated = function( source, msg ) {\n      if( msg.startsWith( 'Success:' ) ) {\n        // Set target component source\n        setNodeDataField( gen.targetData.key, 'fileContent', source );\n      }\n      // Update generator status\n      setNodeDataField( nodeData, 'label', 'Generator: [Generation...Done]\\n'+msg );\n    };\n    \n    if( gen.groupKey != null && gen.targetData ) {\n      generationRoot( gen, onGenerated );\n    } else {\n      alert( 'Generation Components needs to have 2 fan out nodes:\\n'+\n           '- Group (a group with a model, Group_BasicGroup),\\n'+\n           '- Code (target source component, Hierarchy_CodeInGraph)' );\n    }\n    break;\n  case 'Execute':\n    setNodeDataField( nodeData, 'label', 'Executor: [Executing...]' );\n    executeCode( gen );\n    setNodeDataField( nodeData, 'label', 'Executor: [Execution...Done]' );\n    break;\n}\n\nfunction getGenInfo( nodeData ) {\n  // Generation Instance Data\n  const gen = {\n    name: 'GenDFE 1.3',  // Code generator name and version\n    groupKey: null,       // Group node key containing the Model to be generated\n    targetData: null,     // Target node to store generated code\n    me: null,             // ModelExplorer\n    modelId: 'main',      // Model Id\n  };\n  \n  // Initialize generation info\n  const g = getMainGraph();\n  // The model is the source of the WorkSpace (as found in the xx.json file)\n  // it is in string form with full content\n  const model = g.getJSONModel();\n  // An alternative is to put in model the full source of the WorkSpace file\n  // by reading it in text form from the server directory: .../xx/yy.json\n  \n  // Initialize ModelExplorer with full model\n  gen.me = new ModelExplorer();\n  gen.me.setJSONModel( gen.modelId, model );\n  \n  // Use Model to Code Generate\n  const dataList = gen.me.getNodeListFanOutByNodeKey( gen.modelId, nodeData.key );\n  // If at least a node has been found\n  if( dataList && dataList.length ) {\n    for( const data of dataList ) {\n      if( data.category.startsWith( 'Group_' ) ) {\n        gen.groupKey = data.key;\n      } else if( data.category.startsWith( 'Hierarchy_CodeInGraph' ) ) {\n        gen.targetData = data;\n      }\n    }\n  }\n  return( gen );\n}\nfunction executeCode( gen ) {\n  console.log( 'Executing Generated Code...' );\n  \n  const source = gen.targetData.fileContent;\n  eval( source );\n  console.log( 'Execution Done.' );\n}",
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 37,
      "location": "1820 2220",
      "editorPosition": [
        2562,
        1007,
        804,
        1305
      ]
    },
    {
      "label": "TargetCode.js",
      "color": "orange",
      "size": "211 124",
      "category": "Hierarchy_CodeInGraph",
      "isFile": true,
      "fileContent": "/*\n * This file is code generated by GenDFE 1.0\n *\n * Generated on Sun, 21 Jan 2024 10:50:20 GMT\n */\n\n/********************\n * Node Functions\n ********************/\n// System function for reading properties\nfunction nodeData_getProperty( name, defaultValue ) {\n  // NOTE: this function access both nodeData fields and properties\n  if( this.nd_[name] != undefined ) {\n    return( this.nd_[name] );\n  } else if( this.nd_.props_[name] != undefined ) {\n    return( this.nd_.props_[name] );\n  } else {\n    return( defaultValue );\n  }\n}\n// System function for reading input\nfunction nodeData_getInput( name, defaultValue ) {\n  if( this.in_[name] == undefined ) {\n    this.in_[name] = defaultValue;\n  }\n  return( this.in_[name] );\n}\n// System function for storing access\nfunction nodeData_setInput( name, value ) {\n  this.in_[name] = value;\n}\n// System function for instance data access\nfunction nodeData_get( name, defaultValue ) {\n  if( this.st_[name] == undefined ) {\n    this.st_[name] = defaultValue;\n  }\n  return( this.st_[name] );\n}\n// System function for firing inputs\nfunction nodeData_fireInput( name, value ) {\n  this.setInput( name, value );\n  this.doCompute( name, value );\n}\n\n/********************\n * Model Functions\n ********************/\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\nconst nodeData_7 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: '2+3*5-(2+20*0.5)+1=z',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_15.setInput( 'in', value );\n      nodeData_15.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Component] Equation Parser\nconst nodeData_9 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Parser',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_19.setInput( 'in', value );\n      nodeData_19.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: EquationParser,\n};\n// Node Info: [DataFlow_Component] Equation Tokenizer\nconst nodeData_15 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Tokenizer',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_18.setInput( 'in', value );\n      nodeData_18.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: compute_15,\n};\n// Node Info: [DataFlow_Component] Equation Compute\nconst nodeData_19 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Compute',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_58.setInput( 'rValue', value );\n      nodeData_58.doCompute( 'rValue', value );\n    } else if( name == 'status' ) {\n      // Store new input\n      nodeData_58.setInput( 'rStatus', value );\n      nodeData_58.doCompute( 'rStatus', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: EquationCompute,\n};\n// Node Info: [DataFlow_Component] Equation Split\nconst nodeData_18 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Split',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'lEq' ) {\n      // Store new input\n      nodeData_26.setInput( 'in', value );\n      nodeData_26.doCompute( 'in', value );\n    } else if( name == 'rEq' ) {\n      // Store new input\n      nodeData_9.setInput( 'in', value );\n      nodeData_9.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: compute_18,\n};\n// Node Info: [DataFlow_Component] Equation Parser\nconst nodeData_26 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Parser',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_27.setInput( 'in', value );\n      nodeData_27.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: EquationParser,\n};\n// Node Info: [DataFlow_Component] Equation Compute\nconst nodeData_27 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Compute',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_58.setInput( 'lValue', value );\n      nodeData_58.doCompute( 'lValue', value );\n    } else if( name == 'status' ) {\n      // Store new input\n      nodeData_58.setInput( 'lStatus', value );\n      nodeData_58.doCompute( 'lStatus', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: EquationCompute,\n};\n// Node Info: [DataFlow_Component] Equation Compare\nconst nodeData_25 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Equation Compare',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_34.setInput( 'in', value );\n      nodeData_34.doCompute( 'in', value );\n      // Store new input\n      nodeData_45.setInput( 'in', value );\n      nodeData_45.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: compute_25,\n};\n// Node Info: [DataFlow_Message] y = 25\nconst nodeData_34 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'y = 25',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\nconst nodeData_38 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: '2+3*5-(2+20*0.5)+1=10-4',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_15.setInput( 'in', value );\n      nodeData_15.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\nconst nodeData_42 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: '2+3*5-(2+20*0.5)+1=10-1',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_15.setInput( 'in', value );\n      nodeData_15.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Message] y=3*5+10\nconst nodeData_46 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'y=3*5+10',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_15.setInput( 'in', value );\n      nodeData_15.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\nconst nodeData_50 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: '2+3*5-(2+20*0.5)+1',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_15.setInput( 'in', value );\n      nodeData_15.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: DataFlow_Message,\n};\n// Node Info: [DataFlow_Component] Log Result\nconst nodeData_45 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Log Result',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: compute_45,\n};\n// Node Info: [DataFlow_Component] Barrier\nconst nodeData_58 = {\n  in_: {},     // Input\n  st_: {},     // Storage\n  nd_: { // Properties\n    label: 'Barrier',\n    props_: {}\n  },\n  out_: {},     // Output\n  fireOutput: function ( name, value ) {\n    if( name == 'out' ) {\n      // Store new input\n      nodeData_25.setInput( 'in', value );\n      nodeData_25.doCompute( 'in', value );\n    }\n  },\n  getProperty: nodeData_getProperty,\n  getInput: nodeData_getInput,\n  setInput: nodeData_setInput,\n  fireInput: nodeData_fireInput,\n  get: nodeData_get,\n  doCompute: MakeObject,\n};\n\n/********************\n * Compute Functions\n ********************/\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\nfunction DataFlow_Message( name, value ) {\n  \n  if( value == undefined ) {\n    value = this.getProperty( 'label', '' );\n    try {\n      value = JSON.parse( value ); \n    } catch( e ) {}\n  }\n  this.fireOutput( 'out', value );\n}\n// Node Compute: [DataFlow_Component] Equation Parser\nfunction EquationParser( name, value ) {\n  \n  if( name == 'in' ) {\n    // Build the AST tree (recursive function)\n    const outValue = buildAST( value );\n    \n    this.fireOutput( 'out', outValue );\n  }\n  \n  function buildAST( tokenList ) {\n    if( tokenList.length == 0 ) {\n      return( null );\n    } else if( tokenList.length == 1 ) {\n      return( tokenList[0] );\n    }\n  \n    // Find the index of the lowest precedence operator\n    let index = -1;\n    let minPrecedence = Infinity;\n    let parenthesis = 0;\n    // Loop over all tokenList\n    for( let i = 0; i < tokenList.length; ++i ) {\n      if( tokenList[i] == '(' ) {\n        parenthesis++;\n      } else if( tokenList[i] == ')' ) {\n        parenthesis--;\n      } else if( parenthesis === 0 ) {\n        // Compute precedences\n        const operator = tokenList[i];\n        let precedence = 0;\n        if( ( operator == '+' ) || ( operator == '-' ) ) {\n          precedence = 1;\n        } else if( ( operator == '*' ) || ( operator == '/' ) ) {\n          precedence = 2;\n        } else {\n          precedence = Infinity;\n        }\n        \n        if( precedence <= minPrecedence ) {\n          minPrecedence = precedence;\n          index = i;\n        }\n      }\n    }\n  \n    // Handle subexpressions inside parentheses\n    if( index === -1 ) {\n      return( buildAST( tokenList.slice( 1, -1 ) ) );\n    }\n  \n    const result = [\n      tokenList[index],\n      buildAST( tokenList.slice( 0, index ) ),\n      buildAST( tokenList.slice( index+1 ))\n    ];\n    return( result );\n  }\n  \n}\n// Node Compute: [DataFlow_Component] Equation Tokenizer\nfunction compute_15( name, value ) {\n  \n  if( name == 'in' ) {\n    // Tokenize the input equation\n    const regex = /\\d+(\\.\\d+)?|[\\+\\-\\*\\/\\(\\)]|[=a-zA-Z]/g;\n    const tokenList = value.match( regex ).map( token => {\n      return( isNaN( token ) ? token : parseFloat( token ) );\n    });\n    \n    this.fireOutput( 'out', tokenList );\n  }\n}\n// Node Compute: [DataFlow_Component] Equation Compute\nfunction EquationCompute( name, value ) {\n  \n  if( name == 'in' ) {\n    let outValue = NaN;\n    let outStatus = 'Done';\n    try {\n      if( value == null ) {\n        outValue = '';\n      } else {\n        outValue = evaluateAST( value );\n      }\n    } catch( e ) {\n      outStatus = `Syntax error in expression: ${e}`;\n    }\n    \n    this.fireOutput( 'out', outValue );\n    this.fireOutput( 'status', outStatus );\n  }\n  \n  function evaluateAST( ast ) {\n    if( RegExp( /^[a-z]/i ).test( ast ) ) {\n      return( ast );\n    } else if( typeof( ast ) === 'number' ) {\n      // Base case: if the node is a number, return it.\n      return( ast );\n    }\n  \n    // Recursive case: evaluate the left and right operands.\n    const left = evaluateAST( ast[1] );\n    const right = evaluateAST( ast[2] );\n  \n    // Compute the result based on the operator.\n    switch( ast[0] ) {\n      case '+':\n        return( left + right );\n      case '-':\n        return( left - right );\n      case '*':\n        return( left * right );\n      case '/':\n        return( left / right );\n      default:\n        throw new Error( 'Unknown operator: ' + ast[0] );\n    }\n  }\n}\n// Node Compute: [DataFlow_Component] Equation Split\nfunction compute_18( name, value ) {\n  \n  if( name == 'in' ) {\n    let i = value.indexOf( '=' );\n    if( i == -1 ) {\n      i = value.length;\n    }\n    \n    const lEq = value.slice( 0, i );\n    const rEq = value.slice( i+1 );\n    \n    this.fireOutput( 'lEq', lEq );\n    this.fireOutput( 'rEq', rEq );\n  }\n}\n// Node Compute: [DataFlow_Component] Equation Parser\n// Node Compute: [DataFlow_Component] Equation Compute\n// Node Compute: [DataFlow_Component] Equation Compare\nfunction compute_25( name, value ) {\n  \n  if( name == 'in' ) {\n    let outValue = '';\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\n        outValue = value.lValue || value.rValue;\n      } else if( isVariable( value.lValue  ) ) {\n        outValue = `${value.lValue} = ${value.rValue}`;\n      } else if( isVariable( value.rValue ) ) {\n        outValue = `${value.rValue} = ${value.lValue}`;\n      } else {\n        outValue = String( value.lValue == value.rValue );\n      }\n    } else {\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\n    }\n    \n    this.fireOutput( 'out', outValue );\n  }\n  \n  function isVariable( str ) {\n    return( RegExp( /^[a-z]/i ).test( str ) );\n  }\n}\n// Node Compute: [DataFlow_Message] y = 25\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1\n// Node Compute: [DataFlow_Message] y=3*5+10\n// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\n// Node Compute: [DataFlow_Component] Log Result\nfunction compute_45( name, value ) {\n  \n  console.log( value );\n}\n// Node Compute: [DataFlow_Component] Barrier\nfunction MakeObject( name, value ) {\n  \n  const defaultInputStat = {\n    'lValue': false,\n    'lStatus': false,\n    'rValue': false,\n    'rStatus': false,\n  };\n  const inputStat = this.get( 'inputStat', defaultInputStat );\n  \n  inputStat[name] = true;\n  let isObjectReady = true;\n  for( const inName in inputStat ) {\n    if( !inputStat[inName] ) {\n      isObjectReady = false;\n      break;\n    }\n  }\n  \n  if( isObjectReady ) {\n    const outValue = {};\n    for( const inName in inputStat ) {\n      inputStat[inName] = false;\n      outValue[inName] = this.getInput( inName, null );\n    }\n    this.fireOutput( 'out', outValue );\n  }\n  \n}\n\n/********************\n * System Start\n ********************/\nnodeData_7.doCompute( 'in' );\nnodeData_38.doCompute( 'in' );\nnodeData_42.doCompute( 'in' );\nnodeData_46.doCompute( 'in' );\nnodeData_50.doCompute( 'in' );\n",
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 44,
      "location": "3110 2220",
      "group": 78
    },
    {
      "label": "Log Result",
      "category": "DataFlow_Component",
      "size": "240 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "in"
        }
      ],
      "out_": [],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "*"
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nconsole.log( value );",
      "fileTypeName": "Component",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 45,
      "location": "1450 3073.158",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 48,
      "location": "588.103515625 2771.658",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 49,
      "location": "-90 2583.158",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 52,
      "location": "-641.896484375 2681.316",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 53,
      "location": "-1170 3310",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 54,
      "location": "-640 3281.316",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 55,
      "location": "-70 3423.158",
      "group": 36
    },
    {
      "label": "Log",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 56,
      "location": "588.103515625 3253.658",
      "group": 36
    },
    {
      "label": "Barrier",
      "category": "DataFlow_Component",
      "size": "240 80",
      "color": "LightSeaGreen",
      "in_": [
        {
          "portId": "1in",
          "name": "lValue"
        },
        {
          "portId": "2in",
          "name": "lStatus"
        },
        {
          "portId": "3in",
          "name": "rValue"
        },
        {
          "portId": "4in",
          "name": "rStatus"
        }
      ],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "props_": [
        {
          "name": "computeBarrier",
          "value": "*"
        }
      ],
      "isFile": true,
      "fileContent": "var nodeData, name, value;\n\nconst defaultInputStat = {\n  'lValue': false,\n  'lStatus': false,\n  'rValue': false,\n  'rStatus': false,\n};\nconst inputStat = graphData.dfe.get( nodeData, 'inputStat', defaultInputStat );\n\ninputStat[name] = true;\nlet isObjectReady = true;\nfor( const inName in inputStat ) {\n  if( !inputStat[inName] ) {\n    isObjectReady = false;\n    break;\n  }\n}\n\nif( isObjectReady ) {\n  const outValue = {};\n  for( const inName in inputStat ) {\n    inputStat[inName] = false;\n    outValue[inName] = graphData.dfe.getInput( nodeData, inName, null );\n  }\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\n}\n",
      "fileTypeName": "MakeObject",
      "fileType": "text/javascript",
      "iconURL": "",
      "key": 58,
      "location": "690 2973.058",
      "group": 36,
      "editorPosition": [
        2146,
        2191,
        674,
        512
      ]
    },
    {
      "label": "This WorkSpace demonstrate different concepts:",
      "category": "TextLabels_Size4",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "1689 92",
      "key": 59,
      "location": "-1820 1560"
    },
    {
      "label": "1) Creation of a system through its model (Equation Solver Model)\n2) Usage of the component model defined in DataFlowDSL+DataFlowEngine\n3) Execution of a model by using DataFlowEngine\n4) Code Generation of the model into a JavaScript program that do not depend from the DataFlowEngine\n5) The execution of the generated code",
      "category": "TextLabels_Size3",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "2136 276",
      "key": 61,
      "location": "-1800 1750"
    },
    {
      "label": "3) The system can be executed by pressing the start buttons",
      "category": "TextLabels_Size2",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "501 102",
      "key": 63,
      "location": "-2380 2646",
      "group": 36
    },
    {
      "label": "1) This model defines an Equation Solver system",
      "category": "TextLabels_Size2",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "438 114",
      "key": 65,
      "location": "-570 2130"
    },
    {
      "label": "2) The different components show examples of the component model usage. The code can be seen by clicking on the component's context menu and selecting \"Open File\"",
      "category": "TextLabels_Size2",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "698 145",
      "key": 67,
      "location": "-1410 2800",
      "group": 36
    },
    {
      "label": "NOTE: Log components are linked with a log link and are inserted into a group. These 2 choices make sure that such components are not included in the code-generation phase",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "613 145",
      "key": 69,
      "location": "1110 2350",
      "group": 36
    },
    {
      "label": "4) By clicking \"Generate\" the Equation Solver Model is code-generated into the Target Code  component",
      "category": "TextLabels_Size2",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "580 145",
      "key": 71,
      "location": "2300 2140"
    },
    {
      "label": "5) By clicking \"Execute\" the code-generated system in the Target Code component is executed. Output can be seen in the JavaScript console",
      "category": "TextLabels_Size2",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "580 145",
      "key": 73,
      "location": "2300 2370"
    },
    {
      "label": "NOTE: The DataFlow Engine is used to execute the Equation Solver Model from the model itself",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "374 102",
      "key": 75,
      "location": "4650 930"
    },
    {
      "label": "This second component create a new instance of the DataFlow Engine once entered in the WorkSpace",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "372 102",
      "key": 77,
      "location": "4650 1110"
    },
    {
      "label": "This is the DataFlow Engine Control Center. It can be opened by clicking on its context menu and selecting\n\"Open File\"",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "391 117",
      "key": 79,
      "location": "4650 1270"
    },
    {
      "label": "DFECodeGenerator.js",
      "color": "orange",
      "size": "406 144",
      "category": "Hierarchy_CodeInGraph",
      "isIncludeScript": true,
      "isFile": true,
      "fileContent": "/**\n * This is an example of Code Generator based on the conventions\n * of the component model and the DataFlow Engine execution model\n *\n * The main function to start code generation is:\n *    generationRoot( gen, callback )\n * Where:\n *   gen: is a data structure with the following information\n *        {\n *          name: 'GenDFE 1.0',  // Code generator name and version\n *          groupKey: null,       // Group node key containing the Model to be generated\n *          me: null,             // ModelExplorer loaded with the model\n *          modelId: 'main',      // Model Id\n *        };\n * \n *   callback: a function( source, msg ) executed at the end of\n *             the generation process. Source is the generated source\n *             code, while msg is a message starting with Success:/Error:\n */\n\nfunction generationRoot( gen, onGenerated ) {\n  console.log( 'Starting Generation...' );\n  \n  // If nodes are found ==> start generation\n  if( gen.groupKey != null ) {\n    // Extend generation info\n    gen.lines = [];                      // Number of lines of code generate\n    gen.date = new Date().toGMTString(); // Generation date info\n    gen.startNodeList = [],              // Start nodes\n    // Match line: var nodeData, name, value;\n    gen.declLine = RegExp( /\\s*var\\s+nodeData\\s*,/ );\n    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\(\\s*nodeData\\s*,/ );\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,/ );\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\n    gen.getLine = RegExp( /graphData.dfe.get\\(\\s*nodeData\\s*,/ );\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,\\s*([^,]+),/ );  \n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\n    gen.computeBuffer = {};                // Store all generated compute functions\n    \n    // Start generation\n    generateGroup( gen, onGenerated );\n  } else {\n    if( onGenerated ) {\n      onGenerated( '', 'Error: group key not found in gen parameter' );\n    }\n  }\n}\nfunction generateGroup( gen, onGenerated ) {\n  const header = [ \n    '/*',\n    ` * This file is code generated by ${gen.name}`,\n    ' *',\n    ` * Generated on ${gen.date}`,\n    ' */',\n    '',\n    '/********************',\n    ' * Node Functions',\n    ' ********************/',\n    '// System function for reading properties',\n    'function nodeData_getProperty( name, defaultValue ) {',\n    '  // NOTE: this function access both nodeData fields and properties',\n    '  if( this.nd_[name] != undefined ) {',\n    '    return( this.nd_[name] );',\n    '  } else if( this.nd_.props_[name] != undefined ) {',\n    '    return( this.nd_.props_[name] );',\n    '  } else {',\n    '    return( defaultValue );',\n    '  }',\n    '}',\n    '// System function for reading input',\n    'function nodeData_getInput( name, defaultValue ) {',\n    '  if( this.in_[name] == undefined ) {',\n    '    this.in_[name] = defaultValue;',\n    '  }',\n    '  return( this.in_[name] );',\n    '}',\n    '// System function for storing access',\n    'function nodeData_setInput( name, value ) {',\n    '  this.in_[name] = value;',\n    '}',\n    '// System function for instance data access',\n    'function nodeData_get( name, defaultValue ) {',\n    '  if( this.st_[name] == undefined ) {',\n    '    this.st_[name] = defaultValue;',\n    '  }',\n    '  return( this.st_[name] );',\n    '}',\n    '// System function for firing inputs',\n    'function nodeData_fireInput( name, value ) {',\n    '  this.setInput( name, value );',\n    '  this.doCompute( name, value );',\n    '}',\n    '',\n    '/********************',\n    ' * Model Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( header );\n  \n  // Get all nodes in the group\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\n  \n  // Generate instance data for all nodes\n  for( const data of dataList ) {\n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\n      generateNodeState( gen, nodeInfo );\n    }\n  }\n  \n  const funcHeader = [\n    '',\n    '/********************',\n    ' * Compute Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( funcHeader );\n  \n  // Generate compute function for all nodes\n  for( const data of dataList ) {\n    // Get nodeInfo\n    if( data.category == 'DataFlow_Start' ) {\n      gen.startNodeList.push( data );\n      continue;\n    }\n    \n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\n      generateNodeCompute( gen, nodeInfo );\n    }\n  }\n  \n  if( gen.startNodeList.length ) {\n    // Generate start functions\n    const sysStart =[\n      '',\n      '/********************',\n      ' * System Start',\n      ' ********************/' ];\n    // Add lines\n    gen.lines = gen.lines.concat( sysStart );\n    // Generate Start Nodes\n    for( const data of gen.startNodeList ) {\n      generateStartNode( gen, data );\n    }\n    gen.lines.push( '' );\n  }\n  \n  // Save source in target component\n  const content = gen.lines.join( '\\n' );\n  if( onGenerated ) {\n    // Generate closing event\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\n  }\n}\nfunction generateNodeState( gen, ni ) {\n  const nodeDataObjOpen = [\n    `const nodeData_${ni.key} = {`,\n    `  in_: {},     // Input`,\n    `  st_: {},     // Storage`,\n    `  nd_: { // Properties`,\n    `    label: '${ni.data.label}',`, // Some fields could be put here\n    '    props_: {}', // It could be translated here into key,value?\n    `  },`,\n    `  out_: {},     // Output` ];\n  // Add lines\n  gen.lines = gen.lines.concat( nodeDataObjOpen );\n  \n  generateNodeFire( gen, ni );\n  const nodeDataObjClose = [\n    `  getProperty: nodeData_getProperty,`,\n    `  getInput: nodeData_getInput,`,\n    `  setInput: nodeData_setInput,`,\n    `  fireInput: nodeData_fireInput,`,\n    `  get: nodeData_get,`,\n    `  doCompute: ${getComputeId( gen, ni )},`,\n    `};` ];\n  // Add lines\n  gen.lines = gen.lines.concat( nodeDataObjClose );\n}\nfunction generateNodeFire( gen, ni ) {\n  // Get out port list\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\n  const portLen = outPortList.length\n  \n  // Generate fire function\n  gen.lines.push( `  fireOutput: function ( name, value ) {` );\n  // Generate fire body\n  if( portLen ) {\n    gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );\n    // Loop on each output port\n    for( let i = 0; i < portLen; ++i ) {\n      const portName = outPortList[i];\n      if( i > 0 ) {\n        gen.lines.push( `    } else if( name == '${portName}' ) {` );\n      }\n      \n      // Get output links\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\n      for( const link of linkList ) {\n        generateLinkCall( gen, ni, '      ', link, 'value' );\n      }\n    }\n    gen.lines.push( `    }` );\n  }\n  gen.lines.push( `  },` );\n}\nfunction generateLinkCall( gen, ni, indent, link, value ) {\n  // Check link type\n  if( link.category == 'DataFlow_Log' ) {\n      return;\n  } else if( link.category == 'DataFlow_Pause') {\n    gen.lines.push( `${indent}debugger` );\n  }\n  \n  // Get target input port name\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\n  // Generate input update if node info is defined\n  if( ni ) {\n    gen.lines.push( `${indent}// Store new input` );\n    gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );\n  }\n  // Generate compute call\n  if( value ) {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\n  } else {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\n  }\n}\nfunction generateStartNode( gen, data ) {\n  // Get output links\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\n  for( const link of linkList ) {\n    generateLinkCall( gen, null, '', link );\n  }\n}\nfunction generateNodeCompute( gen, ni ) {\n  let isMainDeclSkipped = false;\n  \n  // Get compute identifier\n  let computeId = getComputeId( gen, ni );\n  // Generate compute only if necessary\n  if( computeId ) {\n    addComputeId( gen, computeId );\n    // Generate compute function\n    gen.lines.push( `function ${computeId}( name, value ) {` );\n    for( let line of ni.src ) {\n      if( !isMainDeclSkipped ) {\n        if( gen.declLine.test( line ) ) {\n          isMainDeclSkipped = true;\n        }\n      } else {\n        if( gen.fireLine.test( line ) ) {\n          line = line.replace( gen.fireLine, `this.fireOutput(` );\n        } else if( gen.getInLine.test( line ) ) {\n          line = line.replace( gen.getInLine, `this.getInput(` );\n        } else if( gen.getLine.test( line ) ) {\n          line = line.replace( gen.getLine, `this.get(` );\n        }\n        gen.lines.push( `  ${line}` );\n      }\n    }\n    gen.lines.push( `}` );\n  }\n}\nfunction getComputeId( gen, ni ) {\n  let result = null;\n  let computeId = null;\n  \n  if( ni.data.doCompute ) {\n    computeId = ni.data.doCompute;\n  } else if( ni.data.fileTypeName && ni.data.fileTypeName != 'Component' ) {\n    computeId = ni.data.fileTypeName;\n  } else {\n    computeId = `compute_${ni.key}`;\n  }\n  // If we did not generate the compute yet\n  if( !gen.computeBuffer[computeId] ) {\n    result = computeId;\n  }\n  return( result );\n}\nfunction addComputeId( gen, computeId ) {\n  gen.computeBuffer[computeId] = true;\n}\nfunction getNodeInfo( gen, data ) {\n  const nodeInfo = {\n    data,\n    src: null,\n    key: data.key,\n    label: data.label,\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\n  };\n  \n  if( data.fileContent ) {\n    nodeInfo.src = data.fileContent.split( '\\n' );\n  } else if( data.category == 'DataFlow_Message' ) {\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\n' );\n    nodeInfo.src = [ \n      `var nodeData, name, value;`,\n      ``,\n      `if( value == undefined ) {`,\n      //`  value = \"${nodeInfo.label}\";`,\n      `  value = this.getProperty( 'label', '' );`,\n      `  try {`,\n      `    value = JSON.parse( value ); `,\n      `  } catch( e ) {}`,\n      `}`,\n      `this.fireOutput( 'out', value );` \n    ];\n  }\n  \n  return( nodeInfo.src? nodeInfo: null );  \n}\n\nvar module;\nif( module ) {\n  module.exports = generationRoot;\n}",
      "fileTypeName": "JavaScript",
      "fileType": "text/javascript",
      "key": 62,
      "location": "3020 2390",
      "editorPosition": [
        3039,
        1058,
        799,
        1814
      ],
      "group": 78
    },
    {
      "label": "This is the code generator library.\nNOTE: it is an include file for this workspace, as well as a file to be deployed on the server",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "391 58",
      "key": 64,
      "location": "3450 2370"
    },
    {
      "label": "",
      "category": "Pictures_Basic",
      "size": "2698 1916",
      "isFile": true,
      "fileTypeName": "Image",
      "fileType": "image/png",
      "fileURL": "/fileServer/pictures/Test DataFlow & Code Generation.png",
      "key": 66,
      "location": "8080 3660"
    },
    {
      "label": "Includes",
      "category": "TextLabels_Size5",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "2151 154",
      "key": 60,
      "location": "3570 580",
      "color": "LightGreen"
    },
    {
      "label": "Screenshot",
      "category": "TextLabels_Size5",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "3539 154",
      "key": 70,
      "location": "6380 1380",
      "color": "Yellow"
    },
    {
      "label": "  Development WorkSpace",
      "category": "TextLabels_Size5",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "5298 154",
      "key": 68,
      "location": "-2470 930",
      "color": "#d2b4de"
    },
    {
      "label": "MainCodeGenerate.js 1.0",
      "color": "orange",
      "size": "406 144",
      "category": "Hierarchy_CodeInGraph",
      "isIncludeScript": false,
      "isFile": true,
      "fileContent": "/**\n * This is an example of Code Generator based on the conventions\n * of the component model and the DataFlow Engine execution model\n *\n * The main function to start code generation is:\n *    generationRoot( gen, callback )\n * Where:\n *   gen: is a data structure with the following information\n *        {\n *          name: 'GenDFE 1.0',  // Code generator name and version\n *          groupKey: null,       // Group node key containing the Model to be generated\n *          me: null,             // ModelExplorer loaded with the model\n *          modelId: 'main',      // Model Id\n *        };\n * \n *   callback: a function( source, msg ) executed at the end of\n *             the generation process. Source is the generated source\n *             code, while msg is a message starting with Success:/Error:\n */\n\nfunction generationRoot( gen, onGenerated ) {\n  console.log( 'Starting Generation...' );\n  \n  // If nodes are found ==> start generation\n  if( gen.groupKey != null ) {\n    // Extend generation info\n    gen.lines = [];                      // Number of lines of code generate\n    gen.date = new Date().toGMTString(); // Generation date info\n    gen.startNodeList = [],              // Start nodes\n    // Match line: var nodeData, name, value;\n    gen.declLine = RegExp( /\\s*var\\s+nodeData\\s*,/ );\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\(\\s*nodeData\\s*,/ );\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,/ );\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\n    gen.getLine = RegExp( /graphData.dfe.get\\(\\s*nodeData\\s*,/ );\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,\\s*([^,]+),/ );  \n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\n    \n    // Start generation\n    generateGroup( gen, onGenerated );\n  } else {\n    if( onGenerated ) {\n      onGenerated( '', 'Error: group key not found in gen parameter' );\n    }\n  }\n}\nfunction generateGroup( gen, onGenerated ) {\n  const header = [ \n    '/*',\n    ` * This file is code generated by ${gen.name}`,\n    ' *',\n    ` * Generated on ${gen.date}`,\n    ' */',\n    '',\n    '// System function for reading input',\n    'function node_getInput( node, name, defaultValue ) {',\n    '  if( node.in_[name] == undefined ) {',\n    '    node.in_[name] = defaultValue;',\n    '  }',\n    '  return( node.in_[name] );',\n    '}',\n    '// System function for storing access',\n    'function node_setInput( node, name, value ) {',\n    '  node.in_[name] = value;',\n    '}',\n    '// System function for instance data access',\n    'function node_get( node, name, defaultValue ) {',\n    '  if( node.st_[name] == undefined ) {',\n    '    node.st_[name] = defaultValue;',\n    '  }',\n    '  return( node.st_[name] );',\n    '}',\n    '' ];\n  // Add lines\n  gen.lines = gen.lines.concat( header );\n  \n  // Get all nodes in the group\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\n  // Generate compute function for all nodes\n  for( const data of dataList ) {\n    // Get nodeInfo\n    if( data.category == 'DataFlow_Start' ) {\n      gen.startNodeList.push( data );\n      continue;\n    }\n    \n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      generateNodeState( gen, nodeInfo );\n      generateNodeCompute( gen, nodeInfo );\n      generateNodeFire( gen, nodeInfo );\n    }\n  }\n  \n  if( gen.startNodeList.length ) {\n    // Generate start functions\n    gen.lines.push( '' );\n    gen.lines.push( '/********************' );\n    gen.lines.push( ' * System Start' );\n    gen.lines.push( ' ********************/' );\n    // Generate Start Nodes\n    for( const data of gen.startNodeList ) {\n      generateStartNode( gen, data );\n    }\n    gen.lines.push( '' );\n  }\n  \n  // Save source in target component\n  const content = gen.lines.join( '\\n' );\n  if( onGenerated ) {\n    // Generate closing event\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\n  }\n}\nfunction generateNodeState( gen, ni ) {\n  gen.lines.push( `const node_${ni.key} = {` );\n  gen.lines.push( `  in_:  {}, // Input` );\n  gen.lines.push( `  st_:  {}, // Storage` );\n  gen.lines.push( `  out_: {}, // Output` );\n  gen.lines.push( `};` );\n}\nfunction generateNodeCompute( gen, ni ) {\n  let isMainDeclSkipped = false;\n  \n  // Generate compute function\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\n  gen.lines.push( `` );\n  gen.lines.push( `  // Store new input` );\n  gen.lines.push( `  node_setInput( node_${ni.key}, name, value );` );\n  for( let line of ni.src ) {\n    if( !isMainDeclSkipped ) {\n      if( gen.declLine.test( line ) ) {\n        isMainDeclSkipped = true;\n      }\n    } else {\n      if( gen.fireLine.test( line ) ) {\n        line = line.replace( gen.fireLine, `fire_${ni.key}(` );\n      } else if( gen.getInLine.test( line ) ) {\n        line = line.replace( gen.getInLine, `node_getInput( node_${ni.key},` );\n      } else if( gen.getLine.test( line ) ) {\n        line = line.replace( gen.getLine, `node_get( node_${ni.key},` );\n      }\n      gen.lines.push( `  ${line}` );\n    }\n  }\n  gen.lines.push( `}` );\n}\nfunction generateNodeFire( gen, ni ) {\n  // Get out port list\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\n  const portLen = outPortList.length\n  if( portLen ) {\n    // Generate fire function\n    gen.lines.push( `function fire_${ni.key}( name, value ) {` );\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\n    // Loop on each output port\n    for( let i = 0; i < portLen; ++i ) {\n      const portName = outPortList[i];\n      if( i > 0 ) {\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\n      }\n      \n      // Get output links\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\n      for( const link of linkList ) {\n        generateLinkCall( gen, '    ', link, 'value' );\n      }\n    }\n    gen.lines.push( `  }` );\n    gen.lines.push( `}` );\n  }\n}\nfunction generateLinkCall( gen, indent, link, value ) {\n  if( link.category == 'DataFlow_Log' ) {\n      return;\n  } else if( link.category == 'DataFlow_Pause') {\n    gen.lines.push( `${indent}debugger` );\n  }\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\n  if( value ) {\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}', ${value} );` );\n  } else {\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}' );` );\n  }\n}\nfunction generateStartNode( gen, data ) {\n  // Get output links\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\n  for( const link of linkList ) {\n    generateLinkCall( gen, '', link );\n  }\n}\nfunction getNodeInfo( gen, data ) {\n  const nodeInfo = {\n    data,\n    src: null,\n    key: data.key,\n    label: data.label,\n    descr: ( data.label? data.label: data.key ),\n  };\n  \n  if( data.fileContent ) {\n    nodeInfo.src = data.fileContent.split( '\\n' );\n    gen.lines.push( `// Node: ${nodeInfo.descr}` );\n    \n  } else if( data.category == 'DataFlow_Message' ) {\n    gen.lines.push( `// Node: Message \"${nodeInfo.descr}\"` );\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\n' );\n    nodeInfo.src = [ \n      `var nodeData, name, value;`,\n      ``,\n      `if( value == undefined ) {`,\n      `  value = \"${nodeInfo.label}\";`,\n      `  try {`,\n      `    value = JSON.parse( value ); `,\n      `  } catch( e ) {}`,\n      `}`,\n      `fire_${nodeInfo.key}( 'out', value );` \n    ];\n  }\n  \n  return( nodeInfo.src? nodeInfo: null );  \n}",
      "fileTypeName": "JavaScript",
      "fileType": "text/javascript",
      "key": 72,
      "location": "2410 1130"
    },
    {
      "label": "MainCodeGenerate.js 1.1",
      "color": "orange",
      "size": "406 144",
      "category": "Hierarchy_CodeInGraph",
      "isIncludeScript": false,
      "isFile": true,
      "fileContent": "/**\n * This is an example of Code Generator based on the conventions\n * of the component model and the DataFlow Engine execution model\n *\n * The main function to start code generation is:\n *    generationRoot( gen, callback )\n * Where:\n *   gen: is a data structure with the following information\n *        {\n *          name: 'GenDFE 1.0',  // Code generator name and version\n *          groupKey: null,       // Group node key containing the Model to be generated\n *          me: null,             // ModelExplorer loaded with the model\n *          modelId: 'main',      // Model Id\n *        };\n * \n *   callback: a function( source, msg ) executed at the end of\n *             the generation process. Source is the generated source\n *             code, while msg is a message starting with Success:/Error:\n */\n\nfunction generationRoot( gen, onGenerated ) {\n  console.log( 'Starting Generation...' );\n  \n  // If nodes are found ==> start generation\n  if( gen.groupKey != null ) {\n    // Extend generation info\n    gen.lines = [];                      // Number of lines of code generate\n    gen.date = new Date().toGMTString(); // Generation date info\n    gen.startNodeList = [],              // Start nodes\n    // Match line: var nodeData, name, value;\n    gen.declLine = RegExp( /\\s*var\\s+nodeData\\s*,/ );\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\(/ );\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\(/ );\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\n    gen.getLine = RegExp( /graphData.dfe.get\\(/ );\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,\\s*([^,]+),/ );  \n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\n    \n    // Start generation\n    generateGroup( gen, onGenerated );\n  } else {\n    if( onGenerated ) {\n      onGenerated( '', 'Error: group key not found in gen parameter' );\n    }\n  }\n}\nfunction generateGroup( gen, onGenerated ) {\n  const header = [ \n    '/*',\n    ` * This file is code generated by ${gen.name}`,\n    ' *',\n    ` * Generated on ${gen.date}`,\n    ' */',\n    '',\n    '/********************',\n    ' * Node Functions',\n    ' ********************/',\n    '// System function for reading properties',\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\n    '  // NOTE: this function access both nodeData fields and properties',\n    '  if( nodeData.nd_[name] != undefined ) {',\n    '    return( nodeData.nd_[name] );',\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\n    '    return( nodeData.nd_.props_[name] );',\n    '  } else {',\n    '    return( defaultValue );',\n    '  }',\n    '}',\n    '// System function for reading input',\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\n    '  if( nodeData.in_[name] == undefined ) {',\n    '    nodeData.in_[name] = defaultValue;',\n    '  }',\n    '  return( nodeData.in_[name] );',\n    '}',\n    '// System function for storing access',\n    'function nodeData_setInput( nodeData, name, value ) {',\n    '  nodeData.in_[name] = value;',\n    '}',\n    '// System function for instance data access',\n    'function nodeData_get( nodeData, name, defaultValue ) {',\n    '  if( nodeData.st_[name] == undefined ) {',\n    '    nodeData.st_[name] = defaultValue;',\n    '  }',\n    '  return( nodeData.st_[name] );',\n    '}',\n    '// System function for firing inputs',\n    'function nodeData_fireInput( nodeData, name, value ) {',\n    '  nodeData_setInput( nodeData, name, value );',\n    '  nodeData.doCompute( nodeData, name, value );',\n    '}',\n    '',\n    '/********************',\n    ' * Model Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( header );\n  \n  // Get all nodes in the group\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\n  \n  // Generate instance data for all nodes\n  for( const data of dataList ) {\n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\n      generateNodeFire( gen, nodeInfo );\n      generateNodeState( gen, nodeInfo );\n    }\n  }\n  \n  const funcHeader = [\n    '',\n    '/********************',\n    ' * Compute Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( funcHeader );\n  \n  // Generate compute function for all nodes\n  for( const data of dataList ) {\n    // Get nodeInfo\n    if( data.category == 'DataFlow_Start' ) {\n      gen.startNodeList.push( data );\n      continue;\n    }\n    \n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\n      generateNodeCompute( gen, nodeInfo );\n    }\n  }\n  \n  if( gen.startNodeList.length ) {\n    // Generate start functions\n    const sysStart =[\n      '',\n      '/********************',\n      ' * System Start',\n      ' ********************/' ];\n    // Add lines\n    gen.lines = gen.lines.concat( sysStart );\n    // Generate Start Nodes\n    for( const data of gen.startNodeList ) {\n      generateStartNode( gen, data );\n    }\n    gen.lines.push( '' );\n  }\n  \n  // Save source in target component\n  const content = gen.lines.join( '\\n' );\n  if( onGenerated ) {\n    // Generate closing event\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\n  }\n}\nfunction generateNodeState( gen, ni ) {\n  const nodeDataObj = [\n    `const nodeData_${ni.key} = {`,\n    `  in_: {},     // Input`,\n    `  st_: {},     // Storage`,\n    `  nd_: { // Properties`,\n    `    label: '${ni.data.label}',`, // Some fields could be put here\n    '    props_: {}', // It could be translated here into key,value?\n    `  },`,\n    `  out_: {},     // Output`,\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\n    `  doCompute: compute_${ni.key},     // Node compute function`,\n    `};` ];\n  // Add lines\n  gen.lines = gen.lines.concat( nodeDataObj );\n}\nfunction generateNodeFire( gen, ni ) {\n  // Get out port list\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\n  const portLen = outPortList.length\n  \n  // Generate fire function\n  gen.lines.push( `function fireOutput_${ni.key}( nodeData, name, value ) {` );\n  // Generate fire body\n  if( portLen ) {\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\n    // Loop on each output port\n    for( let i = 0; i < portLen; ++i ) {\n      const portName = outPortList[i];\n      if( i > 0 ) {\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\n      }\n      \n      // Get output links\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\n      for( const link of linkList ) {\n        generateLinkCall( gen, ni, '    ', link, 'value' );\n      }\n    }\n    gen.lines.push( `  }` );\n  }\n  gen.lines.push( `}` );\n}\nfunction generateLinkCall( gen, ni, indent, link, value ) {\n  // Check link type\n  if( link.category == 'DataFlow_Log' ) {\n      return;\n  } else if( link.category == 'DataFlow_Pause') {\n    gen.lines.push( `${indent}debugger` );\n  }\n  \n  // Get target input port name\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\n  // Generate input update if node info is defined\n  if( ni ) {\n    gen.lines.push( `${indent}// Store new input` );\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\n  }\n  // Generate compute call\n  if( value ) {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}', ${value} );` );\n  } else {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}' );` );\n  }\n}\nfunction generateStartNode( gen, data ) {\n  // Get output links\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\n  for( const link of linkList ) {\n    generateLinkCall( gen, null, '', link );\n  }\n}\nfunction generateNodeCompute( gen, ni ) {\n  let isMainDeclSkipped = false;\n  \n  // Generate compute function\n  gen.lines.push( `function compute_${ni.key}( nodeData, name, value ) {` );\n  for( let line of ni.src ) {\n    if( !isMainDeclSkipped ) {\n      if( gen.declLine.test( line ) ) {\n        isMainDeclSkipped = true;\n      }\n    } else {\n      if( gen.fireLine.test( line ) ) {\n        line = line.replace( gen.fireLine, `nodeData.fireOutput(` );\n      } else if( gen.getInLine.test( line ) ) {\n        line = line.replace( gen.getInLine, `nodeData_getInput(` );\n      } else if( gen.getLine.test( line ) ) {\n        line = line.replace( gen.getLine, `nodeData_get(` );\n      }\n      gen.lines.push( `  ${line}` );\n    }\n  }\n  gen.lines.push( `}` );\n}\nfunction getNodeInfo( gen, data ) {\n  const nodeInfo = {\n    data,\n    src: null,\n    key: data.key,\n    label: data.label,\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\n  };\n  \n  if( data.fileContent ) {\n    nodeInfo.src = data.fileContent.split( '\\n' );\n  } else if( data.category == 'DataFlow_Message' ) {\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\n' );\n    nodeInfo.src = [ \n      `var nodeData, name, value;`,\n      ``,\n      `if( value == undefined ) {`,\n      //`  value = \"${nodeInfo.label}\";`,\n      `  value = nodeData_getProperty( nodeData, 'label', '' );`,\n      `  try {`,\n      `    value = JSON.parse( value ); `,\n      `  } catch( e ) {}`,\n      `}`,\n      `nodeData.fireOutput( nodeData, 'out', value );` \n    ];\n  }\n  \n  return( nodeInfo.src? nodeInfo: null );  \n}",
      "fileTypeName": "JavaScript",
      "fileType": "text/javascript",
      "key": 76,
      "location": "2410 1300",
      "editorPosition": [
        3188,
        1027,
        876,
        1871
      ]
    },
    {
      "label": "MainCodeGenerate.js 1.2",
      "color": "orange",
      "size": "406 144",
      "category": "Hierarchy_CodeInGraph",
      "isIncludeScript": false,
      "isFile": true,
      "fileContent": "/**\n * This is an example of Code Generator based on the conventions\n * of the component model and the DataFlow Engine execution model\n *\n * The main function to start code generation is:\n *    generationRoot( gen, callback )\n * Where:\n *   gen: is a data structure with the following information\n *        {\n *          name: 'GenDFE 1.0',  // Code generator name and version\n *          groupKey: null,       // Group node key containing the Model to be generated\n *          me: null,             // ModelExplorer loaded with the model\n *          modelId: 'main',      // Model Id\n *        };\n * \n *   callback: a function( source, msg ) executed at the end of\n *             the generation process. Source is the generated source\n *             code, while msg is a message starting with Success:/Error:\n */\n\nfunction generationRoot( gen, onGenerated ) {\n  console.log( 'Starting Generation...' );\n  \n  // If nodes are found ==> start generation\n  if( gen.groupKey != null ) {\n    // Extend generation info\n    gen.lines = [];                      // Number of lines of code generate\n    gen.date = new Date().toGMTString(); // Generation date info\n    gen.startNodeList = [],              // Start nodes\n    // Match line: var nodeData, name, value;\n    gen.declLine = RegExp( /\\s*var\\s+nodeData\\s*,/ );\n    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\(\\s*nodeData\\s*,/ );\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,/ );\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\n    gen.getLine = RegExp( /graphData.dfe.get\\(\\s*nodeData\\s*,/ );\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\(\\s*nodeData\\s*,\\s*([^,]+),/ );  \n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\n    \n    // Start generation\n    generateGroup( gen, onGenerated );\n  } else {\n    if( onGenerated ) {\n      onGenerated( '', 'Error: group key not found in gen parameter' );\n    }\n  }\n}\nfunction generateGroup( gen, onGenerated ) {\n  const header = [ \n    '/*',\n    ` * This file is code generated by ${gen.name}`,\n    ' *',\n    ` * Generated on ${gen.date}`,\n    ' */',\n    '',\n    '/********************',\n    ' * Node Functions',\n    ' ********************/',\n    '// System function for reading properties',\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\n    '  // NOTE: this function access both nodeData fields and properties',\n    '  if( nodeData.nd_[name] != undefined ) {',\n    '    return( nodeData.nd_[name] );',\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\n    '    return( nodeData.nd_.props_[name] );',\n    '  } else {',\n    '    return( defaultValue );',\n    '  }',\n    '}',\n    '// System function for reading input',\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\n    '  if( nodeData.in_[name] == undefined ) {',\n    '    nodeData.in_[name] = defaultValue;',\n    '  }',\n    '  return( nodeData.in_[name] );',\n    '}',\n    '// System function for storing access',\n    'function nodeData_setInput( nodeData, name, value ) {',\n    '  nodeData.in_[name] = value;',\n    '}',\n    '// System function for instance data access',\n    'function nodeData_get( nodeData, name, defaultValue ) {',\n    '  if( nodeData.st_[name] == undefined ) {',\n    '    nodeData.st_[name] = defaultValue;',\n    '  }',\n    '  return( nodeData.st_[name] );',\n    '}',\n    '// System function for firing inputs',\n    'function nodeData_fireInput( nodeData, name, value ) {',\n    '  nodeData_setInput( nodeData, name, value );',\n    '  nodeData.doCompute( name, value );',\n    '}',\n    '',\n    '/********************',\n    ' * Model Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( header );\n  \n  // Get all nodes in the group\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\n  \n  // Generate instance data for all nodes\n  for( const data of dataList ) {\n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\n      generateNodeFire( gen, nodeInfo );\n      generateNodeState( gen, nodeInfo );\n    }\n  }\n  \n  const funcHeader = [\n    '',\n    '/********************',\n    ' * Compute Functions',\n    ' ********************/' ];\n  // Add lines\n  gen.lines = gen.lines.concat( funcHeader );\n  \n  // Generate compute function for all nodes\n  for( const data of dataList ) {\n    // Get nodeInfo\n    if( data.category == 'DataFlow_Start' ) {\n      gen.startNodeList.push( data );\n      continue;\n    }\n    \n    const nodeInfo = getNodeInfo( gen, data );\n    if( nodeInfo ) {\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\n      generateNodeCompute( gen, nodeInfo );\n    }\n  }\n  \n  if( gen.startNodeList.length ) {\n    // Generate start functions\n    const sysStart =[\n      '',\n      '/********************',\n      ' * System Start',\n      ' ********************/' ];\n    // Add lines\n    gen.lines = gen.lines.concat( sysStart );\n    // Generate Start Nodes\n    for( const data of gen.startNodeList ) {\n      generateStartNode( gen, data );\n    }\n    gen.lines.push( '' );\n  }\n  \n  // Save source in target component\n  const content = gen.lines.join( '\\n' );\n  if( onGenerated ) {\n    // Generate closing event\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\n  }\n}\nfunction generateNodeState( gen, ni ) {\n  const nodeDataObjOpen = [\n    `const nodeData_${ni.key} = {`,\n    `  in_: {},     // Input`,\n    `  st_: {},     // Storage`,\n    `  nd_: { // Properties`,\n    `    label: '${ni.data.label}',`, // Some fields could be put here\n    '    props_: {}', // It could be translated here into key,value?\n    `  },`,\n    `  out_: {},     // Output`,\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\n    `  doCompute: compute_${ni.key},     // Node compute function`,\n    `};` ];\n  // Add lines\n  gen.lines = gen.lines.concat( nodeDataObjOpen );\n}\nfunction generateNodeFire( gen, ni ) {\n  // Get out port list\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\n  const portLen = outPortList.length\n  \n  // Generate fire function\n  gen.lines.push( `function fireOutput_${ni.key}( name, value ) {` );\n  // Generate fire body\n  if( portLen ) {\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\n    // Loop on each output port\n    for( let i = 0; i < portLen; ++i ) {\n      const portName = outPortList[i];\n      if( i > 0 ) {\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\n      }\n      \n      // Get output links\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\n      for( const link of linkList ) {\n        generateLinkCall( gen, ni, '    ', link, 'value' );\n      }\n    }\n    gen.lines.push( `  }` );\n  }\n  gen.lines.push( `}` );\n}\nfunction generateLinkCall( gen, ni, indent, link, value ) {\n  // Check link type\n  if( link.category == 'DataFlow_Log' ) {\n      return;\n  } else if( link.category == 'DataFlow_Pause') {\n    gen.lines.push( `${indent}debugger` );\n  }\n  \n  // Get target input port name\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\n  // Generate input update if node info is defined\n  if( ni ) {\n    gen.lines.push( `${indent}// Store new input` );\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\n  }\n  // Generate compute call\n  if( value ) {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\n  } else {\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\n  }\n}\nfunction generateStartNode( gen, data ) {\n  // Get output links\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\n  for( const link of linkList ) {\n    generateLinkCall( gen, null, '', link );\n  }\n}\nfunction generateNodeCompute( gen, ni ) {\n  let isMainDeclSkipped = false;\n  \n  // Generate compute function\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\n  for( let line of ni.src ) {\n    if( !isMainDeclSkipped ) {\n      if( gen.declLine.test( line ) ) {\n        isMainDeclSkipped = true;\n      }\n    } else {\n      if( gen.fireLine.test( line ) ) {\n        line = line.replace( gen.fireLine, `this.fireOutput(` );\n      } else if( gen.getInLine.test( line ) ) {\n        line = line.replace( gen.getInLine, `nodeData_getInput( this,` );\n      } else if( gen.getLine.test( line ) ) {\n        line = line.replace( gen.getLine, `nodeData_get( this,` );\n      }\n      gen.lines.push( `  ${line}` );\n    }\n  }\n  gen.lines.push( `}` );\n}\nfunction getNodeInfo( gen, data ) {\n  const nodeInfo = {\n    data,\n    src: null,\n    key: data.key,\n    label: data.label,\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\n  };\n  \n  if( data.fileContent ) {\n    nodeInfo.src = data.fileContent.split( '\\n' );\n  } else if( data.category == 'DataFlow_Message' ) {\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\n' );\n    nodeInfo.src = [ \n      `var nodeData, name, value;`,\n      ``,\n      `if( value == undefined ) {`,\n      //`  value = \"${nodeInfo.label}\";`,\n      `  value = nodeData_getProperty( this, 'label', '' );`,\n      `  try {`,\n      `    value = JSON.parse( value ); `,\n      `  } catch( e ) {}`,\n      `}`,\n      `this.fireOutput( 'out', value );` \n    ];\n  }\n  \n  return( nodeInfo.src? nodeInfo: null );  \n}",
      "fileTypeName": "JavaScript",
      "fileType": "text/javascript",
      "key": 74,
      "location": "2420 1480",
      "editorPosition": [
        3188,
        1027,
        876,
        1871
      ]
    },
    {
      "label": "DFEGen/1.3",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 78,
      "location": "3000 2451.1480468749996"
    },
    {
      "label": "System Status: [DEPLOYED]\ndone\nFilesCount: 0 of 1\nDirCount: 1 of 1",
      "category": "CodeFlow_Button",
      "color": "YellowGreen",
      "size": "390 120",
      "buttons_": [
        {
          "name": "Deploy",
          "checked": true
        },
        {
          "name": "Start",
          "checked": true
        },
        {
          "name": "Stop",
          "checked": false
        }
      ],
      "props_": [
        {
          "name": "isOverwrite",
          "value": "true",
          "valueChanged": "true"
        },
        {
          "name": "scriptPath",
          "value": "DFEGen/1.3",
          "valueChanged": "true"
        }
      ],
      "isFile": true,
      "fileContent": "var event, obj, nodeData;\n  // Uncomment the next line to start debugging\n  //debugger;\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\n//console.log( 'Button Label: '+obj.data.name );\n//console.log( 'Button Status: '+obj.data.checked );\n\nlet script = '';\nlet params = '';\nconst scriptPath = getProperty( 'scriptPath' );\n//const g = getMainGraph();\nlet onLoaded = function(){};\n\nswitch( obj.data.name ) {\n  case 'Deploy':\n    const modelFileURL = getMainGraphURL();\n    const deployKey = nodeData.key;\n    \n    script = `generateSystemLib.js`;\n    params = `modelFileURL=${modelFileURL}&deployKey=${deployKey}`;\n    onLoaded = function( msg ) {\n      setNodeDataField( nodeData, 'label', 'System Status: [DEPLOYED]\\n'+msg );\n    }\n    break;\n  case 'Start':\n    script = 'serverManager';\n    params = 'start '+scriptPath;\n    setNodeDataField( nodeData, 'label', 'System Status: [STARTED]' );\n    break;\n  case 'Stop':\n    script = 'serverManager';\n    params = 'stop '+scriptPath;\n    setNodeDataField( nodeData, 'label', 'System Status: [STOPPED]' );\n    break;\n}\n\nif( script ) {\n  const cmd = `${script}${( params? '?'+params: '')}`;\n  executeScript( cmd, onLoaded );\n}\n\nfunction getProperty( name ) {\n  let result = '';\n  if( nodeData.props_ ) {\n    nodeData.props_.find( (p)=> { if( p.name == name ) { result = p.value; return( true ) } } );\n  }\n  return( result );\n}",
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 80,
      "location": "4330 2110",
      "editorPosition": [
        3132,
        1920,
        758,
        959
      ]
    },
    {
      "label": "This is the reference generated target program (generated on the client)",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "391 58",
      "key": 82,
      "location": "3440 2190"
    },
    {
      "label": "Releases & Features",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 81,
      "location": "3440 1880"
    },
    {
      "label": "DFEGenerator 1.3",
      "category": "CodeFlow_FeatureOnOff",
      "size": "338 40",
      "color": "green",
      "buttons_": [
        {
          "name": "",
          "checked": true,
          "color": "RebeccaPurple"
        }
      ],
      "key": 83,
      "location": "3460 1880",
      "group": 81
    },
    {
      "label": "DummyEnable",
      "category": "CodeFlow_Feature",
      "size": "180 40",
      "color": "green",
      "buttons_": [
        {
          "name": "",
          "checked": true,
          "color": "RebeccaPurple"
        }
      ],
      "key": 84,
      "location": "3860 1880",
      "group": 81
    },
    {
      "label": "Dummy Enabled Component",
      "category": "CodeFlow_Code",
      "size": "180 100",
      "color": "orange",
      "props_": [],
      "in_": [],
      "out_": [
        {
          "portId": "1out",
          "name": "out"
        }
      ],
      "isFile": true,
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 86,
      "location": "3010 1907.5000000000002",
      "group": 87
    },
    {
      "label": "DummyEnable",
      "category": "Group_BasicGroup",
      "isGroup": true,
      "key": 87,
      "location": "2990 1910.0000000000002",
      "color": "green"
    },
    {
      "label": "MainCodeGenerate.js",
      "color": "orange",
      "size": "404 132",
      "category": "Hierarchy_CodeInGraph",
      "isFile": true,
      "fileContent": "const fs = require( 'fs' );\n\nconsole.log( 'Code Generation started' );\n\nconst ModelExplorer = require( './ModelExplorer.js' );\nconst generationRoot = require( './DFECodeGenerator.js' );\nconst isServer = true;\n\nlet args = '';\n\nif( process.argv ) { // Case of execution from the shell\n  args = process.argv[2];\n  const output = initGeneration( args );\n  console.log( output );\n} else {\n  console.log( 'Error, no parameters found' );\n}\n\nfunction initGeneration( args ) {\n  params = null;\n  try {\n    params = JSON.parse( args );\n  } catch( e ) {\n    console.log( 'Error in parameters' );\n    return;\n  }\n  const modelFileURL = params.modelFileURL;\n  const groupKey = params.groupKey;\n\n  startGeneration( modelFileURL, groupKey );\n}\n\nfunction startGeneration( fileURL, groupKey ) {\n  // Generation Instance Data\n  const gen = {\n    name: 'GenDFE 1.3',   // Code generator name and version\n    groupKey,             // Group node key containing the Model to be generated\n    me: null,             // ModelExplorer\n    modelId: 'main',      // Model Id\n  };\n\n  // Get graph source\n  const graph = getModel( fileURL );\n  try {\n    // Get model\n    const graphObj = JSON.parse( graph );\n    const model = graphObj.model;\n\n    // Model ID for the current graph\n    gen.modelId = 'main';\n    // Create a new Model Explorer\n    gen.me = new ModelExplorer();\n    // Load current graph model in Model Explorer\n    gen.me.setJSONModel( gen.modelId, model );\n  } catch( e ) {}\n\n  const onGenerated = function( source, msg ) {\n    if( msg.startsWith( 'Success:' ) ) {\n      // Save target component source\n      const filePathName = './OutCode.js';\n      saveFileContent( filePathName, source );\n    }\n  }\n\n  generationRoot( gen, onGenerated );\n}\nfunction getModel( fileURL ) {\n  let model = '{}';\n\n  if( isServer ) {\n    try {\n      model = fs.readFileSync( fileURL, 'utf8' );\n    } catch( e ) {}\n  } else {\n    // Get current graph model\n    const g = getMainGraph();\n    model = g.getJSONModel();\n  }\n  return( model );\n}\nfunction saveFileContent( filePathName, source ) {\n  // Compute encoding...\n  const fileInfo = { sourceEncoding: '' };\n\n  if( fileInfo.sourceEncoding == 'base64' ) {\n    var sourceBuffer = Buffer.from( source, 'base64' );\n    fs.writeFileSync( filePathName, sourceBuffer );\n  } else {\n    fs.writeFileSync( filePathName, source, 'utf8' );\n  }\n}",
      "fileTypeName": "Javascript",
      "fileType": "text/javascript",
      "key": 89,
      "location": "3020 2600",
      "group": 78
    },
    {
      "label": "This is the start file for code generation.\nIt needs 2 parameters:\n- modelFileURL: url of the model file\n- gropuKey: key of the group with the model to be code generated\n\nParameters should be specified in a json string, like:\n\nnode MainCodeGenerate.js {\"modelFileURL\":\"./41.json\",\"groupKey\":36}",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "720 208",
      "key": 91,
      "location": "3450 2642.5",
      "group": 78
    },
    {
      "label": "51",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 93,
      "location": "-2420 2740",
      "group": 36
    },
    {
      "label": "13",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 95,
      "location": "-2430 2820"
    },
    {
      "label": "39",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 97,
      "location": "-2430 2900"
    },
    {
      "label": "43",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 99,
      "location": "-2430 2980"
    },
    {
      "label": "47",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 101,
      "location": "-2430 3050"
    },
    {
      "label": "50",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 103,
      "location": "-2220 2730"
    },
    {
      "label": "7",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 105,
      "location": "-2220 2810"
    },
    {
      "label": "38",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 107,
      "location": "-2220 2890"
    },
    {
      "label": "42",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 109,
      "location": "-2220 2970"
    },
    {
      "label": "46",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 111,
      "location": "-2220 3060"
    },
    {
      "label": "15",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 113,
      "location": "-1500 2900"
    },
    {
      "label": "18",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 115,
      "location": "-970 2910"
    },
    {
      "label": "26",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 117,
      "location": "-400 2830"
    },
    {
      "label": "9",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 119,
      "location": "-390 2990"
    },
    {
      "label": "27",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 121,
      "location": "150 2830"
    },
    {
      "label": "19",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 123,
      "location": "140 2990"
    },
    {
      "label": "58",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 125,
      "location": "680 2920"
    },
    {
      "label": "25",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 127,
      "location": "1040 2920"
    },
    {
      "label": "45",
      "category": "TextLabels_Size1",
      "alignment": "0 0.5 0 0",
      "alignmentFocus": "0 0.5 0 0",
      "size": "34 35",
      "key": 129,
      "location": "1420 3020"
    }
  ],
  "linkDataArray": [
    {
      "category": "DataFlow_Standard",
      "from": 7,
      "to": 15,
      "points": [
        -1580.5380859375,
        2846.316,
        -1570.5380859375,
        2846.316,
        -1531.896484375,
        2956.316,
        -1521.896484375,
        2956.316
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -1
    },
    {
      "category": "DataFlow_Log",
      "from": 9,
      "to": 11,
      "points": [
        -99.5380859375,
        3046.316,
        -89.5380859375,
        3046.316,
        -60,
        3423.158,
        -50,
        3423.158
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -2
    },
    {
      "category": "DataFlow_Standard",
      "from": 13,
      "to": 7,
      "points": [
        -2279.5380859375,
        2846.316,
        -2269.5380859375,
        2846.316,
        -2231.896484375,
        2846.316,
        -2221.896484375,
        2846.316
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -3
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 15,
      "to": 18,
      "points": [
        -1194.5380859375,
        2956.316,
        -1184.5380859375,
        2956.316,
        -981.896484375,
        2955.916,
        -971.896484375,
        2955.916
      ],
      "key": -4
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 15,
      "to": 17,
      "points": [
        -1194.5380859375,
        2956.316,
        -1184.5380859375,
        2956.316,
        -1160,
        3310,
        -1150,
        3310
      ],
      "key": -5
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 9,
      "to": 19,
      "points": [
        -99.5380859375,
        3046.316,
        -89.5380859375,
        3046.316,
        118.103515625,
        3046.016,
        128.103515625,
        3046.016
      ],
      "key": -6
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 19,
      "to": 21,
      "points": [
        472.3515625,
        3036.016,
        482.3515625,
        3036.016,
        600,
        3219.316,
        610,
        3219.316
      ],
      "key": -7
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "2out",
      "toPort": "1in",
      "from": 19,
      "to": 23,
      "points": [
        472.3515625,
        3056.016,
        482.3515625,
        3056.016,
        598.103515625,
        3290,
        608.103515625,
        3290
      ],
      "key": -8
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 26,
      "to": 27,
      "points": [
        -99.5380859375,
        2886.316,
        -89.5380859375,
        2886.316,
        118.103515625,
        2885.8160000000003,
        128.103515625,
        2885.8160000000003
      ],
      "key": -10
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 27,
      "to": 28,
      "points": [
        471.3515625,
        2875.8160000000003,
        481.3515625,
        2875.8160000000003,
        600,
        2737.316,
        610,
        2737.316
      ],
      "key": -11
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "2out",
      "toPort": "1in",
      "from": 27,
      "to": 29,
      "points": [
        471.3515625,
        2895.8160000000003,
        481.3515625,
        2895.8160000000003,
        598.103515625,
        2810,
        608.103515625,
        2810
      ],
      "key": -12
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 26,
      "to": 31,
      "points": [
        -99.5380859375,
        2886.316,
        -89.5380859375,
        2886.316,
        -80,
        2583.158,
        -70,
        2583.158
      ],
      "key": -14
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 18,
      "to": 33,
      "points": [
        -657.2138671875,
        2945.916,
        -647.2138671875,
        2945.916,
        -631.896484375,
        2681.316,
        -621.896484375,
        2681.316
      ],
      "key": -15
    },
    {
      "category": "DataFlow_Log",
      "fromPort": "2out",
      "toPort": "1in",
      "from": 18,
      "to": 35,
      "points": [
        -657.2138671875,
        2965.916,
        -647.2138671875,
        2965.916,
        -630,
        3281.316,
        -620,
        3281.316
      ],
      "key": -16
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 27,
      "to": 58,
      "points": [
        471.3515625,
        2875.8160000000003,
        481.3515625,
        2875.8160000000003,
        614.6484375,
        2943.058,
        624.6484375,
        2943.058
      ],
      "key": -17
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "2out",
      "toPort": "2in",
      "from": 27,
      "to": 58,
      "points": [
        471.3515625,
        2895.8160000000003,
        481.3515625,
        2895.8160000000003,
        614.6484375,
        2963.058,
        624.6484375,
        2963.058
      ],
      "key": -18
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "3in",
      "from": 19,
      "to": 58,
      "points": [
        472.3515625,
        3036.016,
        482.3515625,
        3036.016,
        614.6484375,
        2983.058,
        624.6484375,
        2983.058
      ],
      "key": -19
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "2out",
      "toPort": "4in",
      "from": 19,
      "to": 58,
      "points": [
        472.3515625,
        3056.016,
        482.3515625,
        3056.016,
        614.6484375,
        3003.058,
        624.6484375,
        3003.058
      ],
      "key": -20
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "2out",
      "toPort": "1in",
      "from": 18,
      "to": 9,
      "points": [
        -657.2138671875,
        2965.916,
        -647.2138671875,
        2965.916,
        -421.896484375,
        3046.316,
        -411.896484375,
        3046.316
      ],
      "key": -21
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 18,
      "to": 26,
      "points": [
        -657.2138671875,
        2945.916,
        -647.2138671875,
        2945.916,
        -421.896484375,
        2886.316,
        -411.896484375,
        2886.316
      ],
      "key": -22
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 25,
      "to": 34,
      "points": [
        1349.4619140625,
        2973.158,
        1359.4619140625,
        2973.158,
        1408.103515625,
        2967.158,
        1418.103515625,
        2967.158
      ],
      "key": -23
    },
    {
      "category": "DataFlow_Standard",
      "from": 39,
      "to": 38,
      "points": [
        -2279.5380859375,
        2926.316,
        -2269.5380859375,
        2926.316,
        -2231.896484375,
        2926.216,
        -2221.896484375,
        2926.216
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -24
    },
    {
      "category": "DataFlow_Standard",
      "from": 43,
      "to": 42,
      "points": [
        -2279.5380859375,
        3006.316,
        -2269.5380859375,
        3006.316,
        -2231.896484375,
        3006.216,
        -2221.896484375,
        3006.216
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -25
    },
    {
      "category": "DataFlow_Standard",
      "from": 47,
      "to": 46,
      "points": [
        -2279.5380859375,
        3086.316,
        -2269.5380859375,
        3086.316,
        -2231.896484375,
        3086.316,
        -2221.896484375,
        3086.316
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -26
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 38,
      "to": 15,
      "points": [
        -1580.5380859375,
        2926.216,
        -1570.5380859375,
        2926.216,
        -1531.896484375,
        2956.316,
        -1521.896484375,
        2956.316
      ],
      "key": -27
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 42,
      "to": 15,
      "points": [
        -1580.5380859375,
        3006.216,
        -1570.5380859375,
        3006.216,
        -1531.896484375,
        2956.316,
        -1521.896484375,
        2956.316
      ],
      "key": -28
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 46,
      "to": 15,
      "points": [
        -1580.5380859375,
        3086.316,
        -1570.5380859375,
        3086.316,
        -1531.896484375,
        2956.316,
        -1521.896484375,
        2956.316
      ],
      "key": -29
    },
    {
      "category": "DataFlow_Standard",
      "from": 51,
      "to": 50,
      "points": [
        -2279.5380859375,
        2766.316,
        -2269.5380859375,
        2766.316,
        -2231.896484375,
        2766.316,
        -2221.896484375,
        2766.316
      ],
      "fromPort": "1out",
      "toPort": "1in",
      "key": -30
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 50,
      "to": 15,
      "points": [
        -1580.5380859375,
        2766.316,
        -1570.5380859375,
        2766.316,
        -1531.896484375,
        2956.316,
        -1521.896484375,
        2956.316
      ],
      "key": -31
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "",
      "toPort": "",
      "from": 37,
      "to": 36,
      "points": [
        1820,
        2219.7556447541588,
        1753.5,
        2219.6767630849918
      ],
      "key": -32,
      "color": "YellowGreen"
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "",
      "toPort": "",
      "from": 37,
      "to": 44,
      "points": [
        2232,
        2220,
        3110,
        2220
      ],
      "key": -33,
      "color": "YellowGreen"
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "label": "log",
      "from": 25,
      "to": 45,
      "points": [
        1349.4619140625,
        2973.158,
        1359.4619140625,
        2973.158,
        1408.103515625,
        3073.158,
        1418.103515625,
        3073.158
      ],
      "key": -34
    },
    {
      "category": "DataFlow_Standard",
      "fromPort": "1out",
      "toPort": "1in",
      "from": 58,
      "to": 25,
      "points": [
        970.4619140625,
        2973.058,
        980.4619140625,
        2973.058,
        1018.103515625,
        2973.158,
        1028.103515625,
        2973.158
      ],
      "key": -35
    },
    {
      "category": "CodeFlow_Code",
      "fromPort": "",
      "toPort": "",
      "from": 80,
      "to": 78,
      "points": [
        4330,
        2110.177459881757,
        4200.5,
        2110.2953114442566
      ],
      "key": -36,
      "color": "YellowGreen"
    },
    {
      "category": "CodeFlow_Code",
      "fromPort": "Feature",
      "toPort": "Feature",
      "from": 83,
      "to": 84,
      "points": [
        3798,
        1880,
        3850,
        1880,
        3860,
        1880
      ],
      "key": -37,
      "color": "RebeccaPurple"
    },
    {
      "category": "CodeFlow_Code",
      "fromPort": "1out",
      "toPort": "",
      "from": 86,
      "to": 44,
      "points": [
        3230.4619140625,
        1907.5000000000002,
        3240.4619140625,
        1907.5000000000002,
        3218.8923580741703,
        2157.5005345577338
      ],
      "key": -38,
      "color": "orange"
    },
    {
      "category": "CodeFlow_Code",
      "fromPort": "1out",
      "toPort": "",
      "from": 86,
      "to": 62,
      "points": [
        3230.4619140625,
        1907.5000000000002,
        3240.4619140625,
        1907.5000000000002,
        3224.5460899631817,
        2317.500052039712
      ],
      "key": -39,
      "color": "orange"
    }
  ]
}