{
  "dslNameList": [
    "HierarchyDSL",
    "TextLabelsDSL",
    "CodeFlowDSL",
    "PicturesDSL",
    "DataFlowDSL"
  ],
  "view": {
    "scale": 0.6574948076856473,
    "position": [
      -2371.0790126934567,
      922.4278244002671
    ],
    "isGridOn": false
  },
  "graphFileServer": [],
  "model": "{ \"class\": \"GraphLinksModel\",\n  \"copiesArrays\": true,\n  \"copiesArrayObjects\": true,\n  \"copiesKey\": false,\n  \"linkKeyProperty\": \"key\",\n  \"linkFromPortIdProperty\": \"fromPort\",\n  \"linkToPortIdProperty\": \"toPort\",\n  \"nodeDataArray\": [\n{\"label\":\"Graph Info\",\"category\":\"Hierarchy_GraphInfo\",\"size\":\"180 80\",\"props_\":[{\"name\":\"Name\",\"value\":\"label@6\",\"valueChanged\":true},{\"name\":\"Version\",\"value\":\"1.0\"},{\"name\":\"Date\",\"value\":\"20/01/2024\"},{\"name\":\"Path\",\"value\":\"/fileServer/02/41.json\"},{\"name\":\"Authors\",\"value\":\"Antonello\",\"valueChanged\":true}],\"key\":0,\"location\":\"390 -70\"},\n{\"label\":\"Model\",\"size\":\"180 60\",\"category\":\"Hierarchy_Model\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphModel$\",\"key\":2,\"location\":\"130 -70\"},\n{\"label\":\"Selection\",\"size\":\"180 60\",\"category\":\"Hierarchy_Selection\",\"isFile\":true,\"fileType\":\"text/json\",\"isSystem\":\"$GraphSelection$\",\"key\":4,\"location\":\"130 20\"},\n{\"label\":\"Test DataFlow & Code Generation v.1.2\",\"category\":\"TextLabels_Size6\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"5269 240\",\"key\":6,\"location\":\"660 -10\"},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  // Build the AST tree (recursive function)\\n  const outValue = buildAST( value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":9,\"location\":\"-880 3048.773\",\"editorPosition\":[1964,1907,466,193],\"group\":36},\n{\"label\":\"[\\n  \\\"+\\\",\\n  [\\n    \\\"+\\\",\\n    [\\n      \\\"*\\\",\\n      3,\\n      5\\n    ],\\n    \\\"alpha\\\"\\n  ],\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":11,\"location\":\"-498.103515625 3468.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":55},\n{\"label\":\"DataFlow Engine\",\"color\":\"orange\",\"size\":\"420 140\",\"category\":\"Hierarchy_CodeInFile\",\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"fileURL\":\"lib/DataFlowEngine/1.5/DataFlowEngine.js\",\"key\":8,\"location\":\"4150 950\",\"editorPosition\":[1087,1811,666,1123]},\n{\"label\":\"New Engine Instance \\n         onLoad\",\"color\":\"orange\",\"size\":\"430 80\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"DataFlowEngine.getInstance();\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":10,\"location\":\"4150 1110\",\"isIncludeScript\":true},\n{\"label\":\"Engine Control\",\"color\":\"DarkKhaki\",\"size\":\"416 110\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"<div style=\\\"display:grid\\\">\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.loadModel();\\\" style=\\\"font-size: 24px;\\\">Load Model</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.clearInstanceData();\\\" style=\\\"font-size: 24px;\\\">Clear Instance Data</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.doPause();\\\" style=\\\"font-size: 24px;\\\">Pause</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.doContinue();\\\" style=\\\"font-size: 24px;\\\">Continue</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setLogOn();\\\" style=\\\"font-size: 24px;\\\">Set Log On</button>\\n  <button type=\\\"Button\\\" onclick=\\\"graphData.dfe.setLogOff();\\\" style=\\\"font-size: 24px;\\\">Set Log Off</button>\\n</div>\",\"fileTypeName\":\"Web Page\",\"fileType\":\"application/html\",\"key\":12,\"location\":\"4160 1270\",\"isLocalDiv\":true,\"editorPosition\":[985,2598,400,350]},\n{\"label\":\"Equation Tokenizer\",\"category\":\"DataFlow_Component\",\"size\":\"255 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  // Split each line\\n  const lineList = value.split( '\\\\n' );\\n  for( const line of lineList ) {\\n    // Tokenize the input equation\\n    const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+/g;\\n    let tokenList = [];\\n    if( value ) {\\n      tokenList = line.match( regex ).map( token => {\\n        return( isNaN( token ) ? token : parseFloat( token ) );\\n      });\\n    }\\n    \\n    graphData.dfe.fireOutput( nodeData, 'out', tokenList );\\n  }\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":15,\"location\":\"-1970 2958.773\",\"group\":36,\"editorPosition\":[-4464,1910,494,263]},\n{\"label\":\"[\\n  \\\"var\\\",\\n  \\\"=\\\",\\n  3,\\n  \\\"*\\\",\\n  5,\\n  \\\"+\\\",\\n  \\\"alpha\\\",\\n  \\\"+\\\",\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 451\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":17,\"location\":\"-1598.103515625 3318.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":53},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"254 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"\\nvar nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = NaN;\\n  let outStatus = 'Done';\\n  try {\\n    if( value == null ) {\\n      outValue = '';\\n    } else {\\n      const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n      const variableValues = getVariableValues( variables );\\n\\n      outValue = evaluateAST( value, variableValues );\\n    }\\n  } catch( e ) {\\n    outStatus = `Syntax error in expression: ${e}`;\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\\n}\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":19,\"location\":\"-320 3068.773\",\"group\":36,\"editorPosition\":[2441,1906,560,417]},\n{\"label\":\"33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 64\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":21,\"location\":\"163.79296875 3224.431\",\"group\":56},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":23,\"location\":\"161.896484375 3295.1150000000002\",\"group\":56},\n{\"label\":\"Equation Split\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"lEq\"},{\"portId\":\"2out\",\"name\":\"rEq\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let i = value.indexOf( '=' );\\n  if( i == -1 ) {\\n    i = value.length;\\n  }\\n  \\n  const lEq = value.slice( 0, i );\\n  const rEq = value.slice( i+1 );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'lEq', lEq );\\n  graphData.dfe.fireOutput( nodeData, 'rEq', rEq );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":18,\"location\":\"-1420 2958.773\",\"group\":36},\n{\"label\":\"Equation Parser\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  // Build the AST tree (recursive function)\\n  const outValue = buildAST( value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"EquationParser\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":26,\"location\":\"-860 2798.773\",\"editorPosition\":[1270,1836,523,943],\"group\":36},\n{\"label\":\"Equation Compute\",\"category\":\"DataFlow_Component\",\"size\":\"253 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"status\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"\\nvar nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = NaN;\\n  let outStatus = 'Done';\\n  try {\\n    if( value == null ) {\\n      outValue = '';\\n    } else {\\n      const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n      const variableValues = getVariableValues( variables );\\n\\n      outValue = evaluateAST( value, variableValues );\\n    }\\n  } catch( e ) {\\n    outStatus = `Syntax error in expression: ${e}`;\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n  graphData.dfe.fireOutput( nodeData, 'status', outStatus );\\n}\",\"fileTypeName\":\"EquationCompute\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":27,\"location\":\"-320 2808.773\",\"group\":36},\n{\"label\":\"var\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"247 68\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":28,\"location\":\"163.79296875 2654.431\",\"group\":48},\n{\"label\":\"Done\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"617 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":29,\"location\":\"161.896484375 2727.1150000000002\",\"group\":48},\n{\"label\":\"var\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"125 511\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":31,\"location\":\"-518.103515625 2448.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":49},\n{\"label\":\"[\\n  \\\"var\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 352\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":33,\"location\":\"-1068.103515625 2588.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":52},\n{\"label\":\"[\\n  3,\\n  \\\"*\\\",\\n  5,\\n  \\\"+\\\",\\n  \\\"alpha\\\",\\n  \\\"+\\\",\\n  \\\"factor\\\"\\n]\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"114 293\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":35,\"location\":\"-1068.103515625 3288.773\",\"font\":\"17px sans-serif\",\"labelFont\":\"17px sans-serif\",\"group\":54},\n{\"label\":\"Equation Evaluate\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"},{\"portId\":\"2out\",\"name\":\"variable\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  let outValue = '';\\n  if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n    if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n      outValue = value.lValue || value.rValue;\\n    } else if( isVariable( value.lValue  ) ) {\\n      outValue = `${value.lValue} = ${value.rValue}`;\\n      const varValue = { id: value.lValue, value: value.rValue };\\n      graphData.dfe.fireOutput( nodeData, 'variable', varValue );\\n    } else if( isVariable( value.rValue ) ) {\\n      outValue = `${value.rValue} = ${value.lValue}`;\\n      const varValue = { id: value.rValue, value: value.lValue };\\n      graphData.dfe.fireOutput( nodeData, 'variable', varValue );\\n    } else {\\n      outValue = String( value.lValue == value.rValue );\\n    }\\n  } else {\\n    outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n  }\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":25,\"location\":\"580 2978.773\",\"group\":36,\"editorPosition\":[3690,1891,610,424]},\n{\"label\":\"var = 33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"364 72\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":34,\"location\":\"1000 2958.773\",\"group\":36},\n{\"label\":\"2+3*5-(2+20*0.5)+1\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 60\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":50,\"location\":\"-2700 2769.214\",\"group\":36},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":51,\"location\":\"-3680 2768.773\",\"group\":36},\n{\"label\":\"Simple Language Interpreter Model\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":36,\"location\":\"-3950 2940.815494140625\"},\n{\"label\":\"Executor: [Execution...Done]\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"412 120\",\"buttons_\":[{\"name\":\"Generate\",\"checked\":false},{\"name\":\"Execute\",\"checked\":true}],\"props_\":[],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\n// Generation Instance Data\\nconst gen = getGenInfo( nodeData );\\n\\nswitch( obj.data.name ) {\\n  \\n  case 'Generate':\\n    setNodeDataField( nodeData, 'label', 'Generator: [Generating...]' );\\n    const onGenerated = function( source, msg ) {\\n      if( msg.startsWith( 'Success:' ) ) {\\n        // Set target component source\\n        setNodeDataField( gen.targetData.key, 'fileContent', source );\\n      }\\n      // Update generator status\\n      setNodeDataField( nodeData, 'label', 'Generator: [Generation...Done]\\\\n'+msg );\\n    };\\n    \\n    if( gen.groupKey != null && gen.targetData ) {\\n      generationRoot( gen, onGenerated );\\n    } else {\\n      alert( 'Generation Components needs to have 2 fan out nodes:\\\\n'+\\n           '- Group (a group with a model, Group_BasicGroup),\\\\n'+\\n           '- Code (target source component, Hierarchy_CodeInGraph)' );\\n    }\\n    break;\\n  case 'Execute':\\n    setNodeDataField( nodeData, 'label', 'Executor: [Executing...]' );\\n    executeCode( gen );\\n    setNodeDataField( nodeData, 'label', 'Executor: [Execution...Done]' );\\n    break;\\n}\\n\\nfunction getGenInfo( nodeData ) {\\n  // Generation Instance Data\\n  const gen = {\\n    name: 'GenDFE 1.3',      // Code generator name and version\\n    groupKey: null,          // Group node key containing the Model to be generated\\n    targetData: null,        // Target node to store generated code\\n    me: null,                // ModelExplorer\\n    modelId: 'main',         // Model Id\\n    language: 'javascript',  // Target output language\\n  };\\n  \\n  // Initialize generation info\\n  const g = getMainGraph();\\n  // The model is the source of the WorkSpace (as found in the xx.json file)\\n  // it is in string form with full content\\n  const model = g.getJSONModel();\\n  // An alternative is to put in model the full source of the WorkSpace file\\n  // by reading it in text form from the server directory: .../xx/yy.json\\n  \\n  // Initialize ModelExplorer with full model\\n  gen.me = new ModelExplorer();\\n  gen.me.setJSONModel( gen.modelId, model );\\n  \\n  // Use Model to Code Generate\\n  const dataList = gen.me.getNodeListFanOutByNodeKey( gen.modelId, nodeData.key );\\n  // If at least a node has been found\\n  if( dataList && dataList.length ) {\\n    for( const data of dataList ) {\\n      if( data.category.startsWith( 'Group_' ) ) {\\n        gen.groupKey = data.key;\\n      } else if( data.category.startsWith( 'Hierarchy_CodeInGraph' ) ) {\\n        gen.targetData = data;\\n      }\\n    }\\n  }\\n  return( gen );\\n}\\nfunction executeCode( gen ) {\\n  console.log( 'Executing Generated Code...' );\\n  \\n  const source = gen.targetData.fileContent;\\n  eval( source );\\n  console.log( 'Execution Done.' );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":37,\"location\":\"1820 2080\",\"editorPosition\":[2562,1007,804,1305]},\n{\"label\":\"TargetCode.js\",\"color\":\"orange\",\"size\":\"211 124\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/*\\n * This file is code generated by GenDFE 1.3\\n * \\n * Generated on Thu, 25 Jan 2024 07:41:10 GMT\\n * \\n */\\n\\n\\n/*****************************************\\n * Node Functions\\n *****************************************/\\n// System function for reading properties\\nfunction DFE_getProperty( name, defaultValue ) {\\n  // NOTE: this function access both nodeData fields and properties\\n  if( this.nd_[name] != undefined ) {\\n    return( this.nd_[name] );\\n  } else if( this.nd_.props_[name] != undefined ) {\\n    return( this.nd_.props_[name] );\\n  } else {\\n    return( defaultValue );\\n  }\\n}\\n// System function for property data access\\nfunction DFE_getPropertyList() {\\n  return( this.nd_.props_ );\\n}\\n// System function for reading input\\nfunction DFE_getInput( name, defaultValue ) {\\n  if( this.in_[name] == undefined ) {\\n    this.in_[name] = defaultValue;\\n  }\\n  return( this.in_[name] );\\n}\\n// System function for storing input\\nfunction DFE_setInput( name, value ) {\\n  this.in_[name] = value;\\n}\\n// System function for getting input name list\\nfunction DFE_getInputNameList() {\\n  return( this.nd_.in_ );\\n}\\n// System function for getting output name list\\nfunction DFE_getOutputNameList() {\\n  return( this.nd_.out_ );\\n}\\n// System function for instance data access\\nfunction DFE_get( name, defaultValue ) {\\n  if( this.st_[name] == undefined ) {\\n    this.st_[name] = defaultValue;\\n  }\\n  return( this.st_[name] );\\n}\\n// System function for instance data storage\\nfunction DFE_set( name, value ) {\\n  this.st_[name] = value;\\n}\\n// System function for firing inputs\\nfunction DFE_fireInput( name, value ) {\\n  this.setInput( name, value );\\n  this.doCompute( name, value );\\n}\\n\\n\\n/*****************************************\\n * Node Functions/Model States\\n *****************************************/\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_9 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_19.setInput( 'in', value );\\n      nodeData_19.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Tokenizer\\nconst nodeData_15 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Tokenizer',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_18.setInput( 'in', value );\\n      nodeData_18.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_15,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_19 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rValue', value );\\n      nodeData_58.doCompute( 'rValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'rStatus', value );\\n      nodeData_58.doCompute( 'rStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Split\\nconst nodeData_18 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Split',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'lEq',\\n      'rEq',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'lEq' ) {\\n      // Store new input\\n      nodeData_26.setInput( 'in', value );\\n      nodeData_26.doCompute( 'in', value );\\n    } else if( name == 'rEq' ) {\\n      // Store new input\\n      nodeData_9.setInput( 'in', value );\\n      nodeData_9.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_18,\\n};\\n// Node Info: [DataFlow_Component] Equation Parser\\nconst nodeData_26 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Parser',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'in', value );\\n      nodeData_27.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationParser,\\n};\\n// Node Info: [DataFlow_Component] Equation Compute\\nconst nodeData_27 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Compute',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'status',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lValue', value );\\n      nodeData_58.doCompute( 'lValue', value );\\n    } else if( name == 'status' ) {\\n      // Store new input\\n      nodeData_58.setInput( 'lStatus', value );\\n      nodeData_58.doCompute( 'lStatus', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_EquationCompute,\\n};\\n// Node Info: [DataFlow_Component] Equation Evaluate\\nconst nodeData_25 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Equation Evaluate',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n      'variable',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_34.setInput( 'in', value );\\n      nodeData_34.doCompute( 'in', value );\\n      // Store new input\\n      nodeData_45.setInput( 'in', value );\\n      nodeData_45.doCompute( 'in', value );\\n    } else if( name == 'variable' ) {\\n      // Store new input\\n      nodeData_92.setInput( 'in', value );\\n      nodeData_92.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_25,\\n};\\n// Node Info: [DataFlow_Message] var = 33\\nconst nodeData_34 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'var = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1\\nconst nodeData_50 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Log Result\\nconst nodeData_45 = {\\n  in_: {},       // Input values\\n  nd_: {         // Full node fields/properties\\n    label: 'Log Result',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '*',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_45,\\n};\\n// Node Info: [DataFlow_Component] Barrier\\nconst nodeData_58 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Barrier',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'lValue',\\n      'lStatus',\\n      'rValue',\\n      'rStatus',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_25.setInput( 'in', value );\\n      nodeData_25.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_MakeObject,\\n};\\n// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor\\nconst nodeData_122 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: '2+3*5-(2+20*0.5)+1=z\\\\n2+3*5-(2+20*0.5)+1=10-4\\\\nvalue=3*5+10\\\\nfactor=2*beta\\\\n2+3*5-(2+20*0.5)+1=10-1\\\\nvar=3*5+alpha+factor',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_15.setInput( 'in', value );\\n      nodeData_15.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33\\nconst nodeData_88 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4\\\\nz = 6\\\\nvalue = 25\\\\nfactor = 8\\\\nvar = 33',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_27.setInput( 'variables', value );\\n      nodeData_27.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_19.setInput( 'variables', value );\\n      nodeData_19.doCompute( 'variables', value );\\n      // Store new input\\n      nodeData_92.setInput( 'variables', value );\\n      nodeData_92.doCompute( 'variables', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n// Node Info: [DataFlow_Component] Variable Update\\nconst nodeData_92 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'Variable Update',\\n    color: 'LightSeaGreen',\\n    in_: [       // Storage values \\n      'in',\\n      'variables',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n      'computeBarrier': '',\\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_Component_92,\\n};\\n// Node Info: [DataFlow_Message] alpha = 10\\\\nbeta = 4\\nconst nodeData_96 = {\\n  in_: {},       // Input values\\n  out_: {},      // Output values\\n  nd_: {         // Full node fields/properties\\n    label: 'alpha = 10\\\\nbeta = 4',\\n    in_: [       // Storage values \\n      'in',\\n    ],\\n    out_: [      // Storage values \\n      'out',\\n    ],\\n    props_: {    // Storage values \\n    },\\n  },\\n  st_: {},       // Storage values \\n  fireOutput: function ( name, value ) {\\n    if( name == 'out' ) {\\n      // Store new input\\n      nodeData_88.setInput( 'in', value );\\n      nodeData_88.doCompute( 'in', value );\\n    }\\n  },\\n  getProperty: DFE_getProperty,\\n  getPropertyList: DFE_getPropertyList,\\n  getInput: DFE_getInput,\\n  setInput: DFE_setInput,\\n  getInputNameList: DFE_getInputNameList,\\n  getOutputNameList: DFE_getOutputNameList,\\n  get: DFE_get,\\n  set: DFE_set,\\n  fireInput: DFE_fireInput,\\n  doCompute: compute_DataFlow_Message,\\n};\\n\\n/*****************************************\\n * Compute Functions\\n *****************************************/\\n// Node Compute[9]: [DataFlow_Component] Equation Parser\\nfunction compute_EquationParser( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Build the AST tree (recursive function)\\n    const outValue = buildAST( value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[15]: [DataFlow_Component] Equation Tokenizer\\nfunction compute_Component_15( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    // Split each line\\n    const lineList = value.split( '\\\\n' );\\n    for( const line of lineList ) {\\n      // Tokenize the input equation\\n      const regex = /\\\\d+(\\\\.\\\\d+)?|[\\\\+\\\\-\\\\*\\\\/\\\\(\\\\)]|=|[a-zA-Z1-9_]+/g;\\n      let tokenList = [];\\n      if( value ) {\\n        tokenList = line.match( regex ).map( token => {\\n          return( isNaN( token ) ? token : parseFloat( token ) );\\n        });\\n      }\\n      \\n      this.fireOutput( 'out', tokenList );\\n    }\\n  }\\n}\\n// Node Compute[19]: [DataFlow_Component] Equation Compute\\nfunction compute_EquationCompute( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = NaN;\\n    let outStatus = 'Done';\\n    try {\\n      if( value == null ) {\\n        outValue = '';\\n      } else {\\n        const variables = this.getInput( 'variables', '' );\\n        const variableValues = getVariableValues( variables );\\n  \\n        outValue = evaluateAST( value, variableValues );\\n      }\\n    } catch( e ) {\\n      outStatus = `Syntax error in expression: ${e}`;\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n    this.fireOutput( 'status', outStatus );\\n  }\\n}\\n// Node Compute[18]: [DataFlow_Component] Equation Split\\nfunction compute_Component_18( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let i = value.indexOf( '=' );\\n    if( i == -1 ) {\\n      i = value.length;\\n    }\\n    \\n    const lEq = value.slice( 0, i );\\n    const rEq = value.slice( i+1 );\\n    \\n    this.fireOutput( 'lEq', lEq );\\n    this.fireOutput( 'rEq', rEq );\\n  }\\n}\\n// Node Compute[25]: [DataFlow_Component] Equation Evaluate\\nfunction compute_Component_25( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    let outValue = '';\\n    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {\\n      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {\\n        outValue = value.lValue || value.rValue;\\n      } else if( isVariable( value.lValue  ) ) {\\n        outValue = `${value.lValue} = ${value.rValue}`;\\n        const varValue = { id: value.lValue, value: value.rValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else if( isVariable( value.rValue ) ) {\\n        outValue = `${value.rValue} = ${value.lValue}`;\\n        const varValue = { id: value.rValue, value: value.lValue };\\n        this.fireOutput( 'variable', varValue );\\n      } else {\\n        outValue = String( value.lValue == value.rValue );\\n      }\\n    } else {\\n      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );\\n    }\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Compute[34]: [DataFlow_Message] var = 33\\nfunction compute_DataFlow_Message( name, value ) {\\n  \\n  if( value == undefined ) {\\n    value = this.getProperty( 'label', '' );\\n    try {\\n      value = JSON.parse( value ); \\n    } catch( e ) {}\\n  }\\n  this.fireOutput( 'out', value );\\n}\\n// Node Compute[45]: [DataFlow_Component] Log Result\\nfunction compute_Component_45( name, value ) {\\n  \\n  console.log( value );\\n}\\n// Node Compute[58]: [DataFlow_Component] Barrier\\nfunction compute_MakeObject( name, value ) {\\n  \\n  const inNameList = this.getInputNameList( );\\n  const inputStat = this.get( 'inputStat', {} );\\n  \\n  inputStat[name] = true;\\n  let isObjectReady = true;\\n  for( const inName of inNameList ) {\\n    if( !inputStat[inName] ) {\\n      isObjectReady = false;\\n      break;\\n    }\\n  }\\n  \\n  if( isObjectReady ) {\\n    this.set( 'inputStat', {} );\\n    \\n    const outValue = {};\\n    for( const inName of inNameList ) {\\n      outValue[inName] = this.getInput( inName, null );\\n    }\\n    this.fireOutput( 'out', outValue );\\n  }\\n  \\n}\\n// Node Compute[92]: [DataFlow_Component] Variable Update\\nfunction compute_Component_92( name, value ) {\\n  \\n  if( name == 'in' ) {\\n    const variables = this.getInput( 'variables', '' );\\n    let outValue = updateVariableValue( variables, value.id, value.value );\\n    \\n    this.fireOutput( 'out', outValue );\\n  }\\n}\\n// Node Includes[94]: [Hierarchy_CodeInGraph] Helper Functions\\nfunction getVariableValues( variables ) {\\n  const result = {};\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    result[match[1]] = match[2];\\n  }\\n  return( result );\\n}\\nfunction updateVariableValue( variables, id, value ) {\\n  const result = [];\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n  let isVarUpdated = false;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    if( match[1] == id ) {\\n      isVarUpdated = true;\\n      result.push( `${match[1]} = ${value}` );\\n    } else {\\n     result.push( `${match[1]} = ${match[2]}` );\\n    }\\n  }\\n  if( !isVarUpdated ) {\\n    result.push( `${id} = ${value}` );\\n  }\\n  return( result.join( '\\\\n' ) );\\n}\\nfunction isVariable( str ) {\\n  return( RegExp( /^[a-z]/i ).test( str ) );\\n}\\nfunction buildAST( tokenList ) {\\n  if( tokenList.length == 0 ) {\\n    return( null );\\n  } else if( tokenList.length == 1 ) {\\n    return( tokenList[0] );\\n  }\\n\\n  // Find the index of the lowest precedence operator\\n  let index = -1;\\n  let minPrecedence = Infinity;\\n  let parenthesis = 0;\\n  // Loop over all tokenList\\n  for( let i = 0; i < tokenList.length; ++i ) {\\n    if( tokenList[i] == '(' ) {\\n      parenthesis++;\\n    } else if( tokenList[i] == ')' ) {\\n      parenthesis--;\\n    } else if( parenthesis === 0 ) {\\n      // Compute precedences\\n      const operator = tokenList[i];\\n      let precedence = 0;\\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\\n        precedence = 1;\\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n        precedence = 2;\\n      } else {\\n        precedence = Infinity;\\n      }\\n      \\n      if( precedence <= minPrecedence ) {\\n        minPrecedence = precedence;\\n        index = i;\\n      }\\n    }\\n  }\\n\\n  // Handle subexpressions inside parentheses\\n  if( index === -1 ) {\\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\\n  }\\n\\n  const result = [\\n    tokenList[index],\\n    buildAST( tokenList.slice( 0, index ) ),\\n    buildAST( tokenList.slice( index+1 ))\\n  ];\\n  return( result );\\n}\\nfunction evaluateAST( ast, variables ) {\\n  \\n  if( RegExp( /^[a-z_]/i ).test( ast ) ) {\\n    const varValue = variables[ast];\\n    if( varValue != undefined ) {\\n      return( parseFloat( varValue ) );\\n    } else {\\n      return( ast );\\n    }\\n  } else if( typeof( ast ) === 'number' ) {\\n    // Base case: if the node is a number, return it.\\n    return( ast );\\n  }\\n\\n  // Recursive case: evaluate the left and right operands.\\n  const left = evaluateAST( ast[1], variables );\\n  const right = evaluateAST( ast[2], variables );\\n\\n  // Compute the result based on the operator.\\n  switch( ast[0] ) {\\n    case '+':\\n      return( left + right );\\n    case '-':\\n      return( left - right );\\n    case '*':\\n      return( left * right );\\n    case '/':\\n      return( left / right );\\n    default:\\n      throw new Error( 'Unknown operator: ' + ast[0] );\\n  }\\n}\\n\\n/*****************************************\\n * System Start\\n *****************************************/\\nnodeData_96.doCompute( 'in' );\\nnodeData_50.doCompute( 'in' );\\nnodeData_96.doCompute( 'in' );\\nnodeData_122.doCompute( 'in' );\\n\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":44,\"location\":\"3100 2080\",\"group\":78,\"editorPosition\":[1449,992,670,1631]},\n{\"label\":\"Log Result\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"*\"}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nconsole.log( value );\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":45,\"location\":\"1000 3068.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":48,\"location\":\"110 2688.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":49,\"location\":\"-570 2448.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":52,\"location\":\"-1120 2588.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":53,\"location\":\"-1650 3318.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":54,\"location\":\"-1120 3288.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":55,\"location\":\"-550 3468.773\",\"group\":36},\n{\"label\":\"Log\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":56,\"location\":\"110 3258.773\",\"group\":36},\n{\"label\":\"Barrier\",\"category\":\"DataFlow_Component\",\"size\":\"240 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"lValue\"},{\"portId\":\"2in\",\"name\":\"lStatus\"},{\"portId\":\"3in\",\"name\":\"rValue\"},{\"portId\":\"4in\",\"name\":\"rStatus\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nconst inNameList = graphData.dfe.getInputNameList( nodeData );\\nconst inputStat = graphData.dfe.get( nodeData, 'inputStat', {} );\\n\\ninputStat[name] = true;\\nlet isObjectReady = true;\\nfor( const inName of inNameList ) {\\n  if( !inputStat[inName] ) {\\n    isObjectReady = false;\\n    break;\\n  }\\n}\\n\\nif( isObjectReady ) {\\n  graphData.dfe.set( nodeData, 'inputStat', {} );\\n  \\n  const outValue = {};\\n  for( const inName of inNameList ) {\\n    outValue[inName] = graphData.dfe.getInput( nodeData, inName, null );\\n  }\\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\\n\",\"fileTypeName\":\"MakeObject\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":58,\"location\":\"210 2978.773\",\"group\":36,\"editorPosition\":[2146,2191,674,512]},\n{\"label\":\"This WorkSpace demonstrate different concepts:\",\"category\":\"TextLabels_Size4\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"1689 92\",\"key\":59,\"location\":\"-1820 1560\"},\n{\"label\":\"1) Creation of a system through its model (Simple Language Interpreter Model)\\n2) Usage of the component model defined in DataFlowDSL+DataFlowEngine\\n3) Execution of a model by using DataFlowEngine\\n4) Code Generation of the model into a JavaScript program that do not depend from the DataFlowEngine\\n5) The execution of the generated code\",\"category\":\"TextLabels_Size3\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"2136 276\",\"key\":61,\"location\":\"-1800 1750\"},\n{\"label\":\"3) The system can be executed by pressing the start buttons\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"501 102\",\"key\":63,\"location\":\"-3920 2670\",\"group\":36},\n{\"label\":\"1) This model defines a simple programming language interpreter\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"556 114\",\"key\":65,\"location\":\"-1250 1980\"},\n{\"label\":\"2) The different components show examples of the component model usage. The code can be seen by clicking on the component's context menu and selecting \\\"Open File\\\"\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"698 145\",\"key\":67,\"location\":\"-1920 2818.773\",\"group\":36},\n{\"label\":\"NOTE: Log components are linked with a log link and are inserted into a group. These 2 choices make sure that such components are not included in the code-generation phase\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"613 145\",\"key\":69,\"location\":\"1010 2248.773\",\"group\":36},\n{\"label\":\"4) By clicking \\\"Generate\\\" the Equation Solver Model is code-generated into the Target Code  component\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"580 145\",\"key\":71,\"location\":\"2270 1970\"},\n{\"label\":\"5) By clicking \\\"Execute\\\" the code-generated system in the Target Code component is executed. Output can be seen in the JavaScript console\",\"category\":\"TextLabels_Size2\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"580 145\",\"key\":73,\"location\":\"2280 2220\"},\n{\"label\":\"NOTE: The DataFlow Engine is used to execute the Equation Solver Model from the model itself\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"374 102\",\"key\":75,\"location\":\"4650 930\"},\n{\"label\":\"This second component create a new instance of the DataFlow Engine once entered in the WorkSpace\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"372 102\",\"key\":77,\"location\":\"4650 1110\"},\n{\"label\":\"This is the DataFlow Engine Control Center. It can be opened by clicking on its context menu and selecting\\n\\\"Open File\\\"\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 117\",\"key\":79,\"location\":\"4650 1270\"},\n{\"label\":\"DFECodeGenerator.js\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":true,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',      // Code generator name and version\\n *          groupKey: null,          // Group node key containing the Model to be generated\\n *          me: null,                // ModelExplorer loaded with the model\\n *          modelId: 'main',         // Model Id\\n *          language: 'javascript',  // Target output language\\n *        };\\n *\\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    gen.lang = dfeCGConfig.lang[gen.language];\\n    gen.computeCount = {};                // Store usage of compute functions\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  // Add File Header with basic functions\\n  gen.lang.generateHeader( gen );\\n  \\n  // Generate Basic Node Functions\\n  gen.lang.generateLine( gen );\\n  gen.lang.generateSessionComment( gen, 'Node Functions' );\\n  gen.lang.generateNodeFunctions( gen );\\n        \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  gen.lang.generateLine( gen );\\n  gen.lang.generateSessionComment( gen, 'Node Functions/Model States' );\\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const ni = getNodeInfo( gen, data );\\n    if( ni ) {\\n      if( ( data.category == 'DataFlow_Component' ) || \\n          ( data.category == 'DataFlow_Message' ) ) {\\n        gen.lang.generateNodeState( gen, ni );\\n      }\\n    }\\n  }\\n  \\n  // Add function header\\n  gen.lang.generateSessionComment( gen, 'Compute Functions' );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n    } else if( ( data.category == 'DataFlow_Component' ) || \\n               ( data.category == 'DataFlow_Message' ) ) {\\n      // Get nodeInfo\\n      const ni = getNodeInfo( gen, data );\\n      if( ni ) {\\n        generateNodeCompute( gen, ni );\\n      }\\n    } else if( ( data.category == 'Hierarchy_CodeInGraph' ) &&\\n               ( data.isIncludeScript ) ) {\\n      // Get nodeInfo\\n      const ni = getNodeInfo( gen, data );\\n      if( ni ) {\\n        generateNodeInclude( gen, ni );\\n      }\\n    }\\n  }\\n  \\n  // Generate Start Calls\\n  if( gen.startNodeList.length ) {\\n    // Add start header lines\\n    gen.lang.generateSessionComment( gen, 'System Start' );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  if( onGenerated ) {\\n    // Save source in target component\\n    const content = gen.lines.join( '\\\\n' );\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    gen.lang.generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  // Get compute identifier\\n  let computeId = getComputeId( gen, ni );\\n  \\n  // Generate compute only if necessary\\n  if( !isComputeIfGenerated( gen, computeId ) ) {\\n    gen.lang.generateComputeFunction( gen, ni, computeId );\\n  }\\n  \\n  // Add one more usage of compute function\\n  addComputeId( gen, computeId );\\n}\\nfunction generateNodeInclude( gen, ni ) {\\n  if( ni.data.fileContent ) {\\n    gen.lang.generateLineComment( gen, `Node Includes[${ni.data.key}]: ${ni.descr}` );\\n    const lineList = ni.data.fileContent.split( '\\\\n' );\\n    // Add lines\\n    gen.lines = gen.lines.concat( lineList );\\n  }\\n}\\nfunction getComputeId( gen, ni ) {\\n  let result = null;\\n  \\n  if( ni.data.doCompute ) {\\n    result = ni.data.doCompute;\\n  } else if( ni.data.fileTypeName ) {\\n    result = ni.data.fileTypeName;\\n    if( ni.data.fileTypeName == 'Component' ) {\\n      result = `${result}_${ni.key}`;\\n    }\\n  } else {\\n    result = ni.key;\\n  }\\n  result = `compute_${result}`;\\n  \\n  return( result );\\n}\\nfunction isComputeIfGenerated( gen, computeId ) {\\n  return( gen.computeCount[computeId] >= 1 );\\n}\\nfunction addComputeId( gen, computeId ) {\\n  if( !gen.computeCount[computeId] ) {\\n    gen.computeCount[computeId] = 1;\\n  } else {\\n    ++gen.computeCount[computeId];\\n  }\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const label = ( data.label? data.label.replaceAll( '\\\\n', '\\\\\\\\n' ): data.key ); \\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${label}`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = gen.lang.computeList['DataFlow_Message'];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\\n\\nvar module;\\nif( module ) {\\n  module.exports = generationRoot;\\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":62,\"location\":\"3010 2260\",\"editorPosition\":[2311,924,719,1983],\"group\":78},\n{\"label\":\"This is the code generator library.\\nNOTE: it is an include file for this workspace, as well as a file to be deployed on the server\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 58\",\"key\":64,\"location\":\"3440 2230\"},\n{\"label\":\"\",\"category\":\"Pictures_Basic\",\"size\":\"3225 1881\",\"isFile\":true,\"fileTypeName\":\"Image\",\"fileType\":\"image/png\",\"fileURL\":\"/fileServer/pictures/Test DataFlow & Code Generation-2.png\",\"key\":66,\"location\":\"8070 3620\"},\n{\"label\":\"Includes\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"2151 154\",\"key\":60,\"location\":\"3570 580\",\"color\":\"LightGreen\"},\n{\"label\":\"Screenshot\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"3539 154\",\"key\":70,\"location\":\"6380 1380\",\"color\":\"Yellow\"},\n{\"label\":\"  Development WorkSpace\",\"category\":\"TextLabels_Size5\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"6777 154\",\"key\":68,\"location\":\"-3949 930\",\"color\":\"#d2b4de\"},\n{\"label\":\"MainCodeGenerate.js 1.0\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '// System function for reading input',\\n    'function node_getInput( node, name, defaultValue ) {',\\n    '  if( node.in_[name] == undefined ) {',\\n    '    node.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( node.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function node_setInput( node, name, value ) {',\\n    '  node.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function node_get( node, name, defaultValue ) {',\\n    '  if( node.st_[name] == undefined ) {',\\n    '    node.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( node.st_[name] );',\\n    '}',\\n    '' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      generateNodeState( gen, nodeInfo );\\n      generateNodeCompute( gen, nodeInfo );\\n      generateNodeFire( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    gen.lines.push( '' );\\n    gen.lines.push( '/********************' );\\n    gen.lines.push( ' * System Start' );\\n    gen.lines.push( ' ********************/' );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  gen.lines.push( `const node_${ni.key} = {` );\\n  gen.lines.push( `  in_:  {}, // Input` );\\n  gen.lines.push( `  st_:  {}, // Storage` );\\n  gen.lines.push( `  out_: {}, // Output` );\\n  gen.lines.push( `};` );\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\\n  gen.lines.push( `` );\\n  gen.lines.push( `  // Store new input` );\\n  gen.lines.push( `  node_setInput( node_${ni.key}, name, value );` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `fire_${ni.key}(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `node_getInput( node_${ni.key},` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `node_get( node_${ni.key},` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  if( portLen ) {\\n    // Generate fire function\\n    gen.lines.push( `function fire_${ni.key}( name, value ) {` );\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n    gen.lines.push( `}` );\\n  }\\n}\\nfunction generateLinkCall( gen, indent, link, value ) {\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  if( value ) {\\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}compute_${link.to}( '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, '', link );\\n  }\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: ( data.label? data.label: data.key ),\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n    gen.lines.push( `// Node: ${nodeInfo.descr}` );\\n    \\n  } else if( data.category == 'DataFlow_Message' ) {\\n    gen.lines.push( `// Node: Message \\\"${nodeInfo.descr}\\\"` );\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      `  value = \\\"${nodeInfo.label}\\\";`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `fire_${nodeInfo.key}( 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":72,\"location\":\"2410 1130\"},\n{\"label\":\"MainCodeGenerate.js 1.1\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, ... );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '/********************',\\n    ' * Node Functions',\\n    ' ********************/',\\n    '// System function for reading properties',\\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\\n    '  // NOTE: this function access both nodeData fields and properties',\\n    '  if( nodeData.nd_[name] != undefined ) {',\\n    '    return( nodeData.nd_[name] );',\\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\\n    '    return( nodeData.nd_.props_[name] );',\\n    '  } else {',\\n    '    return( defaultValue );',\\n    '  }',\\n    '}',\\n    '// System function for reading input',\\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.in_[name] == undefined ) {',\\n    '    nodeData.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function nodeData_setInput( nodeData, name, value ) {',\\n    '  nodeData.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function nodeData_get( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.st_[name] == undefined ) {',\\n    '    nodeData.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.st_[name] );',\\n    '}',\\n    '// System function for firing inputs',\\n    'function nodeData_fireInput( nodeData, name, value ) {',\\n    '  nodeData_setInput( nodeData, name, value );',\\n    '  nodeData.doCompute( nodeData, name, value );',\\n    '}',\\n    '',\\n    '/********************',\\n    ' * Model Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\\n      generateNodeFire( gen, nodeInfo );\\n      generateNodeState( gen, nodeInfo );\\n    }\\n  }\\n  \\n  const funcHeader = [\\n    '',\\n    '/********************',\\n    ' * Compute Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( funcHeader );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\\n      generateNodeCompute( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    const sysStart =[\\n      '',\\n      '/********************',\\n      ' * System Start',\\n      ' ********************/' ];\\n    // Add lines\\n    gen.lines = gen.lines.concat( sysStart );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  const nodeDataObj = [\\n    `const nodeData_${ni.key} = {`,\\n    `  in_: {},     // Input`,\\n    `  st_: {},     // Storage`,\\n    `  nd_: { // Properties`,\\n    `    label: '${ni.data.label}',`, // Some fields could be put here\\n    '    props_: {}', // It could be translated here into key,value?\\n    `  },`,\\n    `  out_: {},     // Output`,\\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\\n    `  doCompute: compute_${ni.key},     // Node compute function`,\\n    `};` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObj );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  \\n  // Generate fire function\\n  gen.lines.push( `function fireOutput_${ni.key}( nodeData, name, value ) {` );\\n  // Generate fire body\\n  if( portLen ) {\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, ni, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateLinkCall( gen, ni, indent, link, value ) {\\n  // Check link type\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  \\n  // Get target input port name\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  // Generate input update if node info is defined\\n  if( ni ) {\\n    gen.lines.push( `${indent}// Store new input` );\\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\\n  }\\n  // Generate compute call\\n  if( value ) {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( nodeData_${link.to}, '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( nodeData, name, value ) {` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `nodeData.fireOutput(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `nodeData_getInput(` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `nodeData_get(` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      //`  value = \\\"${nodeInfo.label}\\\";`,\\n      `  value = nodeData_getProperty( nodeData, 'label', '' );`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `nodeData.fireOutput( nodeData, 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":76,\"location\":\"2410 1300\",\"editorPosition\":[3188,1027,876,1871]},\n{\"label\":\"MainCodeGenerate.js 1.2\",\"color\":\"orange\",\"size\":\"406 144\",\"category\":\"Hierarchy_CodeInGraph\",\"isIncludeScript\":false,\"isFile\":true,\"fileContent\":\"/**\\n * This is an example of Code Generator based on the conventions\\n * of the component model and the DataFlow Engine execution model\\n *\\n * The main function to start code generation is:\\n *    generationRoot( gen, callback )\\n * Where:\\n *   gen: is a data structure with the following information\\n *        {\\n *          name: 'GenDFE 1.0',  // Code generator name and version\\n *          groupKey: null,       // Group node key containing the Model to be generated\\n *          me: null,             // ModelExplorer loaded with the model\\n *          modelId: 'main',      // Model Id\\n *        };\\n * \\n *   callback: a function( source, msg ) executed at the end of\\n *             the generation process. Source is the generated source\\n *             code, while msg is a message starting with Success:/Error:\\n */\\n\\nfunction generationRoot( gen, onGenerated ) {\\n  console.log( 'Starting Generation...' );\\n  \\n  // If nodes are found ==> start generation\\n  if( gen.groupKey != null ) {\\n    // Extend generation info\\n    gen.lines = [];                      // Number of lines of code generate\\n    gen.date = new Date().toGMTString(); // Generation date info\\n    gen.startNodeList = [],              // Start nodes\\n    // Match line: var nodeData, name, value;\\n    gen.declLine = RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ );\\n    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n    gen.fireLine = RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n    gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ );\\n    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n    gen.getLine = RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ );\\n    //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n    \\n    // Start generation\\n    generateGroup( gen, onGenerated );\\n  } else {\\n    if( onGenerated ) {\\n      onGenerated( '', 'Error: group key not found in gen parameter' );\\n    }\\n  }\\n}\\nfunction generateGroup( gen, onGenerated ) {\\n  const header = [ \\n    '/*',\\n    ` * This file is code generated by ${gen.name}`,\\n    ' *',\\n    ` * Generated on ${gen.date}`,\\n    ' */',\\n    '',\\n    '/********************',\\n    ' * Node Functions',\\n    ' ********************/',\\n    '// System function for reading properties',\\n    'function nodeData_getProperty( nodeData, name, defaultValue ) {',\\n    '  // NOTE: this function access both nodeData fields and properties',\\n    '  if( nodeData.nd_[name] != undefined ) {',\\n    '    return( nodeData.nd_[name] );',\\n    '  } else if( nodeData.nd_.props_[name] != undefined ) {',\\n    '    return( nodeData.nd_.props_[name] );',\\n    '  } else {',\\n    '    return( defaultValue );',\\n    '  }',\\n    '}',\\n    '// System function for reading input',\\n    'function nodeData_getInput( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.in_[name] == undefined ) {',\\n    '    nodeData.in_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.in_[name] );',\\n    '}',\\n    '// System function for storing access',\\n    'function nodeData_setInput( nodeData, name, value ) {',\\n    '  nodeData.in_[name] = value;',\\n    '}',\\n    '// System function for instance data access',\\n    'function nodeData_get( nodeData, name, defaultValue ) {',\\n    '  if( nodeData.st_[name] == undefined ) {',\\n    '    nodeData.st_[name] = defaultValue;',\\n    '  }',\\n    '  return( nodeData.st_[name] );',\\n    '}',\\n    '// System function for firing inputs',\\n    'function nodeData_fireInput( nodeData, name, value ) {',\\n    '  nodeData_setInput( nodeData, name, value );',\\n    '  nodeData.doCompute( name, value );',\\n    '}',\\n    '',\\n    '/********************',\\n    ' * Model Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( header );\\n  \\n  // Get all nodes in the group\\n  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );\\n  \\n  // Generate instance data for all nodes\\n  for( const data of dataList ) {\\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Info: ${nodeInfo.descr}` );\\n      generateNodeFire( gen, nodeInfo );\\n      generateNodeState( gen, nodeInfo );\\n    }\\n  }\\n  \\n  const funcHeader = [\\n    '',\\n    '/********************',\\n    ' * Compute Functions',\\n    ' ********************/' ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( funcHeader );\\n  \\n  // Generate compute function for all nodes\\n  for( const data of dataList ) {\\n    // Get nodeInfo\\n    if( data.category == 'DataFlow_Start' ) {\\n      gen.startNodeList.push( data );\\n      continue;\\n    }\\n    \\n    const nodeInfo = getNodeInfo( gen, data );\\n    if( nodeInfo ) {\\n      gen.lines.push( `// Node Compute: ${nodeInfo.descr}` );\\n      generateNodeCompute( gen, nodeInfo );\\n    }\\n  }\\n  \\n  if( gen.startNodeList.length ) {\\n    // Generate start functions\\n    const sysStart =[\\n      '',\\n      '/********************',\\n      ' * System Start',\\n      ' ********************/' ];\\n    // Add lines\\n    gen.lines = gen.lines.concat( sysStart );\\n    // Generate Start Nodes\\n    for( const data of gen.startNodeList ) {\\n      generateStartNode( gen, data );\\n    }\\n    gen.lines.push( '' );\\n  }\\n  \\n  // Save source in target component\\n  const content = gen.lines.join( '\\\\n' );\\n  if( onGenerated ) {\\n    // Generate closing event\\n    onGenerated( content, `Success: ${gen.lines.length} lines` );\\n  }\\n}\\nfunction generateNodeState( gen, ni ) {\\n  const nodeDataObjOpen = [\\n    `const nodeData_${ni.key} = {`,\\n    `  in_: {},     // Input`,\\n    `  st_: {},     // Storage`,\\n    `  nd_: { // Properties`,\\n    `    label: '${ni.data.label}',`, // Some fields could be put here\\n    '    props_: {}', // It could be translated here into key,value?\\n    `  },`,\\n    `  out_: {},     // Output`,\\n    `  fireOutput: fireOutput_${ni.key}, // Output fire function`,\\n    `  doCompute: compute_${ni.key},     // Node compute function`,\\n    `};` ];\\n  // Add lines\\n  gen.lines = gen.lines.concat( nodeDataObjOpen );\\n}\\nfunction generateNodeFire( gen, ni ) {\\n  // Get out port list\\n  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n  const portLen = outPortList.length\\n  \\n  // Generate fire function\\n  gen.lines.push( `function fireOutput_${ni.key}( name, value ) {` );\\n  // Generate fire body\\n  if( portLen ) {\\n    gen.lines.push( `  if( name == '${outPortList[0]}' ) {` );\\n    // Loop on each output port\\n    for( let i = 0; i < portLen; ++i ) {\\n      const portName = outPortList[i];\\n      if( i > 0 ) {\\n        gen.lines.push( `  } else if( name == '${portName}' ) {` );\\n      }\\n      \\n      // Get output links\\n      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n      for( const link of linkList ) {\\n        generateLinkCall( gen, ni, '    ', link, 'value' );\\n      }\\n    }\\n    gen.lines.push( `  }` );\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction generateLinkCall( gen, ni, indent, link, value ) {\\n  // Check link type\\n  if( link.category == 'DataFlow_Log' ) {\\n      return;\\n  } else if( link.category == 'DataFlow_Pause') {\\n    gen.lines.push( `${indent}debugger` );\\n  }\\n  \\n  // Get target input port name\\n  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n  // Generate input update if node info is defined\\n  if( ni ) {\\n    gen.lines.push( `${indent}// Store new input` );\\n    gen.lines.push( `${indent}nodeData_setInput( nodeData_${link.to}, '${toPortName}', value );` );\\n  }\\n  // Generate compute call\\n  if( value ) {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\\n  } else {\\n    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\\n  }\\n}\\nfunction generateStartNode( gen, data ) {\\n  // Get output links\\n  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );\\n  for( const link of linkList ) {\\n    generateLinkCall( gen, null, '', link );\\n  }\\n}\\nfunction generateNodeCompute( gen, ni ) {\\n  let isMainDeclSkipped = false;\\n  \\n  // Generate compute function\\n  gen.lines.push( `function compute_${ni.key}( name, value ) {` );\\n  for( let line of ni.src ) {\\n    if( !isMainDeclSkipped ) {\\n      if( gen.declLine.test( line ) ) {\\n        isMainDeclSkipped = true;\\n      }\\n    } else {\\n      if( gen.fireLine.test( line ) ) {\\n        line = line.replace( gen.fireLine, `this.fireOutput(` );\\n      } else if( gen.getInLine.test( line ) ) {\\n        line = line.replace( gen.getInLine, `nodeData_getInput( this,` );\\n      } else if( gen.getLine.test( line ) ) {\\n        line = line.replace( gen.getLine, `nodeData_get( this,` );\\n      }\\n      gen.lines.push( `  ${line}` );\\n    }\\n  }\\n  gen.lines.push( `}` );\\n}\\nfunction getNodeInfo( gen, data ) {\\n  const nodeInfo = {\\n    data,\\n    src: null,\\n    key: data.key,\\n    label: data.label,\\n    descr: `[${data.category}] ${ data.label? data.label: data.key }`,\\n  };\\n  \\n  if( data.fileContent ) {\\n    nodeInfo.src = data.fileContent.split( '\\\\n' );\\n  } else if( data.category == 'DataFlow_Message' ) {\\n    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\\\\n' );\\n    nodeInfo.src = [ \\n      `var nodeData, name, value;`,\\n      ``,\\n      `if( value == undefined ) {`,\\n      //`  value = \\\"${nodeInfo.label}\\\";`,\\n      `  value = nodeData_getProperty( this, 'label', '' );`,\\n      `  try {`,\\n      `    value = JSON.parse( value ); `,\\n      `  } catch( e ) {}`,\\n      `}`,\\n      `this.fireOutput( 'out', value );` \\n    ];\\n  }\\n  \\n  return( nodeInfo.src? nodeInfo: null );  \\n}\",\"fileTypeName\":\"JavaScript\",\"fileType\":\"text/javascript\",\"key\":74,\"location\":\"2420 1480\",\"editorPosition\":[3188,1027,876,1871]},\n{\"label\":\"DFEGen/1.3.2\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":78,\"location\":\"2990 2235.75\"},\n{\"label\":\"System Status: [DEPLOYED]\\ndone\\nFilesCount: 4 of 5\\nDirCount: 1 of 1\",\"category\":\"CodeFlow_Button\",\"color\":\"YellowGreen\",\"size\":\"390 120\",\"buttons_\":[{\"name\":\"Deploy\",\"checked\":true},{\"name\":\"Start\",\"checked\":true},{\"name\":\"Stop\",\"checked\":false}],\"props_\":[{\"name\":\"isOverwrite\",\"value\":\"true\",\"valueChanged\":\"true\"},{\"name\":\"scriptPath\",\"value\":\"DFEGen/1.3.2\",\"valueChanged\":\"true\"}],\"isFile\":true,\"fileContent\":\"var event, obj, nodeData;\\n  // Uncomment the next line to start debugging\\n  //debugger;\\n//console.log( 'NodeData Info: '+JSON.stringify( nodeData ) );\\n//console.log( 'Button Label: '+obj.data.name );\\n//console.log( 'Button Status: '+obj.data.checked );\\n\\nlet script = '';\\nlet params = '';\\nconst scriptPath = getProperty( 'scriptPath' );\\n//const g = getMainGraph();\\nlet onLoaded = function(){};\\n\\nswitch( obj.data.name ) {\\n  case 'Deploy':\\n    const modelFileURL = getMainGraphURL();\\n    const deployKey = nodeData.key;\\n    \\n    script = `generateSystemLib.js`;\\n    params = `modelFileURL=${modelFileURL}&deployKey=${deployKey}`;\\n    onLoaded = function( msg ) {\\n      setNodeDataField( nodeData, 'label', 'System Status: [DEPLOYED]\\\\n'+msg );\\n    }\\n    break;\\n  case 'Start':\\n    script = 'serverManager';\\n    params = 'start '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STARTED]' );\\n    break;\\n  case 'Stop':\\n    script = 'serverManager';\\n    params = 'stop '+scriptPath;\\n    setNodeDataField( nodeData, 'label', 'System Status: [STOPPED]' );\\n    break;\\n}\\n\\nif( script ) {\\n  const cmd = `${script}${( params? '?'+params: '')}`;\\n  executeScript( cmd, onLoaded );\\n}\\n\\nfunction getProperty( name ) {\\n  let result = '';\\n  if( nodeData.props_ ) {\\n    nodeData.props_.find( (p)=> { if( p.name == name ) { result = p.value; return( true ) } } );\\n  }\\n  return( result );\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":80,\"location\":\"4990 1950\",\"editorPosition\":[3132,1920,758,959]},\n{\"label\":\"This is the reference generated target program (generated on the client)\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"391 58\",\"key\":82,\"location\":\"3430 2050\"},\n{\"label\":\"Releases & Features\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":81,\"location\":\"3430 1740\"},\n{\"label\":\"DFEGenerator 1.3\",\"category\":\"CodeFlow_FeatureOnOff\",\"size\":\"338 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":83,\"location\":\"3450 1740\",\"group\":81},\n{\"label\":\"DummyEnable\",\"category\":\"CodeFlow_Feature\",\"size\":\"180 40\",\"color\":\"green\",\"buttons_\":[{\"name\":\"\",\"checked\":true,\"color\":\"RebeccaPurple\"}],\"key\":84,\"location\":\"3850 1740\",\"group\":81},\n{\"label\":\"Dummy Enabled Component\",\"category\":\"CodeFlow_Code\",\"size\":\"180 100\",\"color\":\"orange\",\"props_\":[],\"in_\":[],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"isFile\":true,\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":86,\"location\":\"2730 1757.5000000000002\",\"group\":87},\n{\"label\":\"DummyEnable\",\"category\":\"Group_BasicGroup\",\"isGroup\":true,\"key\":87,\"location\":\"2710 1760.0000000000002\",\"color\":\"green\"},\n{\"label\":\"MainCodeGenerate.js\",\"color\":\"orange\",\"size\":\"404 132\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/**\\n * MainCodeGenerator.js\\n * \\n * Usage:\\n * \\n *  node MainCodeGenerate.js \\\"{\\\\\\\"modelFileURL\\\\\\\":\\\\\\\"./41.json\\\\\\\",\\\\\\\"groupKey\\\\\\\":36}\\\"\\n * \\n */\\n\\nconst fs = require( 'fs' );\\n\\nconsole.log( 'Code Generation started' );\\n\\nconst ModelExplorer = require( './ModelExplorer.js' );\\nconst dfeCGConfig = require( './DFEConfig.js' );\\nconst generationRoot = require( './DFECodeGenerator.js' );\\nconst isServer = true;\\n\\nlet args = '';\\nconsole.log( 'Arguments:' );\\nconsole.log( JSON.stringify( process.argv, null, 2 ) );\\nconsole.log();\\n\\nif( process.argv ) { // Case of execution from the shell\\n  args = process.argv[2];\\n  const output = initGeneration( args );\\n  console.log( output );\\n} else {\\n  console.log( 'Error, no parameters found' );\\n}\\n\\nfunction initGeneration( args ) {\\n  params = null;\\n  try {\\n    params = JSON.parse( args );\\n  } catch( e ) {\\n    console.log( 'Error in parameters' );\\n    return;\\n  }\\n  const modelFileURL = params.modelFileURL;\\n  const groupKey = params.groupKey;\\n\\n  startGeneration( modelFileURL, groupKey );\\n}\\n\\nfunction startGeneration( fileURL, groupKey ) {\\n  // Generation Instance Data\\n  const gen = {\\n    name: 'GenDFE 1.3',      // Code generator name and version\\n    groupKey,                // Group node key containing the Model to be generated\\n    me: null,                // ModelExplorer\\n    modelId: 'main',         // Model Id\\n    language: 'javascript',  // Target output language\\n  };\\n\\n  // Get graph source\\n  const graph = getModel( fileURL );\\n  try {\\n    // Get model\\n    const graphObj = JSON.parse( graph );\\n    const model = graphObj.model;\\n\\n    // Model ID for the current graph\\n    gen.modelId = 'main';\\n    // Create a new Model Explorer\\n    gen.me = new ModelExplorer();\\n    // Load current graph model in Model Explorer\\n    gen.me.setJSONModel( gen.modelId, model );\\n  } catch( e ) {}\\n\\n  const onGenerated = function( source, msg ) {\\n    if( msg.startsWith( 'Success:' ) ) {\\n      // Save target component source\\n      const filePathName = './OutCode.js';\\n      saveFileContent( filePathName, source );\\n    }\\n  }\\n\\n  generationRoot( gen, onGenerated );\\n}\\nfunction getModel( fileURL ) {\\n  let model = '{}';\\n\\n  if( isServer ) {\\n    try {\\n      model = fs.readFileSync( fileURL, 'utf8' );\\n    } catch( e ) {}\\n  } else {\\n    // Get current graph model\\n    const g = getMainGraph();\\n    model = g.getJSONModel();\\n  }\\n  return( model );\\n}\\nfunction saveFileContent( filePathName, source ) {\\n  // Compute encoding...\\n  const fileInfo = { sourceEncoding: '' };\\n\\n  if( fileInfo.sourceEncoding == 'base64' ) {\\n    var sourceBuffer = Buffer.from( source, 'base64' );\\n    fs.writeFileSync( filePathName, sourceBuffer );\\n  } else {\\n    fs.writeFileSync( filePathName, source, 'utf8' );\\n  }\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":89,\"location\":\"4060 2060\",\"group\":78},\n{\"label\":\"This is the start file for code generation.\\nIt needs 2 parameters:\\n- modelFileURL: url of the model file\\n- gropuKey: key of the group with the model to be code generated\\n\\nParameters should be specified in a json string, like:\\n\\nnode MainCodeGenerate.js \\\"{\\\\\\\"modelFileURL\\\\\\\":\\\\\\\"./41.json\\\\\\\",\\\\\\\"groupKey\\\\\\\":36}\\\"\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"789 208\",\"key\":91,\"location\":\"4060 2250\",\"group\":78},\n{\"label\":\"51\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":93,\"location\":\"-3700 2738.773\",\"group\":36},\n{\"label\":\"50\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":103,\"location\":\"-2730 2733.029\",\"group\":36},\n{\"label\":\"15\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":113,\"location\":\"-2000 2908.773\",\"group\":36},\n{\"label\":\"18\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":115,\"location\":\"-1450 2918.773\",\"group\":36},\n{\"label\":\"26\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":117,\"location\":\"-890 2748.773\",\"group\":36},\n{\"label\":\"9\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":119,\"location\":\"-900 2998.773\",\"group\":36},\n{\"label\":\"27\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":121,\"location\":\"-350 2758.773\",\"group\":36},\n{\"label\":\"19\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":123,\"location\":\"-350 3018.773\",\"group\":36},\n{\"label\":\"58\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":125,\"location\":\"180 2918.773\",\"group\":36},\n{\"label\":\"25\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":127,\"location\":\"550 2928.773\",\"group\":36},\n{\"label\":\"45\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":129,\"location\":\"970 3008.773\",\"group\":36},\n{\"label\":\"118\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":116,\"location\":\"-3710 2818.773\",\"group\":36},\n{\"label\":\"\",\"category\":\"DataFlow_Start\",\"size\":\"80 80\",\"buttons_\":[{\"name\":\"Start\",\"checked\":false}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"key\":118,\"location\":\"-3680 2858.773\",\"group\":36},\n{\"label\":\"122\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"42 35\",\"key\":120,\"location\":\"-2740 2822.898\",\"group\":36},\n{\"label\":\"2+3*5-(2+20*0.5)+1=z\\n2+3*5-(2+20*0.5)+1=10-4\\nvalue=3*5+10\\nfactor=2*beta\\n2+3*5-(2+20*0.5)+1=10-1\\nvar=3*5+alpha+factor\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 364\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":122,\"location\":\"-2700 3001.398\",\"group\":36},\n{\"label\":\"alpha = 10\\nbeta = 4\\nz = 6\\nvalue = 25\\nfactor = 8\\nvar = 33\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"569 458\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":88,\"location\":\"-2690 2428.773\",\"group\":36},\n{\"label\":\"Variable Update\",\"category\":\"DataFlow_Component\",\"size\":\"249 80\",\"color\":\"LightSeaGreen\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"},{\"portId\":\"2in\",\"name\":\"variables\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"props_\":[{\"name\":\"computeBarrier\",\"value\":\"\",\"valueChanged\":true}],\"isFile\":true,\"fileContent\":\"var nodeData, name, value;\\n\\nif( name == 'in' ) {\\n  const variables = graphData.dfe.getInput( nodeData, 'variables', '' );\\n  let outValue = updateVariableValue( variables, value.id, value.value );\\n  \\n  graphData.dfe.fireOutput( nodeData, 'out', outValue );\\n}\",\"fileTypeName\":\"Component\",\"fileType\":\"text/javascript\",\"iconURL\":\"\",\"key\":92,\"location\":\"1000 3188.773\",\"group\":36,\"editorPosition\":[2861,2205,778,494]},\n{\"label\":\"Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"344 44\",\"key\":95,\"location\":\"-2680 2178.773\",\"group\":36},\n{\"label\":\"92\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":97,\"location\":\"970 3138.773\",\"group\":36},\n{\"label\":\"34\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":99,\"location\":\"980 2908.773\",\"group\":36},\n{\"label\":\"Helper Functions\",\"color\":\"orange\",\"size\":\"400 180\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"function getVariableValues( variables ) {\\n  const result = {};\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    result[match[1]] = match[2];\\n  }\\n  return( result );\\n}\\nfunction updateVariableValue( variables, id, value ) {\\n  const result = [];\\n  // Match: var = 10\\n  const regex = /\\\\s*(\\\\w+)\\\\s*=\\\\s*(.*)/gm;\\n  let match;\\n  let isVarUpdated = false;\\n\\n  while( ( match = regex.exec( variables ) ) !== null ) {\\n    if( match.index === regex.lastIndex ) {\\n      regex.lastIndex++;\\n    }\\n    if( match[1] == id ) {\\n      isVarUpdated = true;\\n      result.push( `${match[1]} = ${value}` );\\n    } else {\\n     result.push( `${match[1]} = ${match[2]}` );\\n    }\\n  }\\n  if( !isVarUpdated ) {\\n    result.push( `${id} = ${value}` );\\n  }\\n  return( result.join( '\\\\n' ) );\\n}\\nfunction isVariable( str ) {\\n  return( RegExp( /^[a-z]/i ).test( str ) );\\n}\\nfunction buildAST( tokenList ) {\\n  if( tokenList.length == 0 ) {\\n    return( null );\\n  } else if( tokenList.length == 1 ) {\\n    return( tokenList[0] );\\n  }\\n\\n  // Find the index of the lowest precedence operator\\n  let index = -1;\\n  let minPrecedence = Infinity;\\n  let parenthesis = 0;\\n  // Loop over all tokenList\\n  for( let i = 0; i < tokenList.length; ++i ) {\\n    if( tokenList[i] == '(' ) {\\n      parenthesis++;\\n    } else if( tokenList[i] == ')' ) {\\n      parenthesis--;\\n    } else if( parenthesis === 0 ) {\\n      // Compute precedences\\n      const operator = tokenList[i];\\n      let precedence = 0;\\n      if( ( operator == '+' ) || ( operator == '-' ) ) {\\n        precedence = 1;\\n      } else if( ( operator == '*' ) || ( operator == '/' ) ) {\\n        precedence = 2;\\n      } else {\\n        precedence = Infinity;\\n      }\\n      \\n      if( precedence <= minPrecedence ) {\\n        minPrecedence = precedence;\\n        index = i;\\n      }\\n    }\\n  }\\n\\n  // Handle subexpressions inside parentheses\\n  if( index === -1 ) {\\n    return( buildAST( tokenList.slice( 1, -1 ) ) );\\n  }\\n\\n  const result = [\\n    tokenList[index],\\n    buildAST( tokenList.slice( 0, index ) ),\\n    buildAST( tokenList.slice( index+1 ))\\n  ];\\n  return( result );\\n}\\nfunction evaluateAST( ast, variables ) {\\n  \\n  if( RegExp( /^[a-z_]/i ).test( ast ) ) {\\n    const varValue = variables[ast];\\n    if( varValue != undefined ) {\\n      return( parseFloat( varValue ) );\\n    } else {\\n      return( ast );\\n    }\\n  } else if( typeof( ast ) === 'number' ) {\\n    // Base case: if the node is a number, return it.\\n    return( ast );\\n  }\\n\\n  // Recursive case: evaluate the left and right operands.\\n  const left = evaluateAST( ast[1], variables );\\n  const right = evaluateAST( ast[2], variables );\\n\\n  // Compute the result based on the operator.\\n  switch( ast[0] ) {\\n    case '+':\\n      return( left + right );\\n    case '-':\\n      return( left - right );\\n    case '*':\\n      return( left * right );\\n    case '/':\\n      return( left / right );\\n    default:\\n      throw new Error( 'Unknown operator: ' + ast[0] );\\n  }\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":94,\"location\":\"-3770 2228.773\",\"group\":36,\"isIncludeScript\":true,\"editorPosition\":[246,1841,527,1094]},\n{\"label\":\"alpha = 10\\nbeta = 4\",\"category\":\"DataFlow_Message\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"267 143\",\"in_\":[{\"portId\":\"1in\",\"name\":\"in\"}],\"out_\":[{\"portId\":\"1out\",\"name\":\"out\"}],\"doCompute\":\"DataFlow_Message\",\"key\":96,\"location\":\"-3250 2430\",\"group\":36},\n{\"label\":\"Initial Variable Declaration\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"269 44\",\"key\":100,\"location\":\"-3240 2330\",\"group\":36},\n{\"label\":\"96\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":101,\"location\":\"-3290 2350\",\"group\":36},\n{\"label\":\"94\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":104,\"location\":\"-3800 2130\",\"group\":36},\n{\"label\":\"88\",\"category\":\"TextLabels_Size1\",\"alignment\":\"0 0.5 0 0\",\"alignmentFocus\":\"0 0.5 0 0\",\"size\":\"34 35\",\"key\":106,\"location\":\"-2730 2200\",\"group\":36},\n{\"label\":\"DFEConfig.js\",\"color\":\"orange\",\"size\":\"403 141\",\"category\":\"Hierarchy_CodeInGraph\",\"isFile\":true,\"fileContent\":\"/**\\n * This is the configuration file for the DFECodeGenerator\\n * \\n * This file defines configuration for language support\\n */\\n \\nconst dfeCGConfig = {\\n  lang: {\\n    'javascript': {\\n      generateLine: function( gen, text ) {\\n        text = text || '';\\n        gen.lines.push( text );\\n      },\\n      generateLineComment: function( gen, text ) {\\n        gen.lines.push( `// ${text}` );\\n      },\\n      generateMultiLineComment: function( gen, text ) {\\n        const comment = [\\n          '/*',\\n          ` * ${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          ' */' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateSessionComment: function( gen, text ) {\\n        const comment = [\\n          '',\\n          '/*****************************************',\\n          ` * ${text.replaceAll( '\\\\n', '\\\\n * ' )}`,\\n          ' *****************************************/' ];\\n          gen.lines = gen.lines.concat( comment );\\n      },\\n      generateHeader: function( gen ) {\\n        const header = `This file is code generated by ${gen.name}\\\\n`+\\n                       `\\\\n`+\\n                       `Generated on ${gen.date}\\\\n`;\\n        this.generateMultiLineComment( gen, header );\\n      },\\n      generateNodeFunctions: function( gen ) {\\n        const nodeFunctions = [\\n          '// System function for reading properties',\\n          'function DFE_getProperty( name, defaultValue ) {',\\n          '  // NOTE: this function access both nodeData fields and properties',\\n          '  if( this.nd_[name] != undefined ) {',\\n          '    return( this.nd_[name] );',\\n          '  } else if( this.nd_.props_[name] != undefined ) {',\\n          '    return( this.nd_.props_[name] );',\\n          '  } else {',\\n          '    return( defaultValue );',\\n          '  }',\\n          '}',\\n          '// System function for property data access',\\n          'function DFE_getPropertyList() {',\\n          '  return( this.nd_.props_ );',\\n          '}',\\n          '// System function for reading input',\\n          'function DFE_getInput( name, defaultValue ) {',\\n          '  if( this.in_[name] == undefined ) {',\\n          '    this.in_[name] = defaultValue;',\\n          '  }',\\n          '  return( this.in_[name] );',\\n          '}',\\n          '// System function for storing input',\\n          'function DFE_setInput( name, value ) {',\\n          '  this.in_[name] = value;',\\n          '}',\\n          '// System function for getting input name list',\\n          'function DFE_getInputNameList() {',\\n          '  return( this.nd_.in_ );',\\n          '}',\\n          '// System function for getting output name list',\\n          'function DFE_getOutputNameList() {',\\n          '  return( this.nd_.out_ );',\\n          '}',\\n          '// System function for instance data access',\\n          'function DFE_get( name, defaultValue ) {',\\n          '  if( this.st_[name] == undefined ) {',\\n          '    this.st_[name] = defaultValue;',\\n          '  }',\\n          '  return( this.st_[name] );',\\n          '}',\\n          '// System function for instance data storage',\\n          'function DFE_set( name, value ) {',\\n          '  this.st_[name] = value;',\\n          '}',\\n          '// System function for firing inputs',\\n          'function DFE_fireInput( name, value ) {',\\n          '  this.setInput( name, value );',\\n          '  this.doCompute( name, value );',\\n          '}',];\\n        gen.lines = gen.lines.concat( nodeFunctions );\\n      },\\n      generateNodeState: function ( gen, ni ) {\\n        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );\\n        // Node data instance variable\\n        gen.lines.push( `const nodeData_${ni.key} = {` );\\n        // Node data fields\\n        this.generateNodeDataFields( gen, ni );\\n        // Node methods\\n        this.generateNodeFire( gen, ni );\\n        const nodeDataObjClose = [\\n          `  getProperty: DFE_getProperty,`,\\n          `  getPropertyList: DFE_getPropertyList,`,\\n          `  getInput: DFE_getInput,`,\\n          `  setInput: DFE_setInput,`,\\n          `  getInputNameList: DFE_getInputNameList,`,\\n          `  getOutputNameList: DFE_getOutputNameList,`,\\n          `  get: DFE_get,`,\\n          `  set: DFE_set,`,\\n          `  fireInput: DFE_fireInput,`,\\n          `  doCompute: ${getComputeId( gen, ni )},`,\\n          `};` ];\\n        // Add lines\\n        gen.lines = gen.lines.concat( nodeDataObjClose );\\n      },\\n      generateNodeDataFields: function( gen, ni ) {\\n        if( ni.data.in_ && ni.data.in_.length ) {\\n          gen.lines.push( `  in_: {},       // Input values` );\\n        }\\n        if( ni.data.out_ && ni.data.out_.length ) {\\n          gen.lines.push( `  out_: {},      // Output values` );\\n        }\\n        gen.lines.push( `  nd_: {         // Full node fields/properties` );\\n        for( const field of [ 'label', 'color' ] ) {\\n          let value = ni.data[field];\\n          if( value != undefined ) {\\n            value = value.replaceAll( '\\\\n', '\\\\\\\\n' );\\n            gen.lines.push( `    ${field}: '${value}',` );\\n          }\\n        }\\n        gen.lines.push( `    in_: [       // Storage values ` );\\n        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );\\n        for( const name of inPortNameList ) {\\n          gen.lines.push( `      '${name}',` );\\n        }\\n        gen.lines.push( `    ],` );\\n        gen.lines.push( `    out_: [      // Storage values ` );\\n        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );\\n        for( const name of outPortNameList ) {\\n          gen.lines.push( `      '${name}',` );\\n        }\\n        gen.lines.push( `    ],` );\\n        gen.lines.push( `    props_: {    // Storage values ` );\\n        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );\\n        for( const name in propList ) {\\n          gen.lines.push( `      '${name}': '${propList[name]}',` );\\n        }\\n        gen.lines.push( `    },` );\\n        gen.lines.push( `  },` );\\n        gen.lines.push( `  st_: {},       // Storage values ` );\\n      },\\n      generateNodeFire: function( gen, ni ) {\\n        // Get out port list\\n        const outPortList = gen.me.getOutPortNameList( 'main', ni.key );\\n        const portLen = outPortList.length\\n        \\n        // Generate fire function\\n        gen.lines.push( `  fireOutput: function ( name, value ) {` );\\n        // Generate fire body\\n        if( portLen ) {\\n          gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );\\n          // Loop on each output port\\n          for( let i = 0; i < portLen; ++i ) {\\n            const portName = outPortList[i];\\n            if( i > 0 ) {\\n              gen.lines.push( `    } else if( name == '${portName}' ) {` );\\n            }\\n            \\n            // Get output links\\n            const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );\\n            for( const link of linkList ) {\\n              this.generateLinkCall( gen, ni, '      ', link, 'value' );\\n            }\\n          }\\n          gen.lines.push( `    }` );\\n        }\\n        gen.lines.push( `  },` );\\n      },\\n      generateLinkCall: function( gen, ni, indent, link, value ) {\\n        // Check link type\\n        if( link.category == 'DataFlow_Log' ) {\\n            return;\\n        } else if( link.category == 'DataFlow_Pause') {\\n          gen.lines.push( `${indent}debugger` );\\n        }\\n        \\n        // Get target input port name\\n        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );\\n        // Generate input update if node info is defined\\n        if( ni ) {\\n          gen.lines.push( `${indent}// Store new input` );\\n          gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );\\n        }\\n        // Generate compute call\\n        if( value ) {\\n          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );\\n        } else {\\n          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );\\n        }\\n      },\\n      regExp: {\\n       // Match line: var nodeData, name, value;\\n       declLine: RegExp( /\\\\s*var\\\\s+nodeData\\\\s*,/ ),\\n       // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );\\n       fireLine: RegExp( /graphData.dfe.fireOutput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );\\n       getInLine: RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );\\n       setInLine: RegExp( /graphData.dfe.setInput\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );\\n       getInNLLine: RegExp( /graphData.dfe.getInputNameList\\\\(\\\\s*nodeData/ ),\\n       // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );\\n       getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\\\\(\\\\s*nodeData/ ),\\n       // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );\\n       getLine: RegExp( /graphData.dfe.get\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );\\n       setLine: RegExp( /graphData.dfe.set\\\\(\\\\s*nodeData\\\\s*,/ ),\\n       // Match line: const p = graphData.dfe.getPropertyList( nodeData );\\n       getPropListLine: RegExp( /graphData.dfe.getPropertyList\\\\(\\\\s*nodeData\\\\s*/ ),\\n       //gen.getInLine = RegExp( /graphData.dfe.getInput\\\\(\\\\s*nodeData\\\\s*,\\\\s*([^,]+),/ );  \\n       //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );\\n      },\\n      generateComputeFunction: function( gen, ni, computeId ) {\\n        let isMainDeclSkipped = false;\\n        // Generate compute function\\n        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );\\n        gen.lines.push( `function ${computeId}( name, value ) {` );\\n        for( let line of ni.src ) {\\n          if( !isMainDeclSkipped ) {\\n            if( this.regExp.declLine.test( line ) ) {\\n              isMainDeclSkipped = true;\\n            }\\n          } else {\\n            if( this.regExp.fireLine.test( line ) ) {\\n              line = line.replace( this.regExp.fireLine, `this.fireOutput(` );\\n            } else if( this.regExp.getInLine.test( line ) ) {\\n              line = line.replace( this.regExp.getInLine, `this.getInput(` );\\n            } else if( this.regExp.setInLine.test( line ) ) {\\n              line = line.replace( this.regExp.setInLine, `this.setInput(` );\\n            } else if( this.regExp.getInNLLine.test( line ) ) {\\n              line = line.replace( this.regExp.getInNLLine, `this.getInputNameList(` );\\n            } else if( this.regExp.getOutNLLine.test( line ) ) {\\n              line = line.replace( this.regExp.getOutNLLine, `this.getOutputNameList(` );\\n            } else if( this.regExp.getLine.test( line ) ) {\\n              line = line.replace( this.regExp.getLine, `this.get(` );\\n            } else if( this.regExp.setLine.test( line ) ) {\\n              line = line.replace( this.regExp.setLine, `this.set(` );\\n            } else if( this.regExp.getPropListLine.test( line ) ) {\\n              line = line.replace( this.regExp.getPropListLine, `this.getPropertyList(` );\\n            }\\n            gen.lines.push( `  ${line}` );\\n          }\\n        }\\n        gen.lines.push( `}` );\\n      },\\n      computeList: {\\n        'DataFlow_Message': [\\n          `var nodeData, name, value;`,\\n          ``,\\n          `if( value == undefined ) {`,\\n          `  value = this.getProperty( 'label', '' );`,\\n          `  try {`,\\n          `    value = JSON.parse( value ); `,\\n          `  } catch( e ) {}`,\\n          `}`,\\n          `this.fireOutput( 'out', value );` \\n        ],\\n      }\\n    },\\n    'python': {\\n    },\\n  },\\n};\\n\\nvar module;\\nif( module ) {\\n  module.exports = dfeCGConfig;\\n}\",\"fileTypeName\":\"Javascript\",\"fileType\":\"text/javascript\",\"key\":102,\"location\":\"3010 2410\",\"group\":78,\"isIncludeScript\":true,\"editorPosition\":[3063,929,866,2010]}\n],\n  \"linkDataArray\": [\n{\"category\":\"DataFlow_Log\",\"from\":9,\"to\":11,\"points\":[-599.5380859375,3048.773,-589.5380859375,3048.773,-540,3468.773,-530,3468.773],\"fromPort\":\"1out\",\"toPort\":\"1in\",\"key\":-2},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":15,\"to\":17,\"points\":[-1674.5380859375,2958.773,-1664.5380859375,2958.773,-1640,3318.773,-1630,3318.773],\"key\":-5},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":9,\"to\":19,\"points\":[-599.5380859375,3048.773,-589.5380859375,3048.773,-407.02734375,3058.773,-397.02734375,3058.773],\"key\":-6},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":19,\"to\":21,\"points\":[-7.6484375,3058.773,2.3515625,3058.773,121.896484375,3224.431,131.896484375,3224.431],\"key\":-7},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":19,\"to\":23,\"points\":[-7.6484375,3078.773,2.3515625,3078.773,120,3295.1150000000002,130,3295.1150000000002],\"key\":-8},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":26,\"to\":27,\"points\":[-579.5380859375,2798.773,-569.5380859375,2798.773,-407.02734375,2798.773,-397.02734375,2798.773],\"key\":-10},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":27,\"to\":28,\"points\":[-8.6484375,2798.773,1.3515625,2798.773,121.896484375,2654.431,131.896484375,2654.431],\"key\":-11},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":27,\"to\":29,\"points\":[-8.6484375,2818.773,1.3515625,2818.773,120,2727.1150000000002,130,2727.1150000000002],\"key\":-12},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":26,\"to\":31,\"points\":[-579.5380859375,2798.773,-569.5380859375,2798.773,-560,2448.773,-550,2448.773],\"key\":-14},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":18,\"to\":33,\"points\":[-1137.2138671875,2948.773,-1127.2138671875,2948.773,-1110,2588.773,-1100,2588.773],\"key\":-15},\n{\"category\":\"DataFlow_Log\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":18,\"to\":35,\"points\":[-1137.2138671875,2968.773,-1127.2138671875,2968.773,-1110,3288.773,-1100,3288.773],\"key\":-16},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":27,\"to\":58,\"points\":[-8.6484375,2798.773,1.3515625,2798.773,134.6484375,2948.773,144.6484375,2948.773],\"key\":-17},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"2in\",\"from\":27,\"to\":58,\"points\":[-8.6484375,2818.773,1.3515625,2818.773,134.6484375,2968.773,144.6484375,2968.773],\"key\":-18},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"3in\",\"from\":19,\"to\":58,\"points\":[-7.6484375,3058.773,2.3515625,3058.773,134.6484375,2988.773,144.6484375,2988.773],\"key\":-19},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"4in\",\"from\":19,\"to\":58,\"points\":[-7.6484375,3078.773,2.3515625,3078.773,134.6484375,3008.773,144.6484375,3008.773],\"key\":-20},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":18,\"to\":9,\"points\":[-1137.2138671875,2968.773,-1127.2138671875,2968.773,-921.896484375,3048.773,-911.896484375,3048.773],\"key\":-21},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":18,\"to\":26,\"points\":[-1137.2138671875,2948.773,-1127.2138671875,2948.773,-901.896484375,2798.773,-891.896484375,2798.773],\"key\":-22},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":25,\"to\":34,\"points\":[899.02734375,2968.773,909.02734375,2968.773,958.103515625,2958.773,968.103515625,2958.773],\"key\":-23},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":50,\"to\":15,\"points\":[-2090.5380859375,2769.214,-2080.5380859375,2769.214,-2011.896484375,2958.773,-2001.896484375,2958.773],\"key\":-31},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":37,\"to\":36,\"points\":[1820,2078.9896159213067,1653.5,2078.172970537314],\"key\":-32,\"color\":\"YellowGreen\"},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":37,\"to\":44,\"points\":[2232,2080,3100,2080],\"key\":-33,\"color\":\"YellowGreen\"},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"label\":\"log\",\"from\":25,\"to\":45,\"points\":[899.02734375,2968.773,909.02734375,2968.773,958.103515625,3068.773,968.103515625,3068.773],\"key\":-34},\n{\"category\":\"DataFlow_Standard\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":58,\"to\":25,\"points\":[490.4619140625,2978.773,500.4619140625,2978.773,538.103515625,2978.773,548.103515625,2978.773],\"key\":-35},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"\",\"toPort\":\"\",\"from\":80,\"to\":78,\"points\":[4990,1949.5075173055777,4879.5,1949.2284437787384],\"key\":-36,\"color\":\"YellowGreen\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"Feature\",\"toPort\":\"Feature\",\"from\":83,\"to\":84,\"points\":[3788,1740,3840,1740,3850,1740],\"key\":-37,\"color\":\"RebeccaPurple\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":86,\"to\":44,\"points\":[2950.4619140625,1757.5000000000002,2960.4619140625,1757.5000000000002,3080,2040,3100.0234378664277,2046.356646941723],\"key\":-38,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":86,\"to\":62,\"points\":[2950.4619140625,1757.5000000000002,2960.4619140625,1757.5000000000002,3000,2210,3010.0131720630034,2212.3450051669797],\"key\":-39,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":86,\"to\":89,\"points\":[2950.4619140625,1757.5000000000002,2960.4619140625,1757.5000000000002,3050,1870,4010,2010,4060.013807269219,2011.4016249510796],\"key\":-40,\"color\":\"orange\"},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":15,\"to\":18,\"points\":[-1674.5380859375,2958.773,-1664.5380859375,2958.773,-1461.896484375,2958.773,-1451.896484375,2958.773],\"key\":-44},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":122,\"to\":15,\"points\":[-2090.5380859375,3001.398,-2080.5380859375,3001.398,-2042.896484375,2959.014,-2011.896484375,2958.773,-2001.896484375,2958.773],\"key\":-46},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":92,\"to\":88,\"points\":[1289.4619140625,3188.773,1299.4619140625,3188.773,1340,3191.543,1330,3771.543,-2790,3768.773,-2790,2438.773,-2731.896484375,2428.773,-2721.896484375,2428.773],\"key\":-42},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":27,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2040,2428.773,-2040,3621.543,-640,3621.543,-640,3101.543,-480,3101.543,-480,2818.773,-407.02734375,2818.773,-397.02734375,2818.773],\"key\":-43},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":19,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2050,2448.773,-2050,3631.543,-630,3631.543,-630,3111.543,-470,3111.543,-470,3078.773,-407.02734375,3078.773,-397.02734375,3078.773],\"key\":-47},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":51,\"to\":96,\"points\":[-3559.5380859375,2768.773,-3549.5380859375,2768.773,-3540,2780,-3390,2780,-3390,2430,-3291.896484375,2430,-3281.896484375,2430],\"key\":-48},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":51,\"to\":50,\"points\":[-3559.5380859375,2768.773,-3549.5380859375,2768.773,-2741.896484375,2769.214,-2731.896484375,2769.214],\"key\":-49},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":118,\"to\":96,\"points\":[-3559.5380859375,2858.773,-3549.5380859375,2858.773,-3530,2870,-3380,2870,-3380,2440,-3291.896484375,2430,-3281.896484375,2430],\"key\":-45},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":118,\"to\":122,\"points\":[-3559.5380859375,2858.773,-3549.5380859375,2858.773,-3120,2861.543,-2770,2861.543,-2770,2981.543,-2741.896484375,3001.398,-2731.896484375,3001.398],\"key\":-50},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"2out\",\"toPort\":\"1in\",\"from\":25,\"to\":92,\"points\":[899.02734375,2988.773,909.02734375,2988.773,912.97265625,3178.773,922.97265625,3178.773],\"key\":-41},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"2in\",\"from\":88,\"to\":92,\"points\":[-2080.5380859375,2428.773,-2070.5380859375,2428.773,-2060,2458.773,-2060,3758.773,860,3761.543,860,3201.543,912.97265625,3198.773,922.97265625,3198.773],\"key\":-51},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"1in\",\"from\":96,\"to\":88,\"points\":[-2942.5380859375,2430,-2932.5380859375,2430,-2731.896484375,2428.773,-2721.896484375,2428.773],\"key\":-52},\n{\"category\":\"CodeFlow_Code\",\"fromPort\":\"1out\",\"toPort\":\"\",\"from\":86,\"to\":102,\"points\":[2950.4619140625,1757.5000000000002,2960.4619140625,1757.5000000000002,3000,2380,3010.0049322760424,2381.4157923032135],\"key\":-53,\"color\":\"orange\"}\n]}"
}