/**
 * This is the configuration file for the DFECodeGenerator
 * 
 * This file defines configuration for language support
 */
 
const dfeCGConfig = {
  lang: {
    'javascript': {
      generateLine: function( gen, text ) {
        text = text || '';
        gen.lines.push( text );
      },
      generateLineComment: function( gen, text ) {
        gen.lines.push( `// ${text}` );
      },
      generateMultiLineComment: function( gen, text ) {
        const comment = [
          '/*',
          ` * ${text.replaceAll( '\n', '\n * ' )}`,
          ' */' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateSessionComment: function( gen, text ) {
        const comment = [
          '',
          '/*****************************************',
          ` * ${text.replaceAll( '\n', '\n * ' )}`,
          ' *****************************************/' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateHeader: function( gen ) {
        const header = `This file is code generated by ${gen.name}\n`+
                       `\n`+
                       `Generated on ${gen.date}\n`;
        this.generateMultiLineComment( gen, header );
      },
      generateNodeFunctions: function( gen ) {
        const nodeFunctions = [
          '// System function for reading properties',
          'function DFE_getProperty( name, defaultValue ) {',
          '  // NOTE: this function access both nodeData fields and properties',
          '  if( this.nd_[name] != undefined ) {',
          '    return( this.nd_[name] );',
          '  } else if( this.nd_.props_[name] != undefined ) {',
          '    return( this.nd_.props_[name] );',
          '  } else {',
          '    return( defaultValue );',
          '  }',
          '}',
          '// System function for property data access',
          'function DFE_getPropertyList() {',
          '  return( this.nd_.props_ );',
          '}',
          '// System function for reading input',
          'function DFE_getInput( name, defaultValue ) {',
          '  if( this.in_[name] == undefined ) {',
          '    this.in_[name] = defaultValue;',
          '  }',
          '  return( this.in_[name] );',
          '}',
          '// System function for storing input',
          'function DFE_setInput( name, value ) {',
          '  this.in_[name] = value;',
          '}',
          '// System function for getting input name list',
          'function DFE_getInputNameList() {',
          '  return( this.nd_.in_ );',
          '}',
          '// System function for getting output name list',
          'function DFE_getOutputNameList() {',
          '  return( this.nd_.out_ );',
          '}',
          '// System function for instance data access',
          'function DFE_get( name, defaultValue ) {',
          '  if( this.st_[name] == undefined ) {',
          '    this.st_[name] = defaultValue;',
          '  }',
          '  return( this.st_[name] );',
          '}',
          '// System function for instance data storage',
          'function DFE_set( name, value ) {',
          '  this.st_[name] = value;',
          '}',
          '// System function for firing inputs',
          'function DFE_fireInput( name, value ) {',
          '  this.setInput( name, value );',
          '  this.doCompute( name, value );',
          '}',];
        gen.lines = gen.lines.concat( nodeFunctions );
      },
      generateNodeState: function ( gen, ni, computeId ) {
        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );
        // Node data instance variable
        gen.lines.push( `const nodeData_${ni.key} = {` );
        // Node data fields
        this.generateNodeDataFields( gen, ni );
        // Node methods
        this.generateNodeFire( gen, ni );
        const nodeDataObjClose = [
          `  getProperty: DFE_getProperty,`,
          `  getPropertyList: DFE_getPropertyList,`,
          `  getInput: DFE_getInput,`,
          `  setInput: DFE_setInput,`,
          `  getInputNameList: DFE_getInputNameList,`,
          `  getOutputNameList: DFE_getOutputNameList,`,
          `  get: DFE_get,`,
          `  set: DFE_set,`,
          `  fireInput: DFE_fireInput,`,
          `  doCompute: ${computeId},`,
          `};` ];
        // Add lines
        gen.lines = gen.lines.concat( nodeDataObjClose );
      },
      generateNodeDataFields: function( gen, ni ) {
        if( ni.data.in_ && ni.data.in_.length ) {
          gen.lines.push( `  in_: {},       // Input values` );
        }
        if( ni.data.out_ && ni.data.out_.length ) {
          gen.lines.push( `  out_: {},      // Output values` );
        }
        gen.lines.push( `  nd_: {         // Full node fields/properties` );
        for( const field of [ 'label', 'color' ] ) {
          let value = ni.data[field];
          if( value != undefined ) {
            value = value.replaceAll( '\n', '\\n' );
            gen.lines.push( `    ${field}: '${value}',` );
          }
        }
        gen.lines.push( `    in_: [       // Storage values ` );
        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );
        for( const name of inPortNameList ) {
          gen.lines.push( `      '${name}',` );
        }
        gen.lines.push( `    ],` );
        gen.lines.push( `    out_: [      // Storage values ` );
        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );
        for( const name of outPortNameList ) {
          gen.lines.push( `      '${name}',` );
        }
        gen.lines.push( `    ],` );
        gen.lines.push( `    props_: {    // Storage values ` );
        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );
        for( const name in propList ) {
          gen.lines.push( `      '${name}': '${propList[name]}',` );
        }
        gen.lines.push( `    },` );
        gen.lines.push( `  },` );
        gen.lines.push( `  st_: {},       // Storage values ` );
      },
      generateNodeFire: function( gen, ni ) {
        // Get out port list
        const outPortList = gen.me.getOutPortNameList( 'main', ni.key );
        const portLen = outPortList.length
        
        // Generate fire function
        gen.lines.push( `  fireOutput: function ( name, value ) {` );
        // Generate fire body
        if( portLen ) {
          gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );
          // Loop on each output port
          for( let i = 0; i < portLen; ++i ) {
            const portName = outPortList[i];
            if( i > 0 ) {
              gen.lines.push( `    } else if( name == '${portName}' ) {` );
            }
            
            // Get output links
            const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );
            for( const link of linkList ) {
              this.generateLinkCall( gen, ni, '      ', link, 'value' );
            }
          }
          gen.lines.push( `    }` );
        }
        gen.lines.push( `  },` );
      },
      generateLinkCall: function( gen, ni, indent, link, value ) {
        // Check link type
        if( link.category == 'DataFlow_Log' ) {
            return;
        } else if( link.category == 'DataFlow_Pause') {
          gen.lines.push( `${indent}debugger` );
        }
        
        // Get target input port name
        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );
        // Generate input update if node info is defined
        if( ni ) {
          gen.lines.push( `${indent}// Store new input` );
          gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );
        }
        // Generate compute call
        if( value ) {
          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );
        } else {
          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );
        }
      },
      regExp: {
       // Match line: var nodeData, name, value;
       declLine: RegExp( /\s*var\s+nodeData\s*,/ ),
       // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );
       fireLine: RegExp( /graphData.dfe.fireOutput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );
       getInLine: RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );
       setInLine: RegExp( /graphData.dfe.setInput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );
       getInNLLine: RegExp( /graphData.dfe.getInputNameList\(\s*nodeData/ ),
       // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );
       getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\(\s*nodeData/ ),
       // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );
       getLine: RegExp( /graphData.dfe.get\(\s*nodeData\s*,/ ),
       // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );
       setLine: RegExp( /graphData.dfe.set\(\s*nodeData\s*,/ ),
       // Match line: const p = graphData.dfe.getPropertyList( nodeData );
       getPropListLine: RegExp( /graphData.dfe.getPropertyList\(\s*nodeData\s*/ ),
       //gen.getInLine = RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,\s*([^,]+),/ );  
       //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );
      },
      generateComputeFunction: function( gen, ni, computeId ) {
        let isMainDeclSkipped = false;
        // Generate compute function
        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );
        gen.lines.push( `function ${computeId}( name, value ) {` );
        for( let line of ni.src ) {
          if( !isMainDeclSkipped ) {
            if( this.regExp.declLine.test( line ) ) {
              isMainDeclSkipped = true;
            }
          } else {
            if( this.regExp.fireLine.test( line ) ) {
              line = line.replace( this.regExp.fireLine, `this.fireOutput(` );
            } else if( this.regExp.getInLine.test( line ) ) {
              line = line.replace( this.regExp.getInLine, `this.getInput(` );
            } else if( this.regExp.setInLine.test( line ) ) {
              line = line.replace( this.regExp.setInLine, `this.setInput(` );
            } else if( this.regExp.getInNLLine.test( line ) ) {
              line = line.replace( this.regExp.getInNLLine, `this.getInputNameList(` );
            } else if( this.regExp.getOutNLLine.test( line ) ) {
              line = line.replace( this.regExp.getOutNLLine, `this.getOutputNameList(` );
            } else if( this.regExp.getLine.test( line ) ) {
              line = line.replace( this.regExp.getLine, `this.get(` );
            } else if( this.regExp.setLine.test( line ) ) {
              line = line.replace( this.regExp.setLine, `this.set(` );
            } else if( this.regExp.getPropListLine.test( line ) ) {
              line = line.replace( this.regExp.getPropListLine, `this.getPropertyList(` );
            }
            gen.lines.push( `  ${line}` );
          }
        }
        gen.lines.push( `}` );
      },
      computeList: {
        'DataFlow_Message': [
          `var nodeData, name, value;`,
          ``,
          `if( value == undefined ) {`,
          `  value = this.getProperty( 'label', '' );`,
          `  try {`,
          `    value = JSON.parse( value ); `,
          `  } catch( e ) {}`,
          `}`,
          `this.fireOutput( 'out', value );` 
        ],
      }
    },
    'python': {
    },
  },
};

var module;
if( module ) {
  module.exports = dfeCGConfig;
}