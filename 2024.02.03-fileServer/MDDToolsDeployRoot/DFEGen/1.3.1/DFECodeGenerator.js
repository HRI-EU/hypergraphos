
/**
 * This is an example of Code Generator based on the conventions
 * of the component model and the DataFlow Engine execution model
 *
 * The main function to start code generation is:
 *    generationRoot( gen, callback )
 * Where:
 *   gen: is a data structure with the following information
 *        {
 *          name: 'GenDFE 1.0',  // Code generator name and version
 *          groupKey: null,       // Group node key containing the Model to be generated
 *          me: null,             // ModelExplorer loaded with the model
 *          modelId: 'main',      // Model Id
 *        };
 * 
 *   callback: a function( source, msg ) executed at the end of
 *             the generation process. Source is the generated source
 *             code, while msg is a message starting with Success:/Error:
 */

function generationRoot( gen, onGenerated ) {
  console.log( 'Starting Generation...' );
  
  // If nodes are found ==> start generation
  if( gen.groupKey != null ) {
    // Extend generation info
    gen.lines = [];                      // Number of lines of code generate
    gen.date = new Date().toGMTString(); // Generation date info
    gen.startNodeList = [],              // Start nodes
    // Match line: var nodeData, name, value;
    gen.declLine = RegExp( /\s*var\s+nodeData\s*,/ );
    // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );
    gen.fireLine = RegExp( /graphData.dfe.fireOutput\(\s*nodeData\s*,/ );
    // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );
    gen.getInLine = RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,/ );
    // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );
    gen.getLine = RegExp( /graphData.dfe.get\(\s*nodeData\s*,/ );
    //gen.getInLine = RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,\s*([^,]+),/ );  
    //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );
    gen.computeCount = {};                // Store usage of compute functions
    
    // Start generation
    generateGroup( gen, onGenerated );
  } else {
    if( onGenerated ) {
      onGenerated( '', 'Error: group key not found in gen parameter' );
    }
  }
}
function generateGroup( gen, onGenerated ) {
  const header = [ 
    '/*',
    ` * This file is code generated by ${gen.name}`,
    ' *',
    ` * Generated on ${gen.date}`,
    ' */',
    '',
    '/********************',
    ' * Node Functions',
    ' ********************/',
    '// System function for reading properties',
    'function DFE_getProperty( name, defaultValue ) {',
    '  // NOTE: this function access both nodeData fields and properties',
    '  if( this.nd_[name] != undefined ) {',
    '    return( this.nd_[name] );',
    '  } else if( this.nd_.props_[name] != undefined ) {',
    '    return( this.nd_.props_[name] );',
    '  } else {',
    '    return( defaultValue );',
    '  }',
    '}',
    '// System function for reading input',
    'function DFE_getInput( name, defaultValue ) {',
    '  if( this.in_[name] == undefined ) {',
    '    this.in_[name] = defaultValue;',
    '  }',
    '  return( this.in_[name] );',
    '}',
    '// System function for storing access',
    'function DFE_setInput( name, value ) {',
    '  this.in_[name] = value;',
    '}',
    '// System function for instance data access',
    'function DFE_get( name, defaultValue ) {',
    '  if( this.st_[name] == undefined ) {',
    '    this.st_[name] = defaultValue;',
    '  }',
    '  return( this.st_[name] );',
    '}',
    '// System function for firing inputs',
    'function DFE_fireInput( name, value ) {',
    '  this.setInput( name, value );',
    '  this.doCompute( name, value );',
    '}',
    '',
    '/********************',
    ' * Model Functions',
    ' ********************/' ];
  // Add lines
  gen.lines = gen.lines.concat( header );
  
  // Get all nodes in the group
  const dataList = gen.me.getNodeListBy( 'main', 'group', gen.groupKey );
  
  // Generate instance data for all nodes
  for( const data of dataList ) {
    const ni = getNodeInfo( gen, data );
    if( ni ) {
      gen.lines.push( `// Node Info: ${ni.descr}` );
      generateNodeState( gen, ni );
    }
  }
  
  const funcHeader = [
    '',
    '/********************',
    ' * Compute Functions',
    ' ********************/' ];
  // Add lines
  gen.lines = gen.lines.concat( funcHeader );
  
  // Generate compute function for all nodes
  for( const data of dataList ) {
    if( data.category == 'DataFlow_Start' ) {
      gen.startNodeList.push( data );
      continue;
    }
    // Get nodeInfo
    const ni = getNodeInfo( gen, data );
    if( ni ) {
      generateNodeCompute( gen, ni );
    }
  }
  
  if( gen.startNodeList.length ) {
    // Generate start functions
    const sysStart =[
      '',
      '/********************',
      ' * System Start',
      ' ********************/' ];
    // Add lines
    gen.lines = gen.lines.concat( sysStart );
    // Generate Start Nodes
    for( const data of gen.startNodeList ) {
      generateStartNode( gen, data );
    }
    gen.lines.push( '' );
  }
  
  // Save source in target component
  const content = gen.lines.join( '\n' );
  if( onGenerated ) {
    // Generate closing event
    onGenerated( content, `Success: ${gen.lines.length} lines` );
  }
}
function generateNodeState( gen, ni ) {
  // Node data instance variable
  gen.lines.push( `const nodeData_${ni.key} = {` );
  // Node data fields
  generateNodeDataFields( gen, ni );
  // Node methods
  generateNodeFire( gen, ni );
  const nodeDataObjClose = [
    `  getProperty: DFE_getProperty,`,
    `  getInput: DFE_getInput,`,
    `  setInput: DFE_setInput,`,
    `  fireInput: DFE_fireInput,`,
    `  get: DFE_get,`,
    `  doCompute: ${getComputeId( gen, ni )},`,
    `};` ];
  // Add lines
  gen.lines = gen.lines.concat( nodeDataObjClose );
}
function generateNodeDataFields( gen, ni ) {
  if( ni.data.in_ && ni.data.in_.length ) {
    gen.lines.push( `  in_: {},       // Input values` );
  }
  if( ni.data.out_ && ni.data.out_.length ) {
    gen.lines.push( `  out_: {},      // Output values` );
  }
  gen.lines.push( `  nd_: {         // Full node fields/properties` );
  for( const field of [ 'label', 'color' ] ) {
    if( ni.data.field != undefined ) {
      gen.lines.push( `    ${field}: '${ni.data[field]}',` );
    }
  }
  gen.lines.push( `    in_: [       // Storage values ` );
  const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );
  for( const name of inPortNameList ) {
    gen.lines.push( `      '${name}',` );
  }
  gen.lines.push( `    ],` );
  gen.lines.push( `    out_: [      // Storage values ` );
  const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );
  for( const name of outPortNameList ) {
    gen.lines.push( `      '${name}',` );
  }
  gen.lines.push( `    ],` );
  gen.lines.push( `    props_: {    // Storage values ` );
  const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );
  for( const name in propList ) {
    gen.lines.push( `      '${name}': '${propList[name]}',` );
  }
  gen.lines.push( `    },` );
  gen.lines.push( `  },` );
  gen.lines.push( `  st_: {},       // Storage values ` );
}
function generateNodeFire( gen, ni ) {
  // Get out port list
  const outPortList = gen.me.getOutPortNameList( 'main', ni.key );
  const portLen = outPortList.length
  
  // Generate fire function
  gen.lines.push( `  fireOutput: function ( name, value ) {` );
  // Generate fire body
  if( portLen ) {
    gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );
    // Loop on each output port
    for( let i = 0; i < portLen; ++i ) {
      const portName = outPortList[i];
      if( i > 0 ) {
        gen.lines.push( `    } else if( name == '${portName}' ) {` );
      }
      
      // Get output links
      const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );
      for( const link of linkList ) {
        generateLinkCall( gen, ni, '      ', link, 'value' );
      }
    }
    gen.lines.push( `    }` );
  }
  gen.lines.push( `  },` );
}
function generateLinkCall( gen, ni, indent, link, value ) {
  // Check link type
  if( link.category == 'DataFlow_Log' ) {
      return;
  } else if( link.category == 'DataFlow_Pause') {
    gen.lines.push( `${indent}debugger` );
  }
  
  // Get target input port name
  const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );
  // Generate input update if node info is defined
  if( ni ) {
    gen.lines.push( `${indent}// Store new input` );
    gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );
  }
  // Generate compute call
  if( value ) {
    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );
  } else {
    gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );
  }
}
function generateStartNode( gen, data ) {
  // Get output links
  const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, data.key, 'out' );
  for( const link of linkList ) {
    generateLinkCall( gen, null, '', link );
  }
}
function generateNodeCompute( gen, ni ) {
  let isMainDeclSkipped = false;
  
  // Get compute identifier
  let computeId = getComputeId( gen, ni );
  
  // Generate compute only if necessary
  if( !isComputeIfGenerated( gen, computeId ) ) {
    // Generate compute function
    gen.lines.push( `// Node Compute: ${ni.descr}` );
    gen.lines.push( `function ${computeId}( name, value ) {` );
    for( let line of ni.src ) {
      if( !isMainDeclSkipped ) {
        if( gen.declLine.test( line ) ) {
          isMainDeclSkipped = true;
        }
      } else {
        if( gen.fireLine.test( line ) ) {
          line = line.replace( gen.fireLine, `this.fireOutput(` );
        } else if( gen.getInLine.test( line ) ) {
          line = line.replace( gen.getInLine, `this.getInput(` );
        } else if( gen.getLine.test( line ) ) {
          line = line.replace( gen.getLine, `this.get(` );
        }
        gen.lines.push( `  ${line}` );
      }
    }
    gen.lines.push( `}` );
  }
  
  // Add one more usage of compute function
  addComputeId( gen, computeId );
}
function getComputeId( gen, ni ) {
  let result = null;
  
  if( ni.data.doCompute ) {
    result = ni.data.doCompute;
  } else if( ni.data.fileTypeName ) {
    result = ni.data.fileTypeName;
    if( ni.data.fileTypeName == 'Component' ) {
      result = `${result}_${ni.key}`;
    }
  } else {
    result = ni.key;
  }
  result = `compute_${result}`;
  
  return( result );
}
function isComputeIfGenerated( gen, computeId ) {
  return( gen.computeCount[computeId] >= 1 );
}
function addComputeId( gen, computeId ) {
  if( !gen.computeCount[computeId] ) {
    gen.computeCount[computeId] = 1;
  } else {
    ++gen.computeCount[computeId];
  }
}
function getNodeInfo( gen, data ) {
  const nodeInfo = {
    data,
    src: null,
    key: data.key,
    label: data.label,
    descr: `[${data.category}] ${ data.label? data.label: data.key }`,
  };
  
  if( data.fileContent ) {
    nodeInfo.src = data.fileContent.split( '\n' );
  } else if( data.category == 'DataFlow_Message' ) {
    //nodeInfo.src = globalThis[data.doCompute].toString().split( '\n' );
    nodeInfo.src = [ 
      `var nodeData, name, value;`,
      ``,
      `if( value == undefined ) {`,
      //`  value = "${nodeInfo.label}";`,
      `  value = this.getProperty( 'label', '' );`,
      `  try {`,
      `    value = JSON.parse( value ); `,
      `  } catch( e ) {}`,
      `}`,
      `this.fireOutput( 'out', value );` 
    ];
  }
  
  return( nodeInfo.src? nodeInfo: null );  
}

var module;
if( module ) {
  module.exports = generationRoot;
}