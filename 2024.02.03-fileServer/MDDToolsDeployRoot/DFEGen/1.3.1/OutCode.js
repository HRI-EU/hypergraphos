/*
 * This file is code generated by GenDFE 1.3
 *
 * Generated on Mon, 22 Jan 2024 04:05:07 GMT
 */

/********************
 * Node Functions
 ********************/
// System function for reading properties
function DFE_getProperty( name, defaultValue ) {
  // NOTE: this function access both nodeData fields and properties
  if( this.nd_[name] != undefined ) {
    return( this.nd_[name] );
  } else if( this.nd_.props_[name] != undefined ) {
    return( this.nd_.props_[name] );
  } else {
    return( defaultValue );
  }
}
// System function for reading input
function DFE_getInput( name, defaultValue ) {
  if( this.in_[name] == undefined ) {
    this.in_[name] = defaultValue;
  }
  return( this.in_[name] );
}
// System function for storing access
function DFE_setInput( name, value ) {
  this.in_[name] = value;
}
// System function for instance data access
function DFE_get( name, defaultValue ) {
  if( this.st_[name] == undefined ) {
    this.st_[name] = defaultValue;
  }
  return( this.st_[name] );
}
// System function for firing inputs
function DFE_fireInput( name, value ) {
  this.setInput( name, value );
  this.doCompute( name, value );
}

/********************
 * Model Functions
 ********************/
// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z
const nodeData_7 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_15.setInput( 'in', value );
      nodeData_15.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Component] Equation Parser
const nodeData_9 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_19.setInput( 'in', value );
      nodeData_19.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_EquationParser,
};
// Node Info: [DataFlow_Component] Equation Tokenizer
const nodeData_15 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_18.setInput( 'in', value );
      nodeData_18.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_Component_15,
};
// Node Info: [DataFlow_Component] Equation Compute
const nodeData_19 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_58.setInput( 'rValue', value );
      nodeData_58.doCompute( 'rValue', value );
    } else if( name == 'status' ) {
      // Store new input
      nodeData_58.setInput( 'rStatus', value );
      nodeData_58.doCompute( 'rStatus', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_EquationCompute,
};
// Node Info: [DataFlow_Component] Equation Split
const nodeData_18 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'lEq' ) {
      // Store new input
      nodeData_26.setInput( 'in', value );
      nodeData_26.doCompute( 'in', value );
    } else if( name == 'rEq' ) {
      // Store new input
      nodeData_9.setInput( 'in', value );
      nodeData_9.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_Component_18,
};
// Node Info: [DataFlow_Component] Equation Parser
const nodeData_26 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_27.setInput( 'in', value );
      nodeData_27.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_EquationParser,
};
// Node Info: [DataFlow_Component] Equation Compute
const nodeData_27 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_58.setInput( 'lValue', value );
      nodeData_58.doCompute( 'lValue', value );
    } else if( name == 'status' ) {
      // Store new input
      nodeData_58.setInput( 'lStatus', value );
      nodeData_58.doCompute( 'lStatus', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_EquationCompute,
};
// Node Info: [DataFlow_Component] Equation Compare
const nodeData_25 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_34.setInput( 'in', value );
      nodeData_34.doCompute( 'in', value );
      // Store new input
      nodeData_45.setInput( 'in', value );
      nodeData_45.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_Component_25,
};
// Node Info: [DataFlow_Message] y = 25
const nodeData_34 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-4
const nodeData_38 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_15.setInput( 'in', value );
      nodeData_15.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=10-1
const nodeData_42 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_15.setInput( 'in', value );
      nodeData_15.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Message] y=3*5+10
const nodeData_46 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_15.setInput( 'in', value );
      nodeData_15.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Message] 2+3*5-(2+20*0.5)+1
const nodeData_50 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_15.setInput( 'in', value );
      nodeData_15.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_DataFlow_Message,
};
// Node Info: [DataFlow_Component] Log Result
const nodeData_45 = {
  in_: {},       // Input values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_Component_45,
};
// Node Info: [DataFlow_Component] Barrier
const nodeData_58 = {
  in_: {},       // Input values
  out_: {},      // Output values
  nd_: {         // Full node fields/properties
    in_: {       // Storage values 
    },
    out_: {      // Storage values 
    },
    props_: {    // Storage values 
    },
  },
  st_: {},       // Storage values 
  fireOutput: function ( name, value ) {
    if( name == 'out' ) {
      // Store new input
      nodeData_25.setInput( 'in', value );
      nodeData_25.doCompute( 'in', value );
    }
  },
  getProperty: DFE_getProperty,
  getInput: DFE_getInput,
  setInput: DFE_setInput,
  fireInput: DFE_fireInput,
  get: DFE_get,
  doCompute: compute_MakeObject,
};

/********************
 * Compute Functions
 ********************/
// Node Compute: [DataFlow_Message] 2+3*5-(2+20*0.5)+1=z
function compute_DataFlow_Message( name, value ) {
  
  if( value == undefined ) {
    value = this.getProperty( 'label', '' );
    try {
      value = JSON.parse( value ); 
    } catch( e ) {}
  }
  this.fireOutput( 'out', value );
}
// Node Compute: [DataFlow_Component] Equation Parser
function compute_EquationParser( name, value ) {
  
  if( name == 'in' ) {
    // Build the AST tree (recursive function)
    const outValue = buildAST( value );
    
    this.fireOutput( 'out', outValue );
  }
  
  function buildAST( tokenList ) {
    if( tokenList.length == 0 ) {
      return( null );
    } else if( tokenList.length == 1 ) {
      return( tokenList[0] );
    }
  
    // Find the index of the lowest precedence operator
    let index = -1;
    let minPrecedence = Infinity;
    let parenthesis = 0;
    // Loop over all tokenList
    for( let i = 0; i < tokenList.length; ++i ) {
      if( tokenList[i] == '(' ) {
        parenthesis++;
      } else if( tokenList[i] == ')' ) {
        parenthesis--;
      } else if( parenthesis === 0 ) {
        // Compute precedences
        const operator = tokenList[i];
        let precedence = 0;
        if( ( operator == '+' ) || ( operator == '-' ) ) {
          precedence = 1;
        } else if( ( operator == '*' ) || ( operator == '/' ) ) {
          precedence = 2;
        } else {
          precedence = Infinity;
        }
        
        if( precedence <= minPrecedence ) {
          minPrecedence = precedence;
          index = i;
        }
      }
    }
  
    // Handle subexpressions inside parentheses
    if( index === -1 ) {
      return( buildAST( tokenList.slice( 1, -1 ) ) );
    }
  
    const result = [
      tokenList[index],
      buildAST( tokenList.slice( 0, index ) ),
      buildAST( tokenList.slice( index+1 ))
    ];
    return( result );
  }
  
}
// Node Compute: [DataFlow_Component] Equation Tokenizer
function compute_Component_15( name, value ) {
  
  if( name == 'in' ) {
    // Tokenize the input equation
    const regex = /\d+(\.\d+)?|[\+\-\*\/\(\)]|[=a-zA-Z]/g;
    const tokenList = value.match( regex ).map( token => {
      return( isNaN( token ) ? token : parseFloat( token ) );
    });
    
    this.fireOutput( 'out', tokenList );
  }
}
// Node Compute: [DataFlow_Component] Equation Compute
function compute_EquationCompute( name, value ) {
  
  if( name == 'in' ) {
    let outValue = NaN;
    let outStatus = 'Done';
    try {
      if( value == null ) {
        outValue = '';
      } else {
        outValue = evaluateAST( value );
      }
    } catch( e ) {
      outStatus = `Syntax error in expression: ${e}`;
    }
    
    this.fireOutput( 'out', outValue );
    this.fireOutput( 'status', outStatus );
  }
  
  function evaluateAST( ast ) {
    if( RegExp( /^[a-z]/i ).test( ast ) ) {
      return( ast );
    } else if( typeof( ast ) === 'number' ) {
      // Base case: if the node is a number, return it.
      return( ast );
    }
  
    // Recursive case: evaluate the left and right operands.
    const left = evaluateAST( ast[1] );
    const right = evaluateAST( ast[2] );
  
    // Compute the result based on the operator.
    switch( ast[0] ) {
      case '+':
        return( left + right );
      case '-':
        return( left - right );
      case '*':
        return( left * right );
      case '/':
        return( left / right );
      default:
        throw new Error( 'Unknown operator: ' + ast[0] );
    }
  }
}
// Node Compute: [DataFlow_Component] Equation Split
function compute_Component_18( name, value ) {
  
  if( name == 'in' ) {
    let i = value.indexOf( '=' );
    if( i == -1 ) {
      i = value.length;
    }
    
    const lEq = value.slice( 0, i );
    const rEq = value.slice( i+1 );
    
    this.fireOutput( 'lEq', lEq );
    this.fireOutput( 'rEq', rEq );
  }
}
// Node Compute: [DataFlow_Component] Equation Compare
function compute_Component_25( name, value ) {
  
  if( name == 'in' ) {
    let outValue = '';
    if( ( value.lStatus == 'Done' ) && ( value.rStatus == 'Done' ) ) {
      if( ( value.lValue == '' ) || ( value.rValue == '' ) ) {
        outValue = value.lValue || value.rValue;
      } else if( isVariable( value.lValue  ) ) {
        outValue = `${value.lValue} = ${value.rValue}`;
      } else if( isVariable( value.rValue ) ) {
        outValue = `${value.rValue} = ${value.lValue}`;
      } else {
        outValue = String( value.lValue == value.rValue );
      }
    } else {
      outValue == ( value.lStatus == 'Done'? value.rStatus: value.lStatus );
    }
    
    this.fireOutput( 'out', outValue );
  }
  
  function isVariable( str ) {
    return( RegExp( /^[a-z]/i ).test( str ) );
  }
}
// Node Compute: [DataFlow_Component] Log Result
function compute_Component_45( name, value ) {
  
  console.log( value );
}
// Node Compute: [DataFlow_Component] Barrier
function compute_MakeObject( name, value ) {
  
  const defaultInputStat = {
    'lValue': false,
    'lStatus': false,
    'rValue': false,
    'rStatus': false,
  };
  const inputStat = this.get( 'inputStat', defaultInputStat );
  
  inputStat[name] = true;
  let isObjectReady = true;
  for( const inName in inputStat ) {
    if( !inputStat[inName] ) {
      isObjectReady = false;
      break;
    }
  }
  
  if( isObjectReady ) {
    const outValue = {};
    for( const inName in inputStat ) {
      inputStat[inName] = false;
      outValue[inName] = this.getInput( inName, null );
    }
    this.fireOutput( 'out', outValue );
  }
  
}

/********************
 * System Start
 ********************/
nodeData_7.doCompute( 'in' );
nodeData_38.doCompute( 'in' );
nodeData_42.doCompute( 'in' );
nodeData_46.doCompute( 'in' );
nodeData_50.doCompute( 'in' );
