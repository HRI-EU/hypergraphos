/**
 * This is the configuration file for the DFECodeGenerator
 * 
 * This file defines configuration for language support
 */
 
const dfeCGConfig = {
  lang: {
    /*
    *
    * Javascript
    * 
    */
    'javascript': {
      generateLine: function( gen, text ) {
        text = text || '';
        gen.lines.push( text );
      },
      generateLineComment: function( gen, text ) {
        gen.lines.push( `// ${text}` );
      },
      generateMultiLineComment: function( gen, text ) {
        const comment = [
          '/*',
          ` * ${text.replaceAll( '\n', '\n * ' )}`,
          ' */' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateSessionComment: function( gen, text ) {
        const comment = [
          '',
          '/*****************************************',
          ` * ${text.replaceAll( '\n', '\n * ' )}`,
          ' *****************************************/' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateHeader: function( gen ) {
        const header = `This file is code generated by ${gen.name}\n`+
                       `\n`+
                       `Generated on ${gen.date}\n`;
        this.generateMultiLineComment( gen, header );
      },
      generateNodeFunctions: function( gen ) {
        const nodeFunctions = [
          '// System function for reading properties',
          'function DFE_getProperty( name, defaultValue ) {',
          '  // NOTE: this function access both nodeData fields and properties',
          '  if( this.nd_[name] != undefined ) {',
          '    return( this.nd_[name] );',
          '  } else if( this.nd_.props_[name] != undefined ) {',
          '    return( this.nd_.props_[name] );',
          '  } else {',
          '    return( defaultValue );',
          '  }',
          '}',
          '// System function for property data access',
          'function DFE_getPropertyList() {',
          '  return( this.nd_.props_ );',
          '}',
          '// System function for reading input',
          'function DFE_getInput( name, defaultValue ) {',
          '  if( this.in_[name] == undefined ) {',
          '    this.in_[name] = defaultValue;',
          '  }',
          '  return( this.in_[name] );',
          '}',
          '// System function for storing input',
          'function DFE_setInput( name, value ) {',
          '  this.in_[name] = value;',
          '}',
          '// System function for getting input name list',
          'function DFE_getInputNameList() {',
          '  return( this.nd_.in_ );',
          '}',
          '// System function for getting output name list',
          'function DFE_getOutputNameList() {',
          '  return( this.nd_.out_ );',
          '}',
          '// System function for instance data access',
          'function DFE_get( name, defaultValue ) {',
          '  if( this.st_[name] == undefined ) {',
          '    this.st_[name] = defaultValue;',
          '  }',
          '  return( this.st_[name] );',
          '}',
          '// System function for instance data storage',
          'function DFE_set( name, value ) {',
          '  this.st_[name] = value;',
          '}',
          '// System function for firing inputs',
          'function DFE_fireInput( name, value ) {',
          '  this.setInput( name, value );',
          '  this.doCompute( name, value );',
          '}',];
        gen.lines = gen.lines.concat( nodeFunctions );
      },
      generateNodeState: function ( gen, ni, computeId ) {
        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );
        // Node data instance variable
        gen.lines.push( `const nodeData_${ni.key} = {` );
        // Node data fields
        this.generateNodeDataFields( gen, ni );
        // Node methods
        this.generateNodeFire( gen, ni );
        const nodeDataObjClose = [
          `  getProperty: DFE_getProperty,`,
          `  getPropertyList: DFE_getPropertyList,`,
          `  getInput: DFE_getInput,`,
          `  setInput: DFE_setInput,`,
          `  getInputNameList: DFE_getInputNameList,`,
          `  getOutputNameList: DFE_getOutputNameList,`,
          `  get: DFE_get,`,
          `  set: DFE_set,`,
          `  fireInput: DFE_fireInput,`,
          `  doCompute: ${computeId},`,
          `};` ];
        // Add lines
        gen.lines = gen.lines.concat( nodeDataObjClose );
      },
      generateNodeDataFields: function( gen, ni ) {
        if( ni.data.in_ && ni.data.in_.length ) {
          gen.lines.push( `  in_: {},       // Input values` );
        }
        if( ni.data.out_ && ni.data.out_.length ) {
          gen.lines.push( `  out_: {},      // Output values` );
        }
        gen.lines.push( `  nd_: {         // Full node fields/properties` );
        for( const field of [ 'label', 'color' ] ) {
          let value = ni.data[field];
          if( value != undefined ) {
            value = value.replaceAll( '\n', '\\n' );
            gen.lines.push( `    ${field}: '${value}',` );
          }
        }
        gen.lines.push( `    in_: [       // Storage values ` );
        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );
        for( const name of inPortNameList ) {
          gen.lines.push( `      '${name}',` );
        }
        gen.lines.push( `    ],` );
        gen.lines.push( `    out_: [      // Storage values ` );
        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );
        for( const name of outPortNameList ) {
          gen.lines.push( `      '${name}',` );
        }
        gen.lines.push( `    ],` );
        gen.lines.push( `    props_: {    // Storage values ` );
        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );
        for( const name in propList ) {
          gen.lines.push( `      '${name}': '${propList[name]}',` );
        }
        gen.lines.push( `    },` );
        gen.lines.push( `  },` );
        gen.lines.push( `  st_: {},       // Storage values ` );
      },
      generateNodeFire: function( gen, ni ) {
        // Get out port list
        const outPortList = gen.me.getOutPortNameList( 'main', ni.key );
        const portLen = outPortList.length
        
        // Generate fire function
        gen.lines.push( `  fireOutput: function ( name, value ) {` );
        // Generate fire body
        if( portLen ) {
          gen.lines.push( `    if( name == '${outPortList[0]}' ) {` );
          // Loop on each output port
          for( let i = 0; i < portLen; ++i ) {
            const portName = outPortList[i];
            if( i > 0 ) {
              gen.lines.push( `    } else if( name == '${portName}' ) {` );
            }
            
            // Get output links
            const linkList = gen.me.getLinkListFanOutByNodeKey( gen.modelId, ni.key, portName );
            for( const link of linkList ) {
              this.generateLinkCall( gen, ni, '      ', link, 'value' );
            }
          }
          gen.lines.push( `    }` );
        }
        gen.lines.push( `  },` );
      },
      generateLinkCall: function( gen, ni, indent, link, value ) {
        // Check link type
        if( link.category == 'DataFlow_Log' ) {
            return;
        } else if( link.category == 'DataFlow_Pause') {
          gen.lines.push( `${indent}debugger` );
        }
        
        // Get target input port name
        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );
        // Generate input update if node info is defined
        if( ni ) {
          gen.lines.push( `${indent}// Store new input` );
          gen.lines.push( `${indent}nodeData_${link.to}.setInput( '${toPortName}', value );` );
        }
        // Generate compute call
        if( value ) {
          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}', ${value} );` );
        } else {
          gen.lines.push( `${indent}nodeData_${link.to}.doCompute( '${toPortName}' );` );
        }
      },
      regExp: {
       // Match line: var nodeData, name, value;
       declLine: RegExp( /\s*var\s+nodeData\s*,/ ),
       // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );
       fireLine: RegExp( /graphData.dfe.fireOutput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );
       getInLine: RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );
       setInLine: RegExp( /graphData.dfe.setInput\(\s*nodeData\s*,/ ),
       // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );
       getInNLLine: RegExp( /graphData.dfe.getInputNameList\(\s*nodeData/ ),
       // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );
       getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\(\s*nodeData/ ),
       // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );
       getLine: RegExp( /graphData.dfe.get\(\s*nodeData\s*,/ ),
       // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );
       setLine: RegExp( /graphData.dfe.set\(\s*nodeData\s*,/ ),
       // Match line: const p = graphData.dfe.getPropertyList( nodeData );
       getPropListLine: RegExp( /graphData.dfe.getPropertyList\(\s*nodeData\s*/ ),
       //gen.getInLine = RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,\s*([^,]+),/ );  
       //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );
      },
      generateComputeFunction: function( gen, ni, computeId ) {
        let isMainDeclSkipped = false;
        // Generate compute function
        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );
        gen.lines.push( `function ${computeId}( name, value ) {` );
        for( let line of ni.src ) {
          if( !isMainDeclSkipped ) {
            if( this.regExp.declLine.test( line ) ) {
              isMainDeclSkipped = true;
            }
          } else {
            if( this.regExp.fireLine.test( line ) ) {
              line = line.replace( this.regExp.fireLine, `this.fireOutput(` );
            } else if( this.regExp.getInLine.test( line ) ) {
              line = line.replace( this.regExp.getInLine, `this.getInput(` );
            } else if( this.regExp.setInLine.test( line ) ) {
              line = line.replace( this.regExp.setInLine, `this.setInput(` );
            } else if( this.regExp.getInNLLine.test( line ) ) {
              line = line.replace( this.regExp.getInNLLine, `this.getInputNameList(` );
            } else if( this.regExp.getOutNLLine.test( line ) ) {
              line = line.replace( this.regExp.getOutNLLine, `this.getOutputNameList(` );
            } else if( this.regExp.getLine.test( line ) ) {
              line = line.replace( this.regExp.getLine, `this.get(` );
            } else if( this.regExp.setLine.test( line ) ) {
              line = line.replace( this.regExp.setLine, `this.set(` );
            } else if( this.regExp.getPropListLine.test( line ) ) {
              line = line.replace( this.regExp.getPropListLine, `this.getPropertyList(` );
            }
            gen.lines.push( `  ${line}` );
          }
        }
        gen.lines.push( `}` );
      },
      computeList: {
        'DataFlow_Message': [
          `var nodeData, name, value;`,
          ``,
          `if( value == undefined ) {`,
          `  value = this.getProperty( 'label', '' );`,
          `  try {`,
          `    value = JSON.parse( value ); `,
          `  } catch( e ) {}`,
          `}`,
          `this.fireOutput( 'out', value );` 
        ],
      }
    },
    /*
    *
    * Python
    * 
    */
    'python': {
      generateLine: function( gen, text ) {
        text = text || '';
        gen.lines.push( text );
      },
      generateLineComment: function( gen, text ) {
        gen.lines.push( `# ${text}` );
      },
      generateMultiLineComment: function( gen, text ) {
        const comment = [
          '\'\'\'',
          `${text.replaceAll( '\n', '\n * ' )}`,
          '\'\'\'' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateSessionComment: function( gen, text ) {
        const comment = [
          '\'\'\'',
          '****************************************',
          `* ${text.replaceAll( '\n', '\n * ' )}`,
          '****************************************',
          '\'\'\'' ];
          gen.lines = gen.lines.concat( comment );
      },
      generateHeader: function( gen ) {
        const header = `This file is code generated by ${gen.name}\n`+
                      `\n`+
                      `Generated on ${gen.date}\n`;
        this.generateMultiLineComment( gen, header );
      },
      generateNodeFunctions : function ( gen ) {
        const nodeFunctions = [
          'import json',
          'import re',
          'from dataclasses import dataclass',
          'from typing import Callable, Dict, List',
          '',
          '@dataclass',
          'class NodeData:',
          '    #********************',
          '    # Node System Dependant Functions',
          '    #********************',
          '    # System function for reading properties',
          '    def DFE_get_property(self, name, default_value):',
          '        # NOTE: this function accesses both nodeData fields and properties',
          '        if name in self.nd_:',
          '            return self.nd_[name]',
          '        elif name in self.nd_[\'props_\']:',
          '            return self.nd_[\'props_\'][name]',
          '        else:',
          '            return default_value',
          '        ',
          '    # System function for property data access',
          '    def DFE_get_property_list(self):',
          '        return self.nd_[\'props_\']',
          '',
          '    # System function for reading input',
          '    def DFE_get_input(self, name, default_value):',
          '        if name not in self.in_:',
          '            self.in_[name] = default_value',
          '        return self.in_[name]',
          '',
          '    # System function for storing access',
          '    def DFE_set_input(self, name, value):',
          '        self.in_[name] = value',
          '',
          '    # System function for getting input name list',
          '    def DFE_get_input_name_list(self):',
          '        return self.nd_[\'in_\']',
          '    ',
          '    # System function for getting output name list',
          '    def DFE_get_output_name_list(self):',
          '        return self.nd_[\'out_\']',
          '',
          '    # System function for instance data access',
          '    def DFE_get(self, name, default_value):',
          '        if name not in self.st_:',
          '            self.st_[name] = default_value',
          '        return self.st_[name]',
          '    ',
          '    # System function for instance data storage',
          '    def DFE_set(self, name, value):',
          '        self.st_[\'name\'] = value',
          '',
          '    # System function for firing inputs',
          '    def DFE_fire_input(self, name, value):',
          '        self.set_input(name, value)',
          '        self.do_compute(name, value)',
          '',
          '    #********************',
          '    # Node Fields',
          '    #********************',
          '    in_: Dict ',
          '    out_: Dict',
          '    nd_ : Dict',
          '    st_ : Dict',
          '    fire_output: Callable',
          '    get_property = DFE_get_property',
          '    get_input = DFE_get_input',
          '    set_input = DFE_set_input',
          '    get_input_name_list= DFE_get_input_name_list',
          '    get_output_name_list = DFE_get_output_name_list',
          '    get = DFE_get',
          '    set = DFE_set',
          '    fire_input = DFE_fire_input',
          '    get = DFE_get_property',
          '    do_compute: Callable'
        ]
        gen.lines = gen.lines.concat( nodeFunctions );
      },
      generateNodeState: function ( gen, ni, computeId ) {
        gen.lang.generateLineComment( gen, `Node Info: ${ni.descr}` );
        // Node data instance variable
        gen.lines.push( `nodeData_${ni.key} = NodeData(` );
        // Node data fields
        this.generateNodeDataFields( gen, ni );
        // Node methods
        this.generateNodeFire( gen, ni );
        const nodeDataObjClose = [
          // (CP) TODO - decide if necessary here
          // `    getProperty = DFE_get_property,`,
          // `    getPropertyList =  DFE_get_property_list,`,
          // `    getInput: DFE_get_input,`,
          // `    setInput: DFE_set_input,`,
          // `    getInputNameList: DFE_get_input_name_list,`,
          // `    getOutputNameList: DFE_get_output_name_list,`,
          // `    get: DFE_get,`,
          // `    set: DFE_set,`,
          // `    fireInput: DFE_fire_input,`,
          `    do_compute= ${computeId},`,
          `)` ];
        // Add lines
        gen.lines = gen.lines.concat( nodeDataObjClose );
      },
      generateNodeDataFields: function( gen, ni ) {
        if( ni.data.in_ && ni.data.in_.length ) {
          gen.lines.push( `    in_= {},       # Input values` );
        }
        if( ni.data.out_ && ni.data.out_.length ) {
          gen.lines.push( `    out_= {},      # Output values` );
        }
        gen.lines.push( `    nd_= {         # Full node fields/properties` );
        for( const field of [ 'label', 'color' ] ) {
          let value = ni.data[field];
          if( value != undefined ) {
            value = value.replaceAll( '\n', '\\n' );
            gen.lines.push( `        '${field}': '${value}',` );
          }
        }
        gen.lines.push( `        'in_': [       # Storage values ` );
        const inPortNameList = gen.me.getInPortNameList( gen.modelId, ni.data.key );
        for( const name of inPortNameList ) {
          gen.lines.push( `            '${name}',` );
        }
        gen.lines.push( `        ],` );
        gen.lines.push( `        'out_': [      # Storage values ` );
        const outPortNameList = gen.me.getOutPortNameList( gen.modelId, ni.data.key );
        for( const name of outPortNameList ) {
          gen.lines.push( `            '${name}',` );
        }
        gen.lines.push( `        ],` );
        gen.lines.push( `        'props_': {    # Storage values ` );
        const propList = gen.me.gerPropertyList( gen.modelId, ni.data.key );
        for( const name in propList ) {
          gen.lines.push( `            '${name}': '${propList[name]}',` );
        }
        gen.lines.push( `        },` );
        gen.lines.push( `    },` );
        gen.lines.push( `    st_= {},       # Storage values ` );
      }, 
      generateNodeFire: function(gen, ni) {
        // Get out port list
        const outPortList = gen.me.getOutPortNameList('main', ni.key);
        const portLen = outPortList.length;
    
        // Generate fire function
        gen.lines.push(`    fire_output = lambda name, value: (`);
    
        // Generate fire body
        if (portLen) {
          for (let i = 0; i < portLen; ++i) {
            const portName = outPortList[i];
            // Get output links
            const linkList = gen.me.getLinkListFanOutByNodeKey(gen.modelId, ni.key, portName);
            for (const link of linkList) {
              this.generateLinkCall(gen, ni, '        ', link, 'value', `name == '${portName}'`);
            }
          }
          gen.lines.push(`        None`);
        }
        gen.lines.push(`    ),`);
      },
      generateLinkCall: function( gen, ni, indent, link, value, lambdaCondition=undefined ) {
        // Check link type
        if( link.category == 'DataFlow_Log' ) {
            return;
        } else if( link.category == 'DataFlow_Pause') {
          gen.lines.push( `${indent}debugger` );
        }
        
        // Get target input port name
        const toPortName = gen.me.getInPortName( gen.modelId, link.to, link.toPort );

        if ( ni ) {
          if ( value ) {
            gen.lines = gen.lines.concat( `${indent}( `);
          }
          gen.lines.push( `${indent}# Store new input` );
          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.set_input( '${toPortName}', value ), ` );
        } 
        if( value ) {
          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.do_compute( '${toPortName}', ${value} )` );
        } else {
          gen.lines = gen.lines.concat( `${indent}nodeData_${link.to}.do_compute( '${toPortName}', None )` );
        }

        // Trailing lambda `if ${lambdaCondition} else`
        let lIfElse = '';
        if ( lambdaCondition != undefined ) {
          lIfElse = `if ${lambdaCondition} else`
          if ( ni ) {
            gen.lines.push( `${indent}) ${lIfElse}` );
          } else {
            // No closing bracket
            gen.lines.push( `${indent} ${lIfElse}` );
          }
        }
      },
      regExp: {
        // Match line: args = [self, name, value]
        declLine: RegExp( /args\s*=\s*\[.*self.*\]/ ),
        // // Match line: graphData.dfe.fireOutput( nodeData, 'out', value );
        // fireLine: RegExp( /graphData.dfe.fireOutput\(\s*nodeData\s*,/ ),
        // // Match line: const lValue = graphData.dfe.getInput( nodeData, 'lValue', 0 );
        // getInLine: RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,/ ),
        // // Match line: const lValue = graphData.dfe.setInput( nodeData, 'lValue', 0 );
        // setInLine: RegExp( /graphData.dfe.setInput\(\s*nodeData\s*,/ ),
        // // Match line: const lValue = graphData.dfe.getInputNameList( nodeData );
        // getInNLLine: RegExp( /graphData.dfe.getInputNameList\(\s*nodeData/ ),
        // // Match line: const lValue = graphData.dfe.getOutputNameList( nodeData );
        // getOutNLLine: RegExp( /graphData.dfe.getOutputNameList\(\s*nodeData/ ),
        // // Match line: const s = graphData.dfe.get( nodeData, 'inputStat', {} );
        // getLine: RegExp( /graphData.dfe.get\(\s*nodeData\s*,/ ),
        // // Match line: const s = graphData.dfe.set( nodeData, 'inputStat', {} );
        // setLine: RegExp( /graphData.dfe.set\(\s*nodeData\s*,/ ),
        // // Match line: const p = graphData.dfe.getPropertyList( nodeData );
        // getPropListLine: RegExp( /graphData.dfe.getPropertyList\(\s*nodeData\s*/ ),
        // //gen.getInLine = RegExp( /graphData.dfe.getInput\(\s*nodeData\s*,\s*([^,]+),/ );  
        // //line = line.replace( getInLine, `( node_${ni.key}[$1] != undefined? node_${ni.key}[$1]:` );
      },
      generateComputeFunction: function( gen, ni, computeId ) {
        let isMainDeclSkipped = false;
        let firstLineMainDecl = false;
        // Generate compute function
        this.generateLineComment( gen, `Node Compute[${ni.data.key}]: ${ni.descr}` );
        gen.lines.push( `def ${computeId}( self : NodeData, name, value ):` );
        for( let line of ni.src ) {
          if( !isMainDeclSkipped ) {
            if( this.regExp.declLine.test( line ) ) {
              isMainDeclSkipped = true;
            }
          } else {
          //   if( this.regExp.fireLine.test( line ) ) {
          //     line = line.replace( this.regExp.fireLine, `self.fire_output(` );
          //   } else if( this.regExp.getInLine.test( line ) ) {
          //     line = line.replace( this.regExp.getInLine, `self.get_input(` );
          //   } else if( this.regExp.setInLine.test( line ) ) {
          //     line = line.replace( this.regExp.setInLine, `self.set_input(` );
          //   } else if( this.regExp.getInNLLine.test( line ) ) {
          //     line = line.replace( this.regExp.getInNLLine, `self.get_input_name_list(` );
          //   } else if( this.regExp.getOutNLLine.test( line ) ) {
          //     line = line.replace( this.regExp.getOutNLLine, `self.get_output_name_list(` );
          //   } else if( this.regExp.getLine.test( line ) ) {
          //     line = line.replace( this.regExp.getLine, `self.get(` );
          //   } else if( this.regExp.setLine.test( line ) ) {
          //     line = line.replace( this.regExp.setLine, `self.set(` );
          //   } else if( this.regExp.getPropListLine.test( line ) ) {
          //     line = line.replace( this.regExp.getPropListLine, `self.get_property_list(` );
          //   }
            gen.lines.push( `  ${line}` );
          }
        }
      },
      computeList: { // (CP) This needs a second thought...used same JS approach
        'DataFlow_Message': [
            `args = [self, name, value]`,
            `if value is None:`,
            `    value = self.get_property('label', '')`,
            `try:`,
            `    value = json.loads(value)`,
            `except Exception as e:  # Use 'Exception' to catch all exceptions`,
            `    pass`,
            `self.fire_output('out', value)`
        ],
      }
    }
  },
};

var module;
if( module ) {
  module.exports = dfeCGConfig;
}