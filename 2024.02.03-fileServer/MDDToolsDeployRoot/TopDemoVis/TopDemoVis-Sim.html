<html>
	<meta charset="UTF-8">
  <head>
    <title>Robot Inner Monologue</title> 
    <!--includes hChat-->
    <script type='text/javascript' src='lib/hChat/1.0/hChat.js'></script>
    <link type='text/css' rel='stylesheet' href='lib/hChat/1.0/hChat.css'></link>
    <!--End-->
		<!--includes ROSLib-->
    <script type='text/javascript' src='lib/ROSLib/1.3.0/roslib.min.js'></script>
    <!--End-->
		<!--includes translation cache-->
    <script type='text/javascript' src='cache.js'></script>
    <!--End-->
		<!--includes chatGPT-->
		<script type='text/javascript' src='lib/ChatGPT/1.1/ChatGPT.js'></script>
		<!--End-->
		<script>
			// From DataFlowDSL
			const chatGPT = new ChatGPT();
			console.log( 'Instanciate ChatGPT' );
			let translationState = false;
			// From[]: MessageList
			const messageList = [
				{
					"trigger": "speak_event", 
					"expression_information": {
					"text": "Can you pass me the bottle?", 
					"sender": "Felix", 
					"receiver": "Daniel"
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "get_objects", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "get_objects", 
					"result": "Following objects were observed: the_cola_bottle.", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "get_persons", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "get_persons", 
					"result": "Following persons were observed: Felix, Daniel.", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "is_person_busy", 
					"arguments": {
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "is_person_busy", 
					"result": "Daniel is not busy.", 
					"arguments": {
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"result": "Daniel can see the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"result": "Daniel can see the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_reach_object", 
					"result": "Daniel cannot reach the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "move_object_to_person", 
					"arguments": {
						"object_name": "the_cola_bottle", 
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "move_object_to_person", 
					"result": "You moved the the_cola_bottle to Daniel.", 
					"arguments": {
						"object_name": "the_cola_bottle", 
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "gpt_finished", 
					"expression_information": {}
				}
			];
			
			// ROS Simulator
			function startROSSimulator( hc ) {
				const timeout = 1;
				const visualizationSim = ( index )=>
				{
					if( index < messageList.length ) {
						visualization( messageList[index] );
						setTimeout( ()=> visualizationSim( index+1 ), timeout*1000 );
					}
				};
	
				// Start simulator
				visualizationSim( 0 );
			}
			function startROS( hc ) {
				let ros = null;
				if( !ros ) {
					const rosServerURL = 'ws://localhost:9090';
					if( rosServerURL ) {
						// Connect to the ROS Bridge WebSocket server
						ros = new ROSLIB.Ros({
							url: rosServerURL, // The WebSocket connection URL to your ROS Bridge server
						});
						
						// This function is called upon a successful connection to ROS
						ros.on('connection', function() {
							const msg = 'Connected to ROS websocket server.';
							console.log( msg );
							console.log( 'status', msg );
							subscribe( ros );
						});
						
						// This function is called if the connection to ROS is closed
						ros.on('close', function() {
							const msg = 'Connection to ROS websocket server closed.';
							console.log( msg );
							console.log( 'status', msg );
							ros = null;
						});
						
						// This function is called if there's an error in the connection to ROS
						ros.on('error', function(error) {
							isRosConnected = false;
							const msg = 'Error connecting to ROS websocket server: '+error;
							console.log( 'status', msg );
						});
					} else {
						isRosConnected = false;
						graphData.dfe.fireOutput( nodeData, 'status', 'Error: rosServerURL not defined in properties' );
					}
				}

				function subscribe( ros ) {
					if( true ) {
						const label = '/action_xai_topic';
						const datatype = 'std_msgs/String';
						const topicName = label.toLowerCase();
						
						// Create a new ROSLIB.Topic object to subscribe to a ROS topic
						const topic = new ROSLIB.Topic({
							ros: ros, // The ROSLIB.Ros connection handle
							name: topicName, // The name of the topic to subscribe to
							messageType: dataType, // The message type of the topic
						});
						
						// Define a callback function to handle received messages
						const onMessageReceived = ( message )=> {
							console.log('Received message on ' + topic.name + ': ' + message.data );
							let outValue = message.data;
							try {
								outValue = JSON.parse( message.data );
							} catch( e ) {}

							if( outValue.trigger ) {
								visualization( outValue );
							}
						}
						
						// Subscribe to the topic with the callback
						topic.subscribe( onMessageReceived );
					}
				}
			}
			// From[111]:...
			function visualization( message ) {
				produceQueue_107( 'item', message );
			}
	
			// From[108]
			const queue_108 = [];
	
			// From[107, 110]
			function produceQueue_107( name, value ) {
				if( name == 'item' ) {
					queue_108.push( value );
	
					consumeQueue_110( 'in' );
				}
			}
			
			// From[110]:
			const n110 = {
				isFired: false,
			}
			function consumeQueue_110( name ) {
				if( name == 'in' ) {
					const isFired = n110.isFired;
					if( !isFired ) {
						fireFromQueue();
					}
				} else if( name == 'doTrigger' ) {
					fireFromQueue();
				}
	
				function fireFromQueue() {
					// Check if the queue is not empty
					const isQueueFull = ( ( queue_108 != null ) && ( queue_108.length != 0 ) );
					// If queue is not empty --> tell we fired
					n110.isFired = isQueueFull;
	
					// If queue is not empty -> fire last element
					if( isQueueFull ) {
						const message = queue_108.pop();
	
						composeExplanationText_106( 'in', message );
					}
				}
			}
	
			// From[106]:
			function composeExplanationText_106( name, value ) {
				if( name == 'in' ) {
					let outString = '???';
					let sender = 'think';
					let receiver = 'empty';
					const info = value.expression_information;
					const arg = info.arguments;
					let objectName = '';
					switch( value.trigger ) {
						case 'speak_event':
							sender = 'hear';
							outString = `I heard ${info.sender} say to ${info.receiver}: ${info.text}`;
							break;
						case 'gpt_querying':
							outString = 'Let\'s think...';
							break;
						case 'function_call':
							switch( info.function_name ) {
								case 'get_objects':
									outString = 'Let\'s see which objects are on the table...';
									break;
								case 'get_persons':
									outString = 'Let\'s see which persons are with me...';
									break;
								case 'is_person_busy':
									outString = `Let\'s see if ${arg.person_name} is busy...`;
									break;
								case 'can_person_see_object':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check if ${arg.person_name} can see ${objectName}...`;
									break;
								case 'can_person_reach_object':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check if ${arg.person_name} can reach ${objectName}...`;
									break;
								case 'move_object_to_person':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Now, let\'s try to move ${objectName} to ${arg.person_name}...`;
									break;
								case 'speak':
									outString = `Now, let\'s say "${arg.text}" to ${arg.person_name}...`;  // TO BE VERIFIED
									break;
							}
							break;
						case 'function_result':
							let result = info.result.replace(/_/gi, " ");;
							sender = 'look';
							receiver = 'empty';
							switch( info.function_name ) {
								case 'get_objects':
								case 'get_persons':
									const idx = result.indexOf( ':' );
									result = result.slice( idx + 2 );
									outString = `I see ${result}`;
									break;
								case 'is_person_busy':
									outString = `Ok, ${result}`;
									break;
								case 'can_person_see_object':
									outString = `Ok, ${result}`;
									break;
								case 'can_person_reach_object':
									outString = `Ok, ${result}`;
									break;
								case 'move_object_to_person':
									sender = 'act';
									// Replace 'your' with 'my'
									result = result.replace(/your/gi, "my");
									// Replace 'your' with 'my'
									result = result.replace(/Your/gi, "My");
									// Replace 'you' with 'I'
									result = result.replace(/you/gi, "I");
									// Replace 'You' with 'I'
									result = result.replace(/You/gi, "I");
									outString = `Ok, ${result}`;
									break;
								case 'speak':
								sender = 'say';
									// Replace 'your' with 'my'
									result = result.replace(/your/gi, "my");
									// Replace 'your' with 'my'
									result = result.replace(/Your/gi, "My");
									// Replace 'you' with 'I'
									result = result.replace(/you/gi, "I");
									// Replace 'You' with 'I'
									result = result.replace(/You/gi, "I");
									outString = `Ok, ${result}`;
									break;
							}
							break;
						case 'gpt_finished':
							outString = 'I am done.';
							break;
					}
					if( outString != '???' ) {
						const outValue = { sender, receiver, text:outString };
						//graphData.dfe.fireOutput( nodeData, 'message', outValue );
						//graphData.dfe.fireOutput( nodeData, 'text', outString );
						fire( 'message', outValue );
						fire( 'text', outString );
					} else {
						console.log( 'EVENT IS IGNORED !!!!!!!!!!!!!!!!!!!!' );
					}
				}
				function fire( name, value ) {
					if( name == 'text' ) {
						cacheManagement_98( 'phrase', value );
					} else if( name == 'message' ) {
						replaceTextField_105( 'message', value );
					}
				}
			}
	
			// From[98]:
			const n98 = {
				isTranslated: true,
			};
			function cacheManagement_98( name, value ) {
				if( name == 'phrase' ) {
					//const isTranslated = n98.isTranslated;
					const isTranslated = translationState;
					const cache = cache_99;
					const phrase = value;
					if( isTranslated ) {
						const translation = cache[phrase];
						if( translation ) {
							const outValue = phrase+'<br>'+translation;
							fire( 'out', outValue );
						} else {
							fire( 'phrase', phrase );
						}
					} else {
						const outValue = phrase;
						fire( 'out', outValue );
					}
				} else if( name == 'translation' ) {
					const cache = cache_99;
					const translation = value.japanese;
					const phrase = value.english;
					cache[phrase] = translation;
					const outValue = phrase+'<br>'+translation;
					fire( 'out', outValue );
				}
				function fire( name, value ) {
					if( name == 'out' ) {
						replaceTextField_105( 'text', value );
					} else if( name == 'phrase' ) {
						promptTemplate_95( 'phrase', value )
					}
				}
			}
	
			// From[95]:
			function promptTemplate_95( name, value ) {
				if( name == 'phrase' ) {
					const phrase = value;
					const prompt = `Translate the following english sentence into Japanese as quick as possible respecting punctuation:
													  ${phrase}
													Produce you answer in JSON object with the fields:
													- "english": english sentence,
													- "japanese": japaneese translation`;
					fire( 'out', prompt );
				}
				function fire( name, value ) {
					if( name == 'out' ) {
						translateInJP_96( 'user', value );
					}
				}
			}
	
			// From[96]:
			const n96 = {
				timer: null,
				isTimeout: false,
				defaultJPResponse: '',
				// ChatGPT properties
				chatGPT: {
					model: 'gpt-3.5-turbo-1106',
					hasHistory: false,
					stream: false,
					maxRetry: 1,
					timeOut: 10,
				},
			};
			function translateInJP_96( name, value ) {
				if( name == 'user' ) {
					callChatGPT( value, (response)=> fire( 'assistant', response ) );
				}
				
				function callChatGPT( userInput, callback ) {
					//callback( { english: 'ENGLISH-TEXT', japanese: 'TRANSLATION-JP' } )
					const history = [];
					if( userInput ) {
						const entry = { role: 'user', content: userInput };
						// Update history
						history.push( entry );
					}
	
					// Pass all property to REST call
					const propertyList = n96.chatGPT;
					chatGPT.setParamList( propertyList );
					
					// Handle timeout for defaultResponse
					clearTimer();
					n96.timer = setTimeout( ()=> {
						n96.isTimeout = true;
						// Extract the english text from prompt
						const promptList = userInput.split( '\n' );
						const englishText = promptList[1].trim();
						const timeoutResponse = { english: englishText, japanese: n96.defaultJPResponse };
						fire( 'assistant', timeoutResponse );
					}, propertyList.timeOut*1000 );

					// Ask chatGPT
					chatGPT.getResponse( history, (response)=>{
						
						const isTimeout = n96.isTimeout;
						clearTimer();

						if( !isTimeout ) {
							const startJSONString = '```json\n';
							const jsonStrIdx = response.indexOf( startJSONString );
							if( jsonStrIdx != -1 ) {
								const fromIndex = jsonStrIdx+startJSONString.length;
								const toIndex = response.lastIndexOf( '\n```' );
								response = response.substring( fromIndex, toIndex );
							}
							let objResponse = '';
							try {
								objResponse = JSON.parse( response );
							} catch( e ) {
								// Extract the english text from prompt
								const promptList = userInput.split( '\n' );
								const englishText = promptList[1].trim();
								objResponse = { english: englishText, japanese: n96.defaultJPResponse };
							}
							// Genereate output
							//graphData.dfe.fireOutput( nodeData, 'history', history );
							fire( 'assistant', objResponse );
						}
					});
				}
				function fire( name, value ) {
					if( name == 'assistant' ) {
						cacheManagement_98( 'translation', value );
					}
				}
				function clearTimer() {
					if( n96.timer ) {
						clearTimeout( n96.timer );
						n96.timer = null;
						n96.isTimeout = false;
					}
				}
			}

			// From[105]:
			const n105 = {
				message: null,
			}
			function replaceTextField_105( name, value ) {
				if( name == 'message' ) {
					n105.message = value;
				} else if( name == 'text' ) {
					const outValue = { 
						sender: n105.message.sender, 
						receiver: n105.message.receiver,
						text: value 
					};
					fire( 'message', outValue );
				}
				function fire( name, value ) {
					if( name == 'message' ) {
						hChat_101( 'message', value );
					}
				}
			}
	
			// From[101]
			let hc_101 = null;
			function hChat_101( name, value ) {
				if( name == 'message' ) {
					//hc_101.addMessage( 'act', 'empty', value );
					hc_101.addMessage( value.sender, value.receiver, value.text );
	
					consumeQueue_110( 'doTrigger' );
				} else if( name == 'clear' ) {
					// From[101]: function DataFlow_Chat_initChat( dataKey )
					hc_101 = new HChat( 'mainChat-101', '100%', '100%' );
					
					// From[101]: HChat props_ using:
					//   n = getNodeData( 101 )
					//   graphData.dfe.getPropertyList( n )
					const props_101 = {
						"userList": [
							{ name: 'empty', url: '~/empty.png' },
							{ name: 'act', url: '~/act.png', color: 'Linen' },
							{ name: 'look', url: '~/look.png', color: 'MistyRose' },
							{ name: 'speak', url: '~/speak.png', color: 'HoneyDew' },
							{ name: 'think', url: '~/think.png', color: 'White' },
							{ name: 'hear', url: '~/hear.png', color: 'AliceBlue'},
						],
						"hasInputField": false,
						"messageGap": "50px",
						"iconHeight": "150px",
						"backgroundColor": "white",
						"fontSize": "26px"
					};
					
					// From[101]: function DataFlow_Chat_initUserList( nodeData, hc )
					if( props_101.userList ) {
							const userList = props_101.userList;
						// If userList is defined (input or property)
						for( const userInfo of userList ) {
							const userName = userInfo.name;
							const userImageURL = userInfo.url.replace( '~', HChat.path );
							const isSender = ( userName.toLowerCase() != 'all' );
							const userColor = userInfo.color;
							hc_101.addUser( userName, userImageURL, userColor, isSender );
						}
					}
					for( const name in props_101 ) {
						hc_101.setProperty( name, props_101[name] );
					}
				}
			}
			function setTranslationState() {
				const el = document.getElementById( 'translation' );
				translationState = el.checked;
			}
	
			/************************
			 *  Saving routine
			 * 
			 ************************/
			document.addEventListener('DOMContentLoaded', (event) => {

				document.body.style.margin = '0px';
				const saveButton = document.getElementById('saveButton');
				if( saveButton ) {
					saveButton.addEventListener('click', async () => {
						try {
							// Options for the save file picker
							const options = {
								types: [
									{
										description: 'Text Files',
										accept: {
											'text/plain': ['.js'],
										},
									},
								],
								suggestedName: 'cache2.js' ,
							};
		
							// Show file save picker
							const handle = await window.showSaveFilePicker(options);
							const writable = await handle.createWritable();
		
							// Define file content
							const content = JSON.stringify( cache_99, null, 2 );
							const fileContent = `const cache_99 = \n${content};\n`;
							// Write the contents of the string to the file
							await writable.write(fileContent);
		
							// Close the file and write the contents to disk
							await writable.close();
						} catch (err) {
							console.error(err);
							alert('Error saving file');
						}
					});
				}

				hChat_101( 'clear' );
				startROSSimulator( hc_101 );
				//startROS( hc_101 );
			});
		</script>
  </head>
<body>
	<div id="mainChat-101"></div>
	<button id="saveButton" style="position: absolute; top: 20px; right: 40px;">Save Cache</button>
	<div style="position: absolute; top: 60px; right: 40px;">
		<input type="checkbox" id="translation" name="translation" value="translation" 
		onchange="setTranslationState()">
		<label for="translation"> Translation State</label><br>
	</div>
</body>
</html>