<html>
	<meta charset="UTF-8">
  <head>
    <title>Robot's Mind</title>
    <!--includes hChat-->
    <script type='text/javascript' src='lib/hChat/1.0/hChat.js'></script>
    <link type='text/css' rel='stylesheet' href='lib/hChat/1.0/hChat.css'></link>
    <!--End-->
		<!--includes ROSLib-->
    <script type='text/javascript' src='lib/ROSLib/1.3.0/roslib.min.js'></script>
    <!--End-->
		<!--includes translation cache-->
    <script type='text/javascript' src='cache.js'></script>
    <!--End-->
		<!--includes chatGPT-->
		<script type='text/javascript' src='lib/ChatGPT/1.1/ChatGPT.js'></script>
		<!--End-->
		<script>
			// From DataFlowDSL
			const chatGPT = new ChatGPT();
			console.log( 'Instanciate ChatGPT' );
			let translationState = false;
			// From[]: MessageList
			const messageList = [
				{
					"trigger": "speak_event", 
					"expression_information": {
					"text": "Can you pass me the bottle?", 
					"sender": "Felix", 
					"receiver": "Daniel"
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "get_objects", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "get_objects", 
					"result": "Following objects were observed: the_cola_bottle.", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "get_persons", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "get_persons", 
					"result": "Following persons were observed: Felix, Daniel.", 
					"arguments": {}
					}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "is_person_busy", 
					"arguments": {
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "is_person_busy", 
					"result": "Daniel is not busy.", 
					"arguments": {
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"result": "Daniel can see the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_see_object", 
					"result": "Daniel can see the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "can_person_reach_object", 
					"result": "Daniel cannot reach the_cola_bottle.", 
					"arguments": {
						"person_name": "Daniel", 
						"object_name": "the_cola_bottle"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "function_call", 
					"expression_information": {
					"function_name": "move_object_to_person", 
					"arguments": {
						"object_name": "the_cola_bottle", 
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "function_result", 
					"expression_information": {
					"function_name": "move_object_to_person", 
					"result": "You moved the the_cola_bottle to Daniel.", 
					"arguments": {
						"object_name": "the_cola_bottle", 
						"person_name": "Daniel"
					}
					}
				},
				{
					"trigger": "gpt_querying", 
					"expression_information": {}
				},
				{
					"trigger": "gpt_finished", 
					"expression_information": {}
				}
			];
			
			// ROS Simulator
			function startROSSimulator( hc ) {
				const timeout = 1;
				const visualizationSim = ( index )=>
				{
					if( index < messageList.length ) {
						visualization( messageList[index] );
						setTimeout( ()=> visualizationSim( index+1 ), timeout*1000 );
					}
				};
	
				// Start simulator
				visualizationSim( 0 );
			}
			function startROS( hc ) {
				let ros = null;
				if( !ros ) {
					const rosServerURL = 'ws://localhost:9090';
					if( rosServerURL ) {
						// Connect to the ROS Bridge WebSocket server
						ros = new ROSLIB.Ros({
							url: rosServerURL, // The WebSocket connection URL to your ROS Bridge server
						});
						
						// This function is called upon a successful connection to ROS
						ros.on('connection', function() {
							const msg = 'ROS Connected';
							console.log( msg );
							console.log( 'status', msg );
							document.getElementById('ROS-Status').innerText = msg;
							subscribe( ros );
						});
						
						// This function is called if the connection to ROS is closed
						ros.on('close', function() {
							const msg = 'ROS closed';
							console.log( msg );
							console.log( 'status', msg );
							document.getElementById('ROS-Status').innerText = msg;
							ros = null;
						});
						
						// This function is called if there's an error in the connection to ROS
						ros.on('error', function(error) {
							isRosConnected = false;
							const msg = 'ROS Error: '+error;
							console.log( 'status', msg );
							document.getElementById('ROS-Status').innerText = msg;
						});
					} else {
						isRosConnected = false;
						const msg = 'ROS URL undefined';
						document.getElementById('ROS-Status').innerText = msg;
						graphData.dfe.fireOutput( nodeData, 'status', msg );
					}
				}

				function subscribe( ros ) {
					if( true ) {
						const label = '/action_xai_topic';
						const dataType = 'std_msgs/String';
						const topicName = label.toLowerCase();
						
						// Create a new ROSLIB.Topic object to subscribe to a ROS topic
						const topic = new ROSLIB.Topic({
							ros: ros, // The ROSLIB.Ros connection handle
							name: topicName, // The name of the topic to subscribe to
							messageType: dataType, // The message type of the topic
						});
						
						// Define a callback function to handle received messages
						const onMessageReceived = ( message )=> {

							let outValue = message.data;
							try {
								outValue = JSON.parse( message.data );
							} catch( e ) {}
                            console.log('Received message on ' + topic.name + ': ' + outValue.trigger, outValue.expression_information );

							if( outValue.trigger ) {
								visualization( outValue );
							}
						}
						
						// Subscribe to the topic with the callback
						topic.subscribe( onMessageReceived );
					}
				}
			}
			// From[111]:...
			function visualization( message ) {
				produceQueue_107( 'item', message );
			}
	
			// From[108]
			const queue_108 = [];
	
			// From[107, 110]
			function produceQueue_107( name, value ) {
				if( name == 'item' ) {
					queue_108.push( value );
                    if( queue_108.length > 1 ) {
                        queue_108.push( { delay: true } );
                    }
	                console.log( 'PUSH in Queue: ', value );
					consumeQueue_110( 'in' );
				}
			}
			
			// From[110]:
			const n110 = {
				isFired: false,
			}
			function consumeQueue_110( name ) {
				if( name == 'in' ) {
					const isFired = n110.isFired;
					if( !isFired ) {
                        console.log( 'Consumer got message when idle' );
						fireFromQueue();
					} else {
                        console.log( 'Waiting for consumer finishing...' );
                    }
				} else if( name == 'doTrigger' ) {
                    console.log( 'Consumer finished, let me take the next message' );
					fireFromQueue();
				}
	
				function fireFromQueue() {
					// Check if the queue is not empty
					const isQueueFull = ( ( queue_108 != null ) && ( queue_108.length != 0 ) );
					// If queue is not empty --> tell we fired
					n110.isFired = isQueueFull;
	
					// If queue is not empty -> fire last element
					if( isQueueFull ) {
						const message = queue_108.shift();
	                    console.log( 'Consuming message ', message );

                        if( message.delay ) {
                            setTimeout( fireFromQueue , 500 );
                        } else {
                            composeExplanationText_106( 'in', message );
                        }
                    }
				}
			}
	
			// From[106]:
			function composeExplanationText_106( name, value ) {
				if( name == 'in' ) {
					let outString = '???';
					let sender = 'think';
					let receiver = 'empty';
					const info = value.expression_information;
					const arg = info.arguments;
					let objectName = '';
					switch( value.trigger ) {
						case 'speak_event':
							sender = 'hear';
                            let dest = info.receiver;
                            if( info.receiver == 'the_robot' ) {
                                dest = 'me';
                            }
							outString = `I heard ${info.sender} say to ${dest}: ${info.text}`;
							break;
						case 'gpt_querying':
							outString = '???';
							break;
						case 'function_call_OFF':
							switch( info.function_name ) {
								case 'get_objects':
									outString = 'Let\'s see which objects are on the table...';
									break;
								case 'get_persons':
									outString = 'Let\'s see which persons are with me...';
									break;
								case 'check_reach_object_for_robot':
								    objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check if I can get ${objectName}...`;
									break;
								case 'check_hindering_reasons':
								    objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check the situation for ${arg.person_name} and ${objectName}...`;
									break;
								case 'is_person_busy_or_idle':
									outString = `Let\'s see if ${arg.person_name} is busy...`;
									break;
								case 'can_person_see_object':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check if ${arg.person_name} can see ${objectName}...`;
									break;
								case 'can_person_reach_object':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Let\'s check if ${arg.person_name} can reach ${objectName}...`;
									break;
								case 'move_object_to_person':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Now, let\'s try to move ${objectName} to ${arg.person_name}...`;
									break;
								case 'hand_object_over_to_person':
									objectName = arg.object_name.replace(/_/gi, " ");
									outString = `Now, let\'s try to hand ${objectName} to ${arg.person_name}...`;
									break;
								case 'pour_into':
									source_container_name = arg.source_container_name.replace(/_/gi, " ");
									target_container_name = arg.target_container_name.replace(/_/gi, " ");
									outString = `Now, let\'s try to pour ${source_container_name} into ${target_container_name}...`;
									break;
								case 'speak':
									//outString = `Now, let\'s say "${arg.text}" to ${arg.person_name}...`;  // TO BE VERIFIED
                                    outString = `Now, let\'s inform ${arg.person_name}...`;  // TO BE VERIFIED
									break;
								case 'stop':
                                    outString = '???';
									break
								default:
									break;
							}
							break;
						case 'function_result':
							let result = info.result.replace(/_/gi, " ");;
							sender = 'look';
							receiver = 'empty';
							switch( info.function_name ) {
								case 'get_objects':
								// case 'get_persons':
									const idx = result.indexOf( ':' );
									result = result.slice( idx + 2 );
									outString = `I see ${result}`;
									break;
								case 'check_reach_object_for_robot':
									result = result.replace("the robot", "I");
									result = result.replace(/_/gi, " ");
									outString = `${result}`;
									break;
								case 'check_hindering_reasons':
									outString = `${result}`;
									break;
								case 'is_person_busy_or_idle':
									outString = `${result}`;
									break;
								case 'can_person_see_object':
									outString = `${result}`;
									break;
								case 'can_person_reach_object':
									outString = `${result}`;
									break;
								case 'hand_object_over_to_person':
								case 'move_object_to_person':
									sender = 'act';
									// Replace 'your' with 'my'
									result = replaceAll( result );
									outString = `${result}`;
									break;
								case 'pour_into':
									sender = 'act';
									// Replace 'your' with 'my'
									result = replaceAll( result );
									outString = `${result}`;
									break;
								case 'speak':
                                    sender = 'speak';
                                    const receiver = arg.person_name;
                                    const text = arg.text;
									outString = `I said to ${receiver}: ${text}`;
									break;
								case 'stop':
                                    sender = 'think';
                                    // Replace 'your' with 'my'
									result = replaceAll( result );
                                    outString = '???'; //result;
									break;
								default:
									break;
							}
							break;
						case 'gpt_finished':
							sender = 'empty';
							outString = '---';
							// outString = `I am ready...\n${(info.text == "null"? "":info.text)}`;
							break;
						default:
							break;
					}
					if( outString != '???' ) {
						const outValue = { sender, receiver, text:outString };
						//graphData.dfe.fireOutput( nodeData, 'message', outValue );
						//graphData.dfe.fireOutput( nodeData, 'text', outString );
						fire( 'message', outValue );
						fire( 'text', outString );
					} else {
						console.log( 'EVENT IS IGNORED !!!!!!!!!!!!!!!!!!!!' );
                        consumeQueue_110( 'doTrigger' );
					}
				}
                function replaceAll( result ) {
                    // Replace 'your' with 'my'
                    result = result.replace(/your/gi, "my");
                    // Replace 'your' with 'my'
                    result = result.replace(/Your/gi, "My");

                    result = result.replace(/you were/gi, "I was");
                    
                    result = result.replace(/You were/gi, "I was");

                    // Replace 'you' with 'I'
                    result = result.replace(/you/gi, "I");
                    // Replace 'You' with 'I'
                    result = result.replace(/You/gi, "I");
                    return( result );
                }
				function fire( name, value ) {
					if( name == 'text' ) {
						cacheManagement_98( 'phrase', value );
					} else if( name == 'message' ) {
						replaceTextField_105( 'message', value );
					}
				}
			}
	
			// From[98]:
			const n98 = {
				isTranslated: true,
			};
			function cacheManagement_98( name, value ) {
				if( name == 'phrase' ) {
					//const isTranslated = n98.isTranslated;
					const isTranslated = translationState;
					const cache = cache_99;
					const phrase = value;
					if( isTranslated ) {
						const translation = cache[phrase];
						if( translation ) {
							const outValue = phrase+'<br>'+translation;
                            console.log( 'English: ', outValue );
							fire( 'out', outValue );
						} else {
                            console.log( 'English: ', phrase );
							fire( 'phrase', phrase );
						}
					} else {
						const outValue = phrase;
                        console.log( 'English: ', outValue );
						fire( 'out', outValue );
					}
				} else if( name == 'translation' ) {
					const cache = cache_99;
					const translation = value.japanese;
					const phrase = value.english;
					cache[phrase] = translation;
					const outValue = phrase+'<br>'+translation;
					fire( 'out', outValue );
				}
				function fire( name, value ) {
					if( name == 'out' ) {
						replaceTextField_105( 'text', value );
					} else if( name == 'phrase' ) {
						promptTemplate_95( 'phrase', value )
					}
				}
			}
	
			// From[95]:
			function promptTemplate_95( name, value ) {
				if( name == 'phrase' ) {
					let phrase = value;
                    let index = value.indexOf( '\n\n' );
                    if( index != -1 ) {
                        phrase = phrase.substring( 0, index );
                    }

					const prompt = `Translate the following english sentence enclosed between ### into Japanese as quick as possible respecting punctuation:
													  ###
													    ${phrase}
													  ###
													Produce your answer in JSON object with the fields:
													- "japanese": japanese translation`;
					fire( 'out', { prompt, phrase } );
				}
				function fire( name, value ) {
					if( name == 'out' ) {
						translateInJP_96( 'user', value );
					}
				}
			}
	
			// From[96]:
			const n96 = {
				timer: null,
				isTimeout: false,
				defaultJPResponse: '',
				// ChatGPT properties
				chatGPT: {
					model: 'gpt-3.5-turbo-1106',
					hasHistory: false,
					stream: false,
					maxRetry: 1,
					timeOut: 10,
				},
			};
			function translateInJP_96( name, value ) {
				if( name == 'user' ) {
                    const phrase = value.phrase;
                    const prompt = value.prompt;
					callChatGPT( prompt, phrase );
				}
				
				function callChatGPT( userInput, phrase ) {
					const history = [];
					if( userInput ) {
						const entry = { role: 'user', content: userInput };
						// Update history
						history.push( entry );
					}
	
					// Pass all property to REST call
					const propertyList = n96.chatGPT;
					chatGPT.setParamList( propertyList );
					
					// Handle timeout for defaultResponse
					clearTimer();
					n96.timer = setTimeout( ()=> {
						n96.isTimeout = true;

						const timeoutResponse = { english: phrase, japanese: n96.defaultJPResponse };
						fire( 'assistant', timeoutResponse );
					}, propertyList.timeOut*1000 );

					// Ask chatGPT
					chatGPT.getResponse( history, (response)=>{
						
						const isTimeout = n96.isTimeout;
						clearTimer();

						if( !isTimeout ) {
							const startJSONString = '```json\n';
							const jsonStrIdx = response.indexOf( startJSONString );
							if( jsonStrIdx != -1 ) {
								const fromIndex = jsonStrIdx+startJSONString.length;
								const toIndex = response.lastIndexOf( '\n```' );
								response = response.substring( fromIndex, toIndex );
							}
							let objResponse = '';
							try {
								objResponse = JSON.parse( response );
                                objResponse.english = phrase;
							} catch( e ) {
								objResponse = { english: phrase, japanese: n96.defaultJPResponse };
							}
							// Genereate output
							//graphData.dfe.fireOutput( nodeData, 'history', history );
							fire( 'assistant', objResponse );
						}
					});
				}
				function fire( name, value ) {
					if( name == 'assistant' ) {
						cacheManagement_98( 'translation', value );
					}
				}
				function clearTimer() {
					if( n96.timer ) {
						clearTimeout( n96.timer );
						n96.timer = null;
						n96.isTimeout = false;
					}
				}
			}

			// From[105]:
			const n105 = {
				message: null,
			}
			function replaceTextField_105( name, value ) {
				if( name == 'message' ) {
					n105.message = value;
				} else if( name == 'text' ) {
					const outValue = { 
						sender: n105.message.sender, 
						receiver: n105.message.receiver,
						text: value 
					};
					fire( 'message', outValue );
				}
				function fire( name, value ) {
					if( name == 'message' ) {
						hChat_101( 'message', value );
					}
				}
			}
	
			// From[101]
			let hc_101 = null;
			function hChat_101( name, value ) {
				if( name == 'message' ) {
					//hc_101.addMessage( 'act', 'empty', value );
                    console.log( 'ADD MESSAGE: ', value.text );
					hc_101.addMessage( value.sender, value.receiver, value.text );
	
					consumeQueue_110( 'doTrigger' );
				} else if( name == 'clear' ) {
					// From[101]: function DataFlow_Chat_initChat( dataKey )
					hc_101 = new HChat( 'mainChat-101', '100%', '100%' );
					
					// From[101]: HChat props_ using:
					//   n = getNodeData( 101 )
					//   graphData.dfe.getPropertyList( n )
					const props_101 = {
						"userList": [
							{ name: 'empty', url: '~/empty.png', color: 'white' },
							{ name: 'act', url: '~/act.png', color: 'Linen' },
							{ name: 'look', url: '~/look.png', color: 'AliceBlue' },
							{ name: 'speak', url: '~/speak.png', color: 'HoneyDew' },
							{ name: 'think', url: '~/think.png', color: 'White' },
							{ name: 'hear', url: '~/hear.png', color: 'MistyRose'},
						],
						"hasInputField": false,
						"messageGap": "50px",
						"iconHeight": "150px",
						"backgroundColor": "white",
						"fontSize": "26px"
					};
					
					// From[101]: function DataFlow_Chat_initUserList( nodeData, hc )
					if( props_101.userList ) {
							const userList = props_101.userList;
						// If userList is defined (input or property)
						for( const userInfo of userList ) {
							const userName = userInfo.name;
							const userImageURL = userInfo.url.replace( '~', HChat.path );
							const isSender = ( userName.toLowerCase() != 'all' );
							const userColor = userInfo.color;
							hc_101.addUser( userName, userImageURL, userColor, isSender );
						}
					}
					for( const name in props_101 ) {
						hc_101.setProperty( name, props_101[name] );
					}
				}
			}
			function setTranslationState() {
				const el = document.getElementById( 'translation' );
				translationState = el.checked;
			}
	
			/************************
			 *  Saving routine
			 * 
			 ************************/
			document.addEventListener('DOMContentLoaded', (event) => {

				document.body.style.margin = '0px';
				const saveButton = document.getElementById('saveButton');
				if( saveButton ) {
                    saveButton.addEventListener('click', async () => {
                        try {
                            // Define file content
                            const content = JSON.stringify(cache_99, null, 2);
                            const fileContent = `const cache_99 = \n${content};\n`;

                            // Create a Blob from the file content
                            const blob = new Blob([fileContent], { type: 'text/plain' });

                            // Create a URL for the Blob
                            const url = URL.createObjectURL(blob);

                            // Create a temporary anchor element and trigger the download
                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'cache.js'; // Set the file name for download
                            document.body.appendChild(a); // Append anchor to body
                            a.click(); // Trigger click to download
                            document.body.removeChild(a); // Remove anchor from body

                            // Revoke the Blob URL
                            URL.revokeObjectURL(url);
                        } catch (err) {
                            console.error(err);
                            alert('Error saving file');
                        }
                    });
				}

                setTranslationState();
				hChat_101( 'clear' );
				//startROSSimulator( hc_101 );
				startROS( hc_101 );
			});
		</script>
  </head>
<body>
	<div id="mainChat-101"></div>
	<button id="saveButton" style="position: absolute; top: 20px; right: 40px;">Save Cache</button>
	<div style="position: absolute; top: 60px; right: 40px;">
		<input type="checkbox" id="translation" name="translation" value="translation" 
		onchange="setTranslationState()">
		<label for="translation">JP Translation</label><br>
	</div>
    <p id="ROS-Status" style="position: absolute; top: 90px; right: 40px;">Not Connected</p>

</body>
</html>
