<!--
  =============================================================================
  Licensed Materials - Property of Frank Joublin and Antonio Ceravola.
  (C) Copyright Frank Joublin and Antonio Ceravola. 2021, All Rights Reserved.
  France Government Users Restricted Rights - Use, duplication or disclosure
  restricted by GSA ADP Schedule Contract with Frank Joublin and Antonio Ceravola.
  =============================================================================
  Module: HyperGraph <moduleName>
  Date: 10.07.2020
  =============================================================================
-->
<!DOCTYPE html>
<html>
<head>
  <meta charset='utf-8'>
  <title>HyperGraph 3.0</title>
  
  <!-- List here all styles -->
  <style>
    body {
      background-color: #3c3c3c;
      overflow: hidden;
      margin: 0;
    }
    #statusDiv {
      position: absolute;
      width: 100%;
      height: 100%;
      box-sizing: border-box;
      border: 10px;
      border-style: solid;
      border-color: rgba(125, 125, 125, 0.6);
      z-index: 100;
      pointer-events: none;
    }
    #statusDiv.loading {
      border-color: rgba(30, 144, 255, 0.6);
    }
    #statusDiv.default {
      border-color: rgba(125, 125, 125, 0.6);
    }
     #statusDiv.error {
      border-color: rgba(255, 0, 0, 0.6);
    }
    #statusDiv.warning {
      border-color: rgba(255, 221, 0, 0.6);
    }
    #statusDiv.saved {
      animation-name: saved;
      animation-duration: 2s;
    }
    @keyframes saved {
      from { border-color: rgba(123, 255, 0, 0.6); }
      to { border-color: rgba(125, 125, 125, 0.6); }
    }
    .diagramDiv {
      position: absolute;
      /* top: -70px;   /* TODO: Remove this line, remove last lines */
      width: 100%;
      /* height: 120%; /* TODO: Restore to 100%
       remove also last lines in htmlMenu.js in function _computeRootMenuMouseClickXY */
      height: 100%;
      background: rgb(160, 160, 160);
    }
    #contextMenuDiv {
      position: relative;
      /*position: absolute;
      width: 100%;
      height: 100%;
      top: 0px;
      left: 0px;*/
    }
    .wb-like {
        background-size: 20px auto;
    }
    .wb-like.active {
        background-image: url(/fileServer/pictures/pinnedw.svg) !important;
    }
  </style>
  
  <!-- List here all includes -->
  <!--GoJS Editor Includes-->
  <script type='text/javascript' src='/library/gojs/2.3.3/go.js'></script>
  <script type='text/javascript' src='/library/gojs/PolylineLinkingTool.js'></script>
  <script type='text/javascript' src='/library/gojs/SnapLinkReshapingTool.js'></script>
  <script type='text/javascript' src='/library/gojs/InGroupClickCreatingTool.js'></script>
  <!--End-->
  <!--WinBox Editor Includes-->
  <link rel="stylesheet" href="/library/winbox/0.2.73/modern.min.css">
  <link rel="stylesheet" href="/library/winbox/0.2.73/white.min.css">
  <script type="text/javascript" src="/library/winbox/0.2.73/winbox.bundle.min.js"></script>
  <!--End-->
  <!--Contextify Includes-->
  <script src="https://kit.fontawesome.com/df7df855c2.js" crossorigin="anonymous"></script>
  <script src="/library/Contextify/1.0.1/Contextify.js" id="Contextify"> </script>
  <!--End-->
  
  <!-- List here all scripts -->
  <script>
    //------------------------
    // Declarations
    //------------------------
    const appData = {};
    let diagramData = {};  // Previously graphData
    const $ = go.GraphObject.make;  // for conciseness in defining templates
    const hgRoot = {
      status: {
        persistent: {
          diagram: {
            d_viewList: [],
          },
          session: {
            s_isReadOnly: false,
            s_statusName: 'ready',
            w_positionList: {
              // url1: {
              //   key1: [x, y, width, height],
              //   key2: [x, y, width, height],
              // },
            },
            w_openList: {
              // url1: {
              //  key1: { isPin: true },
              //  key1: { isPin: false },
              // }
            },
          },
        },
        transient: {
          s_statusEl: null,
          d_lastNodeKey: null, // null => first time it will be computed by newUniqueKey()
          d_modelEvents: {
            // Node Events
          	onNodeGraphModelChanged: null,
          	onNodeGraphSelectionChanged: null,
          },
          d_diagram: null,
          c_contextMenu: null,
          c_mainMenuModel:
          [
            { 
              text: 'WorkSpace: ...', 
              type: 'button', icon: 'fa-home', hotkey: 'Ctrl + 1', 
              enabled: false 
            },
            { 
              text: 'Properties', 
              type: 'button', icon: 'fa-share',
              click: Diagram_showPropertyFromSelection,
            },
            { type: 'separator'},
            { 
              text: 'Open',
              type: 'button', icon: 'fa-share',
              click: System__openFromMenu,
            },
            { type: 'separator'},
            { 
              text: 'View...', 
              type: 'button', icon: 'fa-times-circle', 
              child: [
                { 
                  text: 'Zoom to Fit', 
                  type: 'button', icon: 'fa-twitter', hotkey: 'Alt + 1', 
                  click: Diagram_zoomToFit,
                },
                { 
                  text: 'Previous View',
                  type: 'button', icon: 'fa-facebook', hotkey: 'Alt + 1', 
                  click: Diagram_goToView.bind(this,0),
                },
                { type: 'separator'},
                { 
                  text: 'Go to View 1', 
                  type: 'button', icon: 'fa-facebook', hotkey: 'Alt + 1', 
                  click: Diagram_goToView.bind(this,1),
                },
                { 
                  text: 'Go to View 2', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_goToView.bind(this,2),
                },
                { 
                  text: 'Go to View 3', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_goToView.bind(this,3),
                },
                { 
                  text: 'Go to View 4', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_goToView.bind(this,4),
                },
                { type: 'separator'},
                { 
                  text: 'Set View 1', 
                  type: 'button', icon: 'fa-facebook', hotkey: 'Alt + 1', 
                  click: Diagram_storeView.bind(this,1),
                },
                { 
                  text: 'Set View 2', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_storeView.bind(this,2),
                },
                { 
                  text: 'Set View 3', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_storeView.bind(this,3),
                },
                { 
                  text: 'Set View 4', 
                  type: 'button', icon: 'fa-instagram', hotkey: 'Alt + 1', 
                  click: Diagram_storeView.bind(this,4),
                },
              ],
            },
            // NODE Beg: Diagram Grid Actions
            {
              text: 'Tools...',
              type: 'button', icon: 'fa-share',
              child: [
                { 
                  text: 'Toogle Visible Grid', 
                  type: 'button', icon: 'fa-twitter', hotkey: 'Alt + 1',
                  click: Diagram_toogleVisibleGrid,
                },
              ],
            },
            // NODE End: Diagram Grid Actions
            { type: 'separator'},
            { 
              text: 'Toogle Read Only', 
              type: 'button', icon: 'fa-share',
              click: State_toogleReadOnly,
            },
          ],
          w_winList: {
            // url1: {
            //   key1: win, 
            // }
          },
        },
      },
    };
    
    //------------------------
    // Initialization on load
    //------------------------
    function HyperGraph_init() {
      Diagram_init( 'diagramDiv' );
      Diagram_setup();
      State_init( 'statusDiv' );
      ContextMenu_init();
      //ContextMenu__registerMenu();
    }
    
    //------------------------
    // List here all functions
    //------------------------
    //------------------------
    // API Functions
    //------------------------
    function State_set( name, value ) {
      if( hgRoot.status.persistent.diagram[name] !== undefined ) {
        hgRoot.status.persistent.diagram[name] = value;
      } else if( hgRoot.status.persistent.session[name] !== undefined ){
        hgRoot.status.persistent.session[name] = value;
      } else if( hgRoot.status.transient[name] !== undefined ){
        hgRoot.status.transient[name] = value;
      } else {
        console.error( `Error: field ${name} not found in state` );
      }
    }
    function State_get( name ) {
      if( hgRoot.status.persistent.diagram[name] !== undefined ) {
        return( hgRoot.status.persistent.diagram[name] );
      } else if( hgRoot.status.persistent.session[name] !== undefined ) {
        return( hgRoot.status.persistent.session[name] );
      } else if( hgRoot.status.transient[name] !== undefined ) {
        return( hgRoot.status.transient[name] );
      } else {
        console.error( `Error: field ${name} not found in state` );
      }
    }
    //------------------------
    // API Functions
    //------------------------
    function State_init( divId ) {
      const el = document.getElementById( divId );
      if( el ) {
        State_set( 's_statusEl', el );
      } else {
        console.error( `Error: div "${divId}" not found` );
      }
    }
    function State_toogleReadOnly() {
      const ro = !State_get( 's_isReadOnly' );
      State_set( 's_isReadOnly', ro );
      const s_statusEl = State_get( 's_statusEl' );
      s_statusEl.style['border-style'] = ( ro? 'dashed': 'solid' );
      State_set( 's_statusName', ( ro? 'readOnly': 'read&Write' ) );
    }
    function State_isReadOnly() {
      return( State_get( 's_isReadOnly' ) );
    }
    function State_setError() {
      const s_statusEl = State_get( 's_statusEl' );
      s_statusEl.className = 'error';
      State_set( 's_statusName', 'error' );
    }
    function State_setReady() {
      const s_statusEl = State_get( 's_statusEl' );
      s_statusEl.className = 'default';
      State_set( 's_statusName', 'ready' );
    }
    function State_setLoading() {
      const s_statusEl = State_get( 's_statusEl' );
      s_statusEl.className = 'loading';
      State_set( 's_statusName', 'loading' );
    }
    function State_setNeedSave() {
      if( !State_get( 's_isReadOnly' ) ) {
        const s_statusEl = State_get( 's_statusEl' );
        s_statusEl.className = 'warning';
        State_set( 's_statusName', 'warning' );
      }
    }
    function State_setSaved() {
      if( !State_get( 's_isReadOnly' ) ) {
        const s_statusEl = State_get( 's_statusEl' );
        s_statusEl.className = 'saved';
        State_set( 's_statusName', 'ready' );
      }
    }
    function State_getStatusName() {
      const result = State_get( 's_statusName' );
      return( result );
    }
    //------------------------
    // API Functions
    //------------------------
    /**
     * Returns an empty model 
     */
    function Diagram_getEmptyJSONModel() {
    	return( '{ nodeDataArray:[], linkDataArray:[] }' );
    }
    function Diagram_getDiagramURL() { // old getGraphPath
      return( 'localhost' );
    }
    function Diagram_getMainDiagram() {
      return( State_get( 'd_diagram' ) );
    }
    function Diagram_getDataInfoFromSelection() {
      let result = '';
      const data = Diagram_getFirstSelectedData();
      if( data ) {
        result = Diagram_getDataInfo( data, false );
      }
      return( result );
    }
    function Diagram_getDataSignature( data ) {
      let result = '';
      if( data ) {
        const prefix = ( data.fileURL? data.fileURL: 'emptyURL' );
        const id = `${prefix}_${data.key}`;
        result = id.replaceAll( /[^A-Za-z0-9]/g, "_" );
      }
      return( result );
    }
    function Diagram_showPropertyFromSelection() {
      alert( Diagram_getProperty(), false );
    }
    function Diagram_getProperty() {
      let result = '';
  
      // Get firt selected node
      const data = Diagram_getFirstSelectedData();
      if( data ) {
        result = Diagram_getDataInfo( data );
      } else {
        // Tooltip info for the diagram's model
        const nodeList = Diagram__getNodeList();
        const linkList = Diagram__getLinkList();
        const graphURL = 'localhost';
        // Return property
    		result = `Model Info:\n`+
    		         `- #${nodeList.length} nodes\n`+
    		         `- #${linkList.length} links\n`+
    		         `WorkSpace URL: ${graphURL}`;
      }
      return( result );
    }
    //------------------------
    // API Functions
    //------------------------
    function Diagram_init( divId ) {
  
      const d_diagram = $(go.Diagram, divId,  // create a d_diagram for the DIV HTML element
      {
        "undoManager.isEnabled": true,
      });
  
      State_set( 'd_diagram', d_diagram );
    }
    function Diagram_setup() {
      // Setup for diagram properties
      {
        // define a simple Node template (but use the default Link template)
        const defaultDSL = $(go.Node, "Auto",
          { 
            //contextMenu: myContextMenu
          },
          // Make nodes positioned by location
          new go.Binding("location", "location",go.Point.parse).makeTwoWay(go.Point.stringify),
          // Allow assignmen to layers
          new go.Binding("layerName","layerName"),
          $(go.Shape, "RoundedRectangle",
            {
              // Register double click event
              doubleClick: System__openNode,
            },
            // Shape.fill is bound to Node.data.color
            new go.Binding( "fill", "color" )
          ),
          $(go.TextBlock,
            { 
              margin: 10,
              editable: true,
              isMultiline: true,
            },  // some room around the text
            // TextBlock.text is bound to Node.data.key
            new go.Binding( "text", "label" )
          )
        );
        Diagram_setDSL( defaultDSL );
      }
      {
        const model = new go.GraphLinksModel(
        [
          { 
            "key": 4,
            "label": "Title: Grap in Code",
            "category": "Basic_Node",
            "color": "White",
            "location": "190 40",
          },
          { 
            "key": 0,
            "label": "First RootGraph",
            "category": "Basic_Node",
            "color": "Plum",
            "isDir": true,
            "fileType": "text/json",
            "fileURL": "/fileServer/01/56.json",
            "location": "60 130",
          },
          { 
            "key": 1,
            "label": "Loot at Greek Letter: Beta",
            "category": "Basic_Node",
            "color": "SandyBrown",
            "isFile": true,
            "fileType": "application/html",
            "fileURL": "https://en.wikipedia.org/wiki/Beta",
            "location": "290 130",
          },
          { 
            "key": 2,
            "label": "Loot at Greek Letter: Gamma",
            "category": "Basic_Node",
            "color": "YellowGreen",
            "isFile": true,
            "fileType": "application/html",
            "fileURL": "https://en.wikipedia.org/wiki/Gamma",
            "location": "300 210",
          },
          {
            "key": 3,
            "label": "Second RootGraph",
            "category": "Basic_Node",
            "color": "LightPink",
            "isDir": true,
            "fileType": "text/json",
            "fileURL": "/fileServer/01/58.json",
            "location": "330 300",
          }
        ],
        [
          { "from": 0, "to": 1 },
          { "from": 0, "to": 2 },
          { "from": 1, "to": 1 },
          { "from": 2, "to": 3 },
          { "from": 3, "to": 0 },
        ]);
        Diagram__setDiagramModel( model );
      }
      {
        const d = Diagram_getMainDiagram();
        if( d ) {
          // Avoid that the diagram comes slowly from the bottom in an animation
          d.animationManager.isInitial = false;
          // Use mouse wheel for zoom
          d.toolManager.mouseWheelBehavior = go.ToolManager.WheelZoom;
          // Disable port gravity (snap to port)
          d.toolManager.linkingTool.portGravity = 0;
          // enable undo & redo
          d.undoManager.isEnabled = true;
    
          // Avoid auto layout and instead use location property
          //d.layout.isInitial = false;
    
          // Set zoom speed
          // NOTE:
          // - 1.05 is good for MagicMouse
          // - 1.25 is good for other mouse and faster
      		d.commandHandler.zoomFactor = 1.25; //1.05; // 1.2;
      		// Allow infinite canvas
      		d.scrollMode = go.Diagram.InfiniteScroll;
        }
      }
      {
        const d = Diagram_getMainDiagram();
        if( d ) {
          // Define grid
        	const mainColor = {
        		dark: {
        			backgroundColor: 'rgb(60, 60, 60)',
        			lineColor1: 'rgb(70, 70, 70)',
        			lineColor2: 'rgb(80, 80, 80)',
        		},
        		light: {
        			backgroundColor: 'AliceBlue',
        			lineColor1: 'rgb(220, 220, 220)',
        			lineColor2: 'rgb(200, 200, 200)',
        		},
        	};
        	const schema = 'dark'; //config.graph.colorSchema;
        	const gridCellSize = new go.Size( 10, 10 );
        	d.grid = $(go.Panel, "Grid",
        		{
        		  name: "GRID",
        		  visible: false,
        		  gridCellSize: gridCellSize,
        		  gridOrigin: new go.Point(0, 0)
        		},
        		$(go.Shape, "LineH", { stroke: mainColor[schema].lineColor1, strokeWidth: 0.5, interval: 1 }),
        		$(go.Shape, "LineH", { stroke: mainColor[schema].lineColor2, strokeWidth: 0.5, interval: 5 }),
        		$(go.Shape, "LineH", { stroke: mainColor[schema].lineColor2, strokeWidth: 1.0, interval: 10 }),
        		$(go.Shape, "LineV", { stroke: mainColor[schema].lineColor1, strokeWidth: 0.5, interval: 1 }),
        		$(go.Shape, "LineV", { stroke: mainColor[schema].lineColor2, strokeWidth: 0.5, interval: 5 }),
        		$(go.Shape, "LineV", { stroke: mainColor[schema].lineColor2, strokeWidth: 1.0, interval: 10 })
        	);
  	
        	// By default grid is not visible
      		d.grid.visible = false;
      		d.div.style.background = mainColor[schema].backgroundColor;
		
      		// Force positioning of nodes according to grid
      		d.toolManager.draggingTool.gridSnapCellSize = gridCellSize;
      		d.toolManager.draggingTool.isGridSnapEnabled = true;
      		d.toolManager.resizingTool.isGridSnapEnabled = true;
        }
      }
    }
    function Diagram_setDSL( dsl ) {
      // DSL definition
      const d = State_get( 'd_diagram' );
      if( d && dsl ) {
        d.nodeTemplate = dsl;
      }
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Diagram__getEmptyModel() {
      return( new go.GraphLinksModel( [], [] ) );
    }
    function Diagram__setDiagramModel( model ) {
      if( model ) {
        const d = State_get( 'd_diagram' );
        // create the model data that will be represented by Nodes and Links
        d.model = model;
      }
    }
    //------------------------
    // API Functions
    //------------------------
    function Diagram_getDiagramImage() {
    	let result = null;
    	const d = State_get( 'diagram' );
      if( d ) {
    		result = d.makeImageData({ 
    			returnType: 'string',
    			size: new go.Size( 800, 532 ),
    			padding: new go.Margin( 50, 10, 10, 10 ),
    		});
    	}
    	return( result );
    }
    function Diagram_getDataInfo( data, isShort ) {
      let result = '';
      if( data ) {
        let nodeType = 'NoType';
        if( data.from && data.to ) {
          nodeType = 'Link';
        } else {
          nodeType = ( data.linkToKey? 'LinkNode': 'Node' );
        }
    
        const label = data.label || data.category;
        result = `${nodeType} [${data.key}]: ${label}`;
        if( !isShort ) {
          result = result+`\nCategory: ${data.category}`+
                 ( data.group? `\nMember of group: [${data.group}]`: '' );
        }
      }
      return( result );
    }
    function Diagram_getCurrentView() {
      const d =Diagram_getMainDiagram();
      if( d ) {
      	// Get current position
      	const position = d.position;
      	// Get current zoom scale
      	const scale = d.scale;
      	// Get grid visibility
      	const isGridOn = d.grid.visible;
      	// Define view info
      	const viewInfo = {
      		position: {
      			x: position.x,
      			y: position.y,
      		},
      		scale,
      		isGridOn,
      	};
    	  return( viewInfo );
      } else {
        return( {} );
      }
    }
    function Diagram_setCurrentView( viewInfo ) {
      const d = Diagram_getMainDiagram();
      if( d && viewInfo ) {
        if( viewInfo.scale ) {
        	// Restore first scale (must be first)
        	d.scale = viewInfo.scale;
        }
        if( viewInfo.position ) {
        	// Restore position
        	d.position = new go.Point( viewInfo.position.x, 
        	                           viewInfo.position.y );
        }
        if( typeof( viewInfo.isGridOn ) == 'boolean' ) {
        	// Restore grid
        	d.grid.visible = viewInfo.isGridOn;
        }
      }
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Diagram__getNodeList() {
      let result = [];
      const d = State_get( 'd_diagram' );
      // Otherwise give info about the diagram
      if( d ) {
        // Return node list
        result = d.model.nodeDataArray;
      }
      return( result );
    }
    function Diagram__getLinkList() {
      let result = [];
      const d = State_get( 'd_diagram' );
      // Otherwise give info about the diagram
      if( d ) {
        // Return node list
        result = d.model.linkDataArray;
      }
      return( result );
    }
    //------------------------
    // API Functions
    //------------------------
    function Diagram_getSelectedDataList() {
      let result = [];
      const d = Diagram_getMainDiagram();
      if( d ) {
        const selection = d.selection;
        const iterator = selection.iterator;
        while( iterator.next() ) {
          const node = iterator.value;
          const data = Diagram__getNodeData( node );
          if( data ) {
            result.push( data );
          }
        }
      }
      return( result );
    }
    function Diagram_getFirstSelectedData() {
      let result = null;
      const d = Diagram_getMainDiagram();
      if( d ) {
        const node = d.selection.first();
        if( node ) {
          result = Diagram__getNodeData( node );
        }
      }
      return( result );
    }
    function Diagram_getSelectionCount() {
      let result = 0;
      const d = Diagram_getMainDiagram();
      if( d ) {
        result = d.selection.count;
      }
      return( result );
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Diagram__getNodeData( node ) {
      let result = null;
      if( node ) {
        result = node.data;
      }
      return( result );
    }
    function Diagram__getNodeElData( nodeEl ) {
      let result = null;
      if( nodeEl ) {
        result = nodeEl.part.data;
      }
      return( result );
    }
    //------------------------
    // API Functions
    //------------------------
    /**
     * Set the model from a JSON string model
     */
    function Diagram_setJSONModel( jsonModel ) {
      let result = false;
    	const d = Diagram_getMainDiagram();
      if( d && jsonModel ) {
    		const model = go.Model.fromJson( jsonModel );
    		Diagram__setModel( model );
    		result = true;
    	} 
    	return( result );
    }
    /**
     * Set the model as a JSON string
     */
    function Diagram_getJSONModel() {
    	const d = Diagram_getMainDiagram();
    	const nodeList = Diagram__getNodeList();
    	if( d && ( nodeList.length > 0 ) ) {
    		return( d.model.toJson() );
    	} else {
    	  return( Diagram__getEmptyJSONModel() );
    	}
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Diagram__setModel( model ) {
    	const d = Diagram_getMainDiagram();
      if( d ) {
    		Diagram__clearInstance();
    		Diagram__setDiagramModel( model );
    		d.model.copiesKey = false;
    		d.model.makeUniqueKeyFunction = Diagram__newUniqueKey;
    		d.model.undoManager.isEnabled = true;
    		d.model.addChangedListener( Diagram___onGraphChangedFilter );
    		// These two lines make sure that nodes are copied in copy/paste as deep copy
    		d.model.copiesArrays = true;
    		d.model.copiesArrayObjects = true;
    		d.model.linkKeyProperty = 'key';
    		// Necessary to remember portIds 
    		d.model.linkFromPortIdProperty = 'fromPort';
    		d.model.linkToPortIdProperty = 'toPort';
    		// Reset last key used by function newUniqueKey()
    		Diagram__clearLastNodeKey();

    		// Make graph fully visible
    		d.zoomToFit();
    	}
    }
    function Diagram__clearInstance() {
      const e = State_get( 'd_modelEvents' );
      // Node Events
    		e.onNodeGraphModelChanged = null;
    		e.onNodeGraphSelectionChanged = null;
    }
    function Diagram___onGraphChangedFilter( e ) {
    	// Ignore unimportant Transaction events
    	if ( e.isTransactionFinished ) {
    		const txn = e.object;  // a Transaction
    		// Call callback only if there is a model change
    		if( txn !== null  ) {
    			//this.em.call.onGraphChanged();
    		}
		
    		//console.log( 'GoJS say graph is changed' );
    		Diagram___callOnNodeModelChanged();
    		Diagram__callOnNodeGraphSelectionChanged();
    //TODO: implement the commented lines from Graph.js
    //this.em.call.onGraphChanged();
    	}
    }
    function Diagram___callOnNodeModelChanged() {
    // TODO: implement the commented lines from Graph.js
    // 	if( this.onNodeGraphModelChanged ) {
    // 		const nodeData = this.onNodeGraphModelChanged.nodeData;
    // 		this.updateSystemNode( nodeData );
    // 		this.onNodeGraphModelChanged.callback( nodeData );
    // 	}
    }
    function Diagram__callOnNodeGraphSelectionChanged() {
    // TODO: implement the commented lines from Graph.js
    // 	if( this.onNodeGraphSelectionChanged ) {
    // 		const nodeData = this.onNodeGraphSelectionChanged.nodeData;
    // 		this.updateSystemNode( nodeData );
    // 		this.onNodeGraphSelectionChanged.callback( nodeData );
    // 	}
    }
    function Diagram__clearLastNodeKey() {
      State_set( 'd_lastNodeKey', null );
    }
    function Diagram__newUniqueKey( model ) {
      const d_lastNodeKey = State_get( 'd_lastNodeKey' );
    	// Generate a new positive key bigger than all keys in the model
    	let key = ( td_lastNodeKey? d_lastNodeKey+1: model.nodeDataArray.length );
    	while( model.findNodeDataForKey( key ) != null ) {
    		++key;
    	}
    	State_set( 'd_lastNodeKey', key );

    	return( key );
    }
    //------------------------
    // API Functions
    //------------------------
    function System_openEntity( data, onLoaded, x, y ) {
      if( data ) {
        if( data.isFile ) {
          // NOTE: Code would be like: Window_openWindow( data, onLoaded, x, y );
          Window_openWindow( data, onLoaded, x, y );
        } if( data.isDir ) {
          // NOTE: Code would be like: Diagram_openDiagram( data, onLoaded, x, y );
          Window_closeUnpinWindow();
          Diagram_openDiagram( data, onLoaded );
        }
      }
    }
    function System_openEntityFromSelection( x, y ) {
      const data = Diagram_getFirstSelectedData();
      System_openEntity( data, null, x, y );
    }
    function System_setDataField( dataOrKey, field, value ) {
      // TODO
    }
    function System_getData( dataOrKey ) {
      // TODO
    }
    //------------------------
    // Internal Functions
    //------------------------
    function System__openFromMenu() {
      const state = ContextMenu_getState();
      System_openEntityFromSelection( state.x, state.y );
    }
    function System__openNode( e, nodeEl ) {
      const x = e.diagram.lastInput.viewPoint.x;
      const y = e.diagram.lastInput.viewPoint.y;
      const data = Diagram__getNodeElData( nodeEl );
      System_openEntity( data, null, x, y );
    }
    //------------------------
    // API Functions
    //------------------------
    function ContextMenu_init() {
      const c = new Contextify(); // TODO: problem with zIndex 'contextMenuDiv' );
      const c_mainMenuModel = State_get( 'c_mainMenuModel' );
      c.setMenu( c_mainMenuModel, 'dark' );
      c.setProperty( 'zIndex', 10000 );
  
      State_set( 'c_contextMenu', c );
    }
    function ContextMenu_getState() {
      let result = {};
      const c = State_get( 'c_contextMenu' );
      if( c ) {
        result = c.getState();
      }
      return( result );
    }
    //------------------------
    // Internal Functions
    //------------------------
    // function ContextMenu__registerMenu() {
    //   document.addEventListener( "contextMenu", function(e) {
    //     //e.preventDefault();
    
    //     // Update context menu state
    //     const cp = State_get( 'c_contextMenuState' );
    //     cp.visible = true;
    //     cp.x = e.x;
    //     cp.y = e.y;
    
    //     // Show context menu
    //     const c = State_get( 'c_contextMenu' );
    //     c.show( cp.x, cp.y );
    //   });
    //   document.addEventListener( "click", function(e) {
    //     // Update context menu state
    //     const cp = State_get( 'c_contextMenuState' );
    //     cp.visible = false;
    
    //     // Hide context menu
    //     const c = State_get( 'c_contextMenu' );
    //     c.hide( true );
    //   });
    // }
    //------------------------
    // API Functions
    //------------------------
    function Diagram_zoomToFit() {
      const d = Diagram_getMainDiagram();
      if( d ) {
        const d_viewList = State_get( 'd_viewList' );
        if( d_viewList ) {
          // Store last view in ViewLast
      		d_viewList[0] = Diagram_getCurrentView();
        }
    		// Zoom to fit
        d.zoomToFit();
      }
    }
    function Diagram_storeView( index ) {
      const d_viewList = State_get( 'd_viewList' );
      if( d_viewList ) {
        d_viewList[index] = Diagram_getCurrentView();
      }
    }
    function Diagram_goToView( index ) {
      const d_viewList = State_get( 'd_viewList' );
      if( d_viewList && d_viewList[index] ) {
        if( d_viewList[index] != undefined ) {
          // Get current view
          const currentView = Diagram_getCurrentView();
    			// Go to new view
    			Diagram_setCurrentView( d_viewList[index] );
    			// Store in 0 previous view;
    			d_viewList[0] = currentView;
    		}
      }
    }
    //------------------------
    // Internal Functions
    //------------------------
    //------------------------
    // API Functions
    //------------------------
    function Diagram_toogleVisibleGrid() {
      const d = Diagram_getMainDiagram();
      if( d ) {
        d.grid.visible = !d.grid.visible
      }
    }
    //------------------------
    // API Functions
    //------------------------
    function Window_openWindow( data, onLoaded, x, y ) {
      // Initialize coordinates
      x = ( x != undefined? x: 100 );
      y = ( y != undefined? y: 100 );
      const width = 250;
      const height = 215;
  
      if( data ) {
        if( data.fileURL ) {
          // Set window property
          const title = data.label
          const url = data.fileURL;
          const wClass = 'modern'; // class is a reserved keyword
          const background = data.color || 'Plum';
      
          // Open window info
          const winInfo = { title, background, class: wClass, url,
                            x,  y,  width, height };
          new WinBox( winInfo );
        } else if( data.fileContent ) {
          //TODO
        }
      }
    }
    function Window_getWindow( data ) {
      // TODO: return the window managing the data
      //       It should be possible to apply
      //       w = Window_getWindow( data )
      //       src = Window_getSource( w )
    }
    //------------------------
    // Internal Functions
    //------------------------
    //------------------------
    // API Functions
    //------------------------
    /**
     * Returns an empty model 
     */
    function Diagram_getSource( isIndented ) {
      let result = Diagram_getEmptyJSONModel();
  
      const d = Diagram_getMainDiagram();
      if( d ) {
        const diagramPosition = d.position;
      	const jsonModel = Diagram_getJSONModel();
  	
      	// TODO: we could put DSL as nodes in the graph
      	//.      that gets included because the field
      	//         "isIncludeScript": true,
      	//       if we do that -> we don't need the next lines
      	//if( this.dslNameList.length == 0 ) {
      		//this.dslNameList = config.graph.defaultDSL;	
      	//}
  	
      	const sourceInfo = {
      		//dslNameList: this.dslNameList,
      		view: {
      			scale: d.scale,
      			position: [diagramPosition.x, diagramPosition.y],
      			isGridOn: d.grid.visible,
      		},
      		model: jsonModel,
      	};
      	if( isIndented ) {
      	  result = JSON.stringify( sourceInfo, null, 2 );
      	} else {
      	  result = JSON.stringify( sourceInfo );
      	}
      }
    	return( result );
    }
    function Diagram_setSource( source, onDone ) {
      // Get an object from the extended model
    		let objModel = null;
		
    		// Parse new source
    		if( source ) {
    		  try {
    			  objModel = JSON.parse( source );
    		  } catch( e ) {
    		    State_setError();
    		    setTimeout( State_setReady, 3*1000 ); // 3 seconds
		    
    		    if( onDone ) {
    		      onDone();
    		    }
    		    return;
    		  }
    		} else {
    			objModel = {
    				view: null,
    				dslNameList: null,
    				model: null,
    			};
    		}
		
    		// This is the finalization of the graph loading
    		const finalizeLoading = ()=> {
    			const d = Diagram_getMainDiagram();
          if( d ) {
            // Set Model (null is also ok)
            Diagram_setJSONModel( objModel.model );
        
            // Set last viewing settings
            if( objModel.view ) {
              if( objModel.view.scale != undefined ) {
                d.scale = objModel.view.scale;
              }
              if( objModel.view.position != undefined ) {
                const p = objModel.view.position;
                const x = ( p[0] != undefined? p[0]: 0 );
                const y = ( p[1] != undefined? p[1]: 0 );
                d.initialPosition = new go.Point( x, y );
              }
              if( objModel.view.isGridOn != undefined ) {
                d.grid.visible = objModel.view.isGridOn;
              }
            }
            // Set graphData (defined in ServerManager.js)
            diagramData = {};
          }
      
    			if( onDone ) {
    				onDone();
    			}
    		};
		
    // TODO: we could put DSL as nodes in the graph
    //       I comment out the code here bellow (see _getSource)
    // Here, if there are DSL to load
    // - then we load all DSL and only after we load the model/window (by finalizeLoading)
    // - otherwise we just load model/window (by finalizeLoading)
    // Set DSL
    // if( objModel.dslNameList ) {
    // 	this.loadDSLList( objModel.dslNameList, finalizeLoading );
    // } else {
    			finalizeLoading();
    //}
    }
    function Diagram_openDiagram( data, extOnLoaded ) {
      if( data && data.isDir ) {
        if( data.fileURL ) {
          console.log( 'Diagram open: ', data.fileURL );
          // Bellow we expect a loading function with 2 paramenters
          // - data: data node
          // - onLoaded: callback event
          const onLoaded = ( source )=> {
            console.log( 'Diagram Loaded: '+Diagram_getDataInfo( data, true ) );
            // Load source
            Diagram_setSource( source, extOnLoaded );
          };
          // NOTE: Code would be like: Loader_loadContent( data, onLoaded );
          Loader_loadContent( data, onLoaded );
        }
      }
    }
    function Diagram_saveDiagram( data, extOnLoaded ) {
      //TODO
      // Note the save funtion is inserted here
      // NOTE: Code would be like: Loader_saveContent( data, onSaved );
    }
    //------------------------
    // Internal Functions
    //------------------------
    //------------------------
    // API Functions
    //------------------------
    function Loader_loadContent( data, onLoaded ) {
      //********************************************
      // NOTE: for this function data will contain 
      //       its content in "fileContent"
      //********************************************
      if( ( data.fileURL != undefined ) && data.fileURL ) { // Check on fileURL must be first
        // Load content from file system
        Loader__openFile( data.fileURL, onLoaded );
      } else if( data.fileContent != undefined ) { // Check on fileContent must be third
        // Load content from node
        const source = data.fileContent;
    
        if( onLoaded ) {
          onLoaded( source );
        }
      } else {
        console.log( `Warning: no content could be loaded `+
                     `for ${Diagram_getDataInfo( data, true )}` );
        if( onLoaded ) {
          onLoaded( '' );
        }
      }
    }
    function Loader_saveContent( data, onSaved ) {
      //********************************************
      // NOTE: for this function data MUST always
      //      contain its content in "fileContent"
      //********************************************
      if( ( data.fileURL != undefined ) && data.fileURL ) { // Check on fileURL must be second
        const sourceEncoding = ( data.fileEncoding? data.fileEncoding: 'utf8' );
        const source = data.fileContent;
        Loader__saveFile( data.fileURL, source, onSaved, sourceEncoding );
      } else if( data.fileContent != undefined ) { // Check on fileContent must be third
        const source = data.fileContent;
        System_setDataField( data, 'fileContent', source );
    
        if( onSaved ) {
          onSaved();
        }
      } else {
        console.log( 'Warning: no content could be saved' );
        if( onSaved ) {
          onSaved();
        }
      }
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Loader__openFile( url, onLoad, noTimeStamp ) {
      // Decide if attach a timestamp or not (timestamp used to avoid chache)
      noTimeStamp = ( noTimeStamp != undefined? noTimeStamp: false );

      // Here we store the loaded source
      let source = '';
  
      // Open a new request to the server
      const request = new XMLHttpRequest();
  
      // Avoid server cache with timestamp
      if( !noTimeStamp ) {
        const timestamp = new Date().getTime();
        url = url+'?_='+timestamp;
      }
      // Open a get request
      request.open( 'GET', url, true );
  
      // Register error handler
      request.onerror = (e)=> {
        Loader__notifyError( e );
    
        if( onLoad ) {
          onLoad( source );
        }
      };

      try {
        // Send a request
        request.send( '' );
      } catch( e ) {
        Loader__notifyError( e );
    
        if( onLoad ) {
          onLoad( '' );
        }
      }
      // Handle state change
      request.onreadystatechange = function () {
        if( request.readyState === 4 ) {
          const status = request.status;
          if( ( status === 0 ) || ( ( status >= 200 ) && ( status < 400 ) ) ) {
            const type = request.getResponseHeader( 'Content-Type' );
            if( type.indexOf( 'text' ) !== 1 ) {
              source = request.responseText;
              console.log( 'Loaded from: '+url );
            } else {
              console.log( 'Unsupported Content-Type: '+type );
            }
          }
      
          if( onLoad ) {
            onLoad( source );
          }
        } else {
          // NOTE: you should not call the onLoad here!!!!!
          // Only readyState 4 is the end of the HTTP request
        }
      }
    }
    function Loader__saveFile( url, source, onSaveDone, sourceEncoding ) {
      // Execute this function if we are not in read only
      if( !State_isReadOnly() ) {
        // Open a new request to the server
        const request = new XMLHttpRequest();
    
        // Open a post request
        request.open( 'POST', '/fileServer' );
        // Set content type
        request.setRequestHeader( 'Content-Type', 'text/plain;charset=UTF-8' );
    
        // Register error handler
        request.onerror = (e)=> {
          Loader__notifyError( e );
      
          if( onSaveDone ) {
            onSaveDone();
          }
        };
        // Register event for notification of save done
        request.addEventListener( 'loadend', ()=> {
          if( onSaveDone ) {
            onSaveDone();
          }
        });
    
        console.log( 'Saving to: '+url );
        // Create package for saving content
        const fileInfo = { url, source, sourceEncoding, };
    
        try {
          // Send a request
          request.send( JSON.stringify( fileInfo ) );
        } catch( e ) {
          Loader__notifyError( e )
      
          if( onSaveDone ) {
            onSaveDone();
          }
        }
      } else {
        console.log( 'Read-only mode. No save request serverd' );
    
        if( onSaveDone ) {
          onSaveDone();
        }
      }
    }
    function Loader__notifyError( e ) {
      // In case of error -> generate an allert
      alert( 'Server not responding' );
      // Set the system on error
      setTimeout( State_setError, 2500 );  // 2.5 seconds
    }
    //------------------------
    // API Functions
    //------------------------
    function Window_alert( msg, isCenter ) {
      isCenter = ( isCenter == undefined? true: isCenter );
      new WinBox( 'Alert', {
        modal: true,
        autosize: true,
        background: 'Crimson',
        html: `<div style="margine: 0px;">`+
                `<pre style="${isCenter? 'text-align: center;':''}">`+
                  msg+
                `</pre>`+
              `</div>`,
      });
    }
    // Override standard alert function
    alert = Window_alert;
    function Window_openWindow( data, onLoaded, x, y ) {
      // If data is defined and can't put win on focus => open new
      if( data && !Window__tryFocusWindow( data ) ) {
    
        // Get window position (previous or default)
        const winLoc = Window__getLocation( data );
        // Initialize coordinates
        if( x != undefined ) {
          winLoc[0] = x;
        }
        if( y != undefined ) {
          winLoc[1] = y;
        }
    
        // Create window info
        const winInfo = Window__createWinInfo( data, winLoc );
        // Open a new window
        const win = new WinBox( winInfo );
        Window__customizeWindow( win, { key: data.key } );
    
        // Store window position and status
        Window__setLocation( data, winLoc );
        Window__setOpenWindow( data, win );
      }
    }
    function Window_tooglePin( data ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const ol = State_get( 'w_openList' );
        if( !ol[dURL] ) {
          ol[dURL] = {}; 
        }
        const key = data.key;
        ol[dURL][key].isPin = !ol[dURL][key].isPin;
      }
    }
    function Window_isPin( data ) {
      let result = false;
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const key = data.key;
        const ol = State_get( 'w_openList' );
        if( ol[dURL] && ol[dURL][key] ) {
          result = ol[dURL][key].isPin;
        }
      }
      return( result );
    }
    function Window_getWindow( data ) {
      // TODO: return the window managing the data
      //       It should be possible to apply
      //       w = Window_getWindow( data )
      //       src = Window_getSource( w )
    }
    function Window_closeUnpinWindow() {
      const dURL = Diagram_getDiagramURL();
      const wl = State_get( 'w_winList' );
      const winList = wl[dURL];
      if( winList ) {
        for( const key in winList ) {
          const win = winList[key];
          if( win ) {
            const data = { key };
            if( !Window_isPin( data ) ) {
              win.close();
            }
          }
        }
      }
    }
    function Window_closeAllWindow() {
      const dURL = Diagram_getDiagramURL();
      const wl = State_get( 'w_winList' );
      const winList = wl[dURL];
      if( winList ) {
        for( const key in winList ) {
          const win = winList[key];
          if( win ) {
            win.close();
          }
        }
      }
    }
    //------------------------
    // Internal Functions
    //------------------------
    function Window__getLocation( data ) {
      let result = [10, 10, 250, 200]; // Default window pos/size
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const pl = State_get( 'w_positionList' );
        let winList = pl[dURL];
        if( winList ) {
          const key = data.key;
          const winPos = winList[key];
          if( winPos ) {
            result = winPos;
          }
        }
      }
      return( result );
    }
    function Window__setLocation( data, winPos ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const pl = State_get( 'w_positionList' );
        if( !pl[dURL] ) {
          pl[dURL] = {};
        }
        const key = data.key;
        pl[dURL][key] = winPos;
      }
    }
    function Window__setPosition( data, x, y ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const pl = State_get( 'w_positionList' );
        if( !pl[dURL] ) {
          pl[dURL] = {};
        }
        const key = data.key;
        if( pl[dURL][key] ) {
          pl[dURL][key][0] = x;
          pl[dURL][key][1] = y;
        } else {
          pl[dURL][key] = [x, y, 250, 200];
        }
      }
    }
    function Window__setSize( data, w, h ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const pl = State_get( 'w_positionList' );
        if( !pl[dURL] ) {
          pl[dURL] = {};
        }
        const key = data.key;
        if( pl[dURL][key] ) {
          pl[dURL][key][2] = w;
          pl[dURL][key][3] = h;
        } else {
          pl[dURL][key] = [10, 10, w, h];
        }
      }
    }
    function Window__setOpenWindow( data, win ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const ol = State_get( 'w_openList' );
        if( !ol[dURL] ) {
          ol[dURL] = {}; 
        }
        const key = data.key;
        ol[dURL][key] = { isPin: false };

        const wl = State_get( 'w_winList' );
        if( !wl[dURL] ) {
          wl[dURL] = {}; 
        }
        wl[dURL][key] = win;
      }
    }
    function Window__tryFocusWindow( data ) {
      let result = false;
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        const wl = State_get( 'w_winList' );
        const winList = wl[dURL];
        if( winList ) {
          const key = data.key;
          const win = winList[key];
          if( win ) {
            win.focus( true );
            result = true;
          }
        }
      }
      return( result );
    }
    function Window__createWinInfo( data, winLoc ) {
      // Set window property
      const title = data.label
      const url = data.fileURL;
      const wClass = 'modern'; // class is a reserved keyword
      const background = data.color || 'Plum';

      // Window info
      const winInfo = { 
        title, background, class: wClass,
        x: winLoc[0],     y: winLoc[1],
        width: winLoc[2], height: winLoc[3],
        onmove: (x,y)=>{
          Window__setPosition( data, x, y );
        },
        onresize: (w,h)=>{
          Window__setSize( data, w, h );
        },
        onclose: (e)=>{
          Window__removeWindow( data );
        },
      };

      if( data.fileURL ) {
        winInfo.url = data.fileURL;
      } else if( data.fileContent ) {

      }

      return( winInfo );
    }
    function Window__customizeWindow( win, dataKey ) {
      win.removeControl("wb-max");
      win.addControl({
          index: 2,
          class: "wb-like",
          image: "/fileServer/pictures/unpinnedw.svg",
          click: function( event, winbox ) {
              // the winbox instance will be passed as 2nd parameter
              // console.log(winbox.id);
              // "this" refers to the button which was clicked:
              this.classList.toggle( "active" );
              Window_tooglePin( dataKey );
          }
      });
    }
    function Window__removeWindow( data ) {
      if( data ) {
        const dURL = Diagram_getDiagramURL();
        // Remove from winList
        const wl = State_get( 'w_winList' );
        const winList = wl[dURL];
        if( winList ) {
          const key = data.key;
          if( winList[key] ) {
            delete winList[key];
          }
        }
        // Remove from openList
        const ol = State_get( 'w_openList' );
        const openList = ol[dURL];
        if( openList ) {
          const key = data.key;
          if( openList[key] ) {
            delete openList[key];
          }
        }
      }
    }
  </script>
<body onload="HyperGraph_init()">
  <div id="statusDiv" style="z-index: 20000;"></div>
  <!--div id="diagram" class='diagramDiv' ondrop="dropHandler(event)" ondragover="dragOverHandler(event)"-->
  <div id="diagramDiv" class='diagramDiv'>
  </div>
  <div id='windowDiv'>
    <!--div id="editorjs"></div-->
  </div>
  <div id="contextMenuDiv" style="position: relative; z-index: 10000;"></div>
</body>
</html>