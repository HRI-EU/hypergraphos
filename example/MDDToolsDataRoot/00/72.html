<!DOCTYPE html>
<html>
  <script type="text/javascript" src="/library/gojs/2.1/go.js"></script>
  <style type="text/css">
    /* CSS for the traditional context menu */
    .menu {
      display: none;
      position: absolute;
      opacity: 0;
      margin: 0;
      padding: 8px 0;
      z-index: 999;
      box-shadow: 0 5px 5px -3px rgba(0, 0, 0, .2), 0 8px 10px 1px rgba(0, 0, 0, .14), 0 3px 14px 2px rgba(0, 0, 0, .12);
      list-style: none;
      background-color: #ffffff;
      border-radius: 4px;
      width: max-content;
    }

    .menu-item-separator {
      margin-block-start: 0;
      margin-block-end: 0;
      margin-left: 10px;
      margin-right: 10px;
    }

    .menu-item b {
      float: right;
    }
    .menu-item {
      display: block;
      position: relative;
      min-width: 60px;
      margin: 0;
      padding: 6px 16px;
      font: bold 12px sans-serif;
      color: rgb(59, 59, 59);
      cursor: pointer;
    }

    .menu-item::before {
      position: absolute;
      top: 0;
      left: 0;
      opacity: 0;
      pointer-events: none;
      content: "";
      width: 100%;
      height: 100%;
      background-color: #000000;
    }

    .menu-item:hover::before {
      opacity: .2;
    }

    .menu .menu {
      top: -8px;
      left: 100%;
    }

    .show-menu, .menu-item:hover > .menu {
      display: block;
      opacity: 0.92;
    }
  </style>
  <script>
    var $ = go.GraphObject.make;  // for conciseness in defining templates
    let myDiagram = null;
  
    console.log('00000000000000000000000000000000000000000000000000000000000000000000000');
    //window.parent.debug();
    
    class HTMLMenu {
      constructor( diagram, parentId ) {
        this.menuList = {};
        this.diagram = diagram;
        this.parentId = parentId;

        this.hideCX = ()=> {
          if ( this.diagram.currentTool instanceof go.ContextMenuTool) {
            this.diagram.currentTool.doCancel();
          }
        }
      }
      add( menuListData, itemName, divParentId ) {
        divParentId = ( !divParentId? this.parentId: divParentId );

        const addItem = (name, data)=> {
          // If we did not add already the menu => we add
          if( !this.menuList[name] ) {
            // Start creation from root
            const parent = document.getElementById( divParentId );
            // Collect menu info
            const menuData = {
              parent,
              name,
              data,
              contextMenu: null,
            };
            
            // Create context menu
            const menuElement = this._createDOMMenu( menuData );
            menuData.menuElement = menuElement;
            
            // Store the new menu
            this.menuList[name] = menuData;
            
            // We don't want the div acting as a context menu to have a (browser) context menu!
            menuElement.addEventListener( "contextmenu", function(e) {
              e.preventDefault();
              return false;
            }, false);
          }
        }

        if( itemName ) {
          // Data of the menu (items, ...)
          const data = menuListData[itemName];
          addItem( itemName, data );
        } else {
          for( const name in menuListData ) {
            // Data of the menu (items, ...)
            const data = menuListData[name];
            addItem( name, data );
          }
        }
      }
      get( name ) {
        return( this.menuList[name] );
      }
      getGoJSMenu( name ) {
        const contextMenu = $(go.HTMLInfo, {
          show: this.getShowCallback( name ),
          hide: this.getHideCallback( name ),
        });
        return( contextMenu );
      }
      getShowCallback( name ) {
        const menuData = this.get( name );
        // This is the actual HTML context menu:
        const cxElement = menuData.menuElement;
        
        const showCM = ( obj, diagram, tool )=> {
          const hasMenuItem = this._show( name, obj );
          
          // Now show the whole context menu element
          if( hasMenuItem ) {
            cxElement.classList.add( "show-menu" );
            // we don't bother overriding positionContextMenu, we just do it here:
            const mousePt = diagram.lastInput.viewPoint;
            this._computeXY( mousePt, cxElement );
            cxElement.style.left = mousePt.x + 5 + "px";
            cxElement.style.top = mousePt.y + "px";
          }
    
          // Optional: Use a `window` click listener with event capture to
          //           remove the context menu if the user clicks elsewhere on the page
          window.addEventListener( "click", this.hideCX, true );
        };
        return( showCM );
      }
      getHideCallback( name ) {
        const menuData = this.get( name );
        // This is the actual HTML context menu:
        const cxElement = menuData.menuElement;
        
        const hideCM = ()=> {
          cxElement.classList.remove( "show-menu" );
          // Optional: Use a `window` click listener with event capture to
          //           remove the context menu if the user clicks elsewhere on the page
          window.removeEventListener( "click", this.hideCX, true );
        };
        return( hideCM );
      }
      _show( name, obj ) {
        const menuData = this.get( name );
        let hasMenuItem = false;
        
        const d = {
          diagram: this.diagram,
          tool: this.diagram.currentTool,
          cmd: this.diagram.commandHandler,
          cmt: this.diagram.toolManager.contextMenuTool,
        }
        
        const showMenu = ( menuData )=> {
          for( const item of menuData.data ) {
            const o = {
              item,
              obj,
              d,
            };
            if( item.label.startsWith( '---' ) ) {
              if( item.if == undefined || item.if( o ) ) {
                item.element.style.display = "block";
              } else {
                item.element.style.display = "none";
              }
            } else {
              if( item.if == undefined || item.if( o ) ) {
                item.element.style.display = "block";
                hasMenuItem = true;
                if( item.sub ) {
                  const subMenuData = {
                    data: item.sub,
                  };
                  showMenu( subMenuData );
                }
              } else {
                item.element.style.display = "none";
              }
            }
          }
        }
        showMenu( menuData );
        return( hasMenuItem );
      }
      _createDOMMenu( menuData ) {
        const d = {
          diagram: this.diagram,
          tool: this.diagram.currentTool,
          cmd: this.diagram.commandHandler,
          cmt: this.diagram.toolManager.contextMenuTool,
        }
        const createMenu = ( menuData )=> {
          // Check if the menu has been already created
          let ul = menuData.parent[menuData.name];
          // if not created => create it
          if( !ul ) {
            // Create ul element 
            ul = document.createElement( 'ul' );
            ul.id = menuData.name;
            ul.className = 'menu';
            menuData.parent.appendChild( ul );
            
            // Create li elements
            for( const item of menuData.data ) {
              if( item.label.startsWith( '---' ) ) {
                const hr = document.createElement( 'hr' );
                hr.className = 'menu-item-separator';
                item.element = hr;
                ul.appendChild( hr );
              } else {
                // We create the element first
                const li = document.createElement( 'li' );
                li.id = item.label;
                li.className = 'menu-item';
                li.innerHTML = item.label+( item.sub? '<b>&#9656</b>': '' );
                item.element = li;
                
                let clickParam = {
                  item,
                  d,
                };
                li.onclick = ( event )=> { clickParam.event = event; if( item.do ) item.do( clickParam ) };
                ul.appendChild( li );
                
                if( item.sub ) {
                  const subMenuData = {
                    parent: li,
                    name: '',
                    data: item.sub,
                    d,
                  };
                  createMenu( subMenuData );
                }
              }
            }
          }
          return( ul );
        }
        
        const ul = createMenu( menuData );
        return( ul );
      }
      _computeXY( mousePoint, element ) {
        // Correct x,y so that the element is fully visible
        // in the browser (does not go bellow the browser height/width)
        const style = getComputedStyle( element );
        const sw = parseInt( style.width );
        const sh = parseInt( style.height );
        const bw = window.innerWidth;  // Browser width
        const bh = window.innerHeight; // Browser height

        mousePoint.x = ( bw-(mousePoint.x+100) < sw? bw-sw-50: mousePoint.x );
        mousePoint.y = ( bh-(mousePoint.y+100) < sh? bh-sh-50: mousePoint.y );
      }
    }
  
    // if: ( o )=> {} where o has properties
    //  o.item    = selected menu data item
    //  o.obj     = selected node in graph
    //  o.d.diagram = diagram
    //  o.d.tool    = diagram.currentTool,
    //  o.d.cmd     = diagram.commandHandler;
    //  o.d.cmt     = diagram.toolManager.contextMenuTool
    // do: ( o )=> {} where e has properties
    //  o.item    = selected menu data item
    //  o.event   = DOM event
    //  o.d.diagram = diagram
    //  o.d.tool    = diagram.currentTool,
    //  o.d.cmd     = diagram.commandHandler;
    //  o.d.cmt     = diagram.toolManager.contextMenuTool
    const menu = {
      'nodeMenu': [
        { label: 'cut',         if: ( o )=> o.d.cmd.canCutSelection(),
                                do: ( o )=> o.d.cmd.cutSelection() },
        { label: 'copy',        if: ( o )=> o.d.cmd.canCopySelection(),
                                do: ( o )=> o.d.cmd.copySelection() },
        { label: 'paste',       if: ( o )=> o.d.cmd.canPasteSelection( o.d.cmt.mouseDownPoint ),
                                do: ( o )=> o.d.cmd.pasteSelection( o.d.cmt.mouseDownPoint ) },
        { label: 'delete',      if: ( o )=> o.d.cmd.canDeleteSelection(),
                                do: ( o )=> o.d.cmd.deleteSelection() },
        { label: 'color',       if: ( o )=> o.obj !== null, 
                                sub:[
            { label: 'red',     if: ( o )=> { o.item.element.style['backgroundColor'] = '#f38181';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeNodeColor( o.d.diagram, color ); } },
            { label: 'green',   if: ( o )=> { o.item.element.style['backgroundColor'] = '#eaffd0';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeNodeColor( o.d.diagram, color ); } },
            { label: 'blue',    if: ( o )=> { o.item.element.style['backgroundColor'] = '#95e1d3';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeNodeColor( o.d.diagram, color ); } },
            { label: 'yellow',  if: ( o )=> { o.item.element.style['backgroundColor'] = '#fce38a';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeNodeColor( o.d.diagram, color ); } },
          ]},
      ],
      'diagramMenu': [
        { label: 'CUT',         if: ( o )=> o.d.cmd.canCutSelection(),
                                do: ( o )=> o.d.cmd.cutSelection() },
        { label: 'COPY',        if: ( o )=> o.d.cmd.canCopySelection(),
                                do: ( o )=> o.d.cmd.copySelection() },
        { label: 'PASTE',       if: ( o )=> o.d.cmd.canPasteSelection( o.d.cmt.mouseDownPoint ),
                                do: ( o )=> o.d.cmd.pasteSelection( o.d.cmt.mouseDownPoint ) },
        { label: 'DELETE',      if: ( o )=> o.d.cmd.canDeleteSelection(),
                                do: ( o )=> o.d.cmd.deleteSelection() },
        { label: 'COLOR',       if: ( o )=> true, 
                                sub:[
            { label: 'red',     if: ( o )=> { o.item.element.style['backgroundColor'] = '#f38181';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeDiagramColor( o.d.diagram, color ); } },
            { label: 'green',   if: ( o )=> { o.item.element.style['backgroundColor'] = '#eaffd0';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeDiagramColor( o.d.diagram, color ); } },
            { label: 'blue',    if: ( o )=> { o.item.element.style['backgroundColor'] = '#95e1d3';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeDiagramColor( o.d.diagram, color ); } },
            { label: 'yellow',  if: ( o )=> { o.item.element.style['backgroundColor'] = '#fce38a';
                                              return( true ); },
                                do: ( o )=> { const color = window.getComputedStyle( o.event.target )['backgroundColor'];
                                              changeDiagramColor( o.d.diagram, color ); } },
          ]},
      ],
    };
     
    function init() {
      myDiagram =
      $(go.Diagram, "myDiagramDiv",  // create a Diagram for the DIV HTML element
        {
          "undoManager.isEnabled": true
        });
      
      // Create context menu
      const cm = new HTMLMenu( myDiagram, 'contextMenuContainer' );
      cm.add( menu );
      
      // an HTMLInfo object is needed to invoke the code to set up the HTML cxElement
      const nodeContextMenu = $(go.HTMLInfo, {
        show: cm.getShowCallback( 'nodeMenu' ),
        hide: cm.getHideCallback( 'nodeMenu' ),
      });
      // an HTMLInfo object is needed to invoke the code to set up the HTML cxElement
      const diagramContextMenu = $(go.HTMLInfo, {
        show: cm.getShowCallback( 'diagramMenu' ),
        hide: cm.getHideCallback( 'diagramMenu' ),
      });
      myDiagram.contextMenu = diagramContextMenu;
        
      // define a simple Node template (but use the default Link template)
      myDiagram.nodeTemplate =
        $(go.Node, "Auto",
          { contextMenu: nodeContextMenu },
          $(go.Shape, "RoundedRectangle",
            // Shape.fill is bound to Node.data.color
            new go.Binding("fill", "color")),
          $(go.TextBlock,
            { margin: 3 },  // some room around the text
            // TextBlock.text is bound to Node.data.key
            new go.Binding("text", "key"))
        );
  
      // create the model data that will be represented by Nodes and Links
      myDiagram.model = new go.GraphLinksModel(
        [
          { key: "Alpha", color: "#f38181" },
          { key: "Beta", color: "#eaffd0" },
          { key: "Gamma", color: "#95e1d3" },
          { key: "Delta", color: "#fce38a" }
        ],
        [
          { from: "Alpha", to: "Beta" },
          { from: "Alpha", to: "Gamma" },
          { from: "Beta", to: "Beta" },
          { from: "Gamma", to: "Delta" },
          { from: "Delta", to: "Alpha" }
        ]
      );
    }
    
    // A custom command, for changing the color of the selected node(s).
    function changeDiagramColor(diagram, color) {
      // Always make changes in a transaction, except when initializing the diagram.
      diagram.startTransaction("change color");
      diagram.div.style.background = color;
      diagram.commitTransaction("change color");
    }    
    // A custom command, for changing the color of the selected node(s).
    function changeNodeColor(diagram, color) {
      // Always make changes in a transaction, except when initializing the diagram.
      diagram.startTransaction("change color");
      diagram.selection.each(function(node) {
        if (node instanceof go.Node) {  // ignore any selected Links and simple Parts
          // Examine and modify the data, not the Node directly.
          var data = node.data;
          // Call setDataProperty to support undo/redo as well as
          // automatically evaluating any relevant bindings.
          diagram.model.setDataProperty(data, "color", color);
        }
      });
      diagram.commitTransaction("change color");
    }
    window.addEventListener('DOMContentLoaded', init);
  </script>
  <body style="background-color: lightgray;">
    <div id="contextMenuContainer" style="position: relative; zIndex: 10000;"></div>
    <div id="myDiagramDiv" style="border: solid 1px black; width:400px; height:400px"></div>
  </body>
</html>

